{"version":3,"sources":["webpack:///../core/src/tools/display.ts","webpack:///../core/src/tools/catchUserErrors.ts","webpack:///../core/src/tools/monitor.ts","webpack:///../core/src/tools/utils.ts","webpack:///../core/src/tools/contextManager.ts","webpack:///../core/src/tools/boundedBuffer.ts","webpack:///../core/src/tools/timeUtils.ts","webpack:///../core/src/browser/cookie.ts","webpack:///../core/src/domain/synthetics/syntheticsWorkerValues.ts","webpack:///../core/src/transport/eventBridge.ts","webpack:///../core/src/domain/tracekit/computeStackTrace.ts","webpack:///../core/src/tools/error.ts","webpack:///../core/src/domain/configuration/experimentalFeatures.ts","webpack:///../core/src/tools/urlPolyfill.ts","webpack:///../core/src/domain/configuration/intakeSites.ts","webpack:///../core/src/domain/configuration/endpointBuilder.ts","webpack:///../core/src/domain/configuration/tags.ts","webpack:///../core/src/domain/configuration/transportConfiguration.ts","webpack:///../core/src/domain/configuration/configuration.ts","webpack:///../core/src/tools/observable.ts","webpack:///../core/src/domain/telemetry/rawTelemetryEvent.types.ts","webpack:///../core/src/domain/telemetry/telemetry.ts","webpack:///../rum-core/src/browser/domMutationObservable.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/resourceUtils.ts","webpack:///../rum-core/src/domain/tracing/getDocumentTraceId.ts","webpack:///../rum-core/src/browser/viewportObservable.ts","webpack:///../rum-core/src/domain/contexts/displayContext.ts","webpack:///../rum-core/src/browser/performanceCollection.ts","webpack:///../core/src/tools/createEventRateLimiter.ts","webpack:///../core/src/tools/limitModification.ts","webpack:///../rum-core/src/domain/contexts/syntheticsContext.ts","webpack:///../rum-core/src/domain/assembly.ts","webpack:///../rum-core/src/domain/contexts/ciTestContext.ts","webpack:///../rum-core/src/domain/contexts/foregroundContexts.ts","webpack:///../rum-core/src/domain/lifeCycle.ts","webpack:///../core/src/browser/xhrObservable.ts","webpack:///../core/src/domain/session/sessionConstants.ts","webpack:///../core/src/tools/contextHistory.ts","webpack:///../core/src/tools/instrumentMethod.ts","webpack:///../core/src/browser/fetchObservable.ts","webpack:///../rum-core/src/domain/tracing/tracer.ts","webpack:///../rum-core/src/domain/requestCollection.ts","webpack:///../rum-core/src/domain/trackEventCounts.ts","webpack:///../rum-core/src/domain/waitPageActivityEnd.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/clickChain.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/getActionNameFromElement.ts","webpack:///../core/src/tools/browserDetection.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/getSelectorsFromElement.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/listenActionEvents.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/computeFrustration.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/trackClickActions.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/actionCollection.ts","webpack:///../core/src/domain/tracekit/tracekit.ts","webpack:///../core/src/domain/console/consoleObservable.ts","webpack:///../core/src/domain/report/reportObservable.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackFirstHidden.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/errorCollection.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/trackConsoleError.ts","webpack:///../core/src/domain/error/trackRuntimeError.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/trackReportError.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/matchRequestTiming.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/resourceCollection.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackInitialViewTimings.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackViewMetrics.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackViews.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/viewCollection.ts","webpack:///../core/src/domain/session/sessionCookieStore.ts","webpack:///../core/src/domain/session/sessionStore.ts","webpack:///../core/src/domain/session/sessionManager.ts","webpack:///../core/src/domain/session/oldCookiesMigration.ts","webpack:///../rum-core/src/domain/rumSessionManager.ts","webpack:///../core/src/transport/batch.ts","webpack:///../core/src/transport/sendWithRetryStrategy.ts","webpack:///../core/src/transport/httpRequest.ts","webpack:///../rum-core/src/transport/startRumBatch.ts","webpack:///../rum-core/src/browser/locationChangeObservable.ts","webpack:///./src/types/sessionReplayConstants.ts","webpack:///./src/constants.ts","webpack:///./src/domain/record/privacy.ts","webpack:///./src/domain/record/serializationUtils.ts","webpack:///./src/domain/record/utils.ts","webpack:///./src/domain/record/serialize.ts","webpack:///./src/domain/record/mutationBatch.ts","webpack:///./src/domain/record/mutationObserver.ts","webpack:///./src/domain/record/viewports.ts","webpack:///./src/domain/record/observers.ts","webpack:///./src/domain/record/record.ts","webpack:///./src/domain/record/elementsScrollPositions.ts","webpack:///./src/domain/replayStats.ts","webpack:///./src/domain/segmentCollection/segment.ts","webpack:///./src/domain/segmentCollection/deflateWorker.js","webpack:///./src/domain/segmentCollection/segmentCollection.ts","webpack:///./src/domain/segmentCollection/startDeflateWorker.ts","webpack:///./src/transport/send.ts","webpack:///./src/entries/main.ts","webpack:///../core/src/boot/init.ts","webpack:///./src/boot/recorderApi.ts","webpack:///./src/boot/startRecording.ts","webpack:///../rum-core/src/boot/rumPublicApi.ts","webpack:///../rum-core/src/domain/configuration.ts","webpack:///../rum-core/src/boot/startRum.ts","webpack:///../rum-core/src/transport/startRumEventBridge.ts","webpack:///../rum-core/src/domain/contexts/viewContexts.ts","webpack:///../rum-core/src/domain/contexts/urlContexts.ts","webpack:///../rum-core/src/domain/rumEventsCollection/longTask/longTaskCollection.ts","webpack:///../rum-core/src/domain/contexts/internalContext.ts"],"names":["ConsoleApiName","log","debug","info","warn","error","display","api","Object","prototype","hasOwnProperty","call","args","catchUserErrors","fn","errorMsg","err","console","bind","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","monitor","callMonitored","this","arguments","context","apply","e","displayIfDebugEnabled","ONE_SECOND","ONE_MINUTE","throttle","wait","options","pendingExecutionWithParameters","pendingTimeoutId","needLeadingExecution","undefined","leading","needTrailingExecution","trailing","inWaitPeriod","throttled","parameters","setTimeout","cancel","clearTimeout","target","toAssign","forEach","source","key","shallowClone","object","generateUUID","placeholder","parseInt","Math","random","toString","replace","performDraw","threshold","round","num","decimals","toFixed","noop","jsonStringify","value","space","JSON","stringify","circularReferenceChecker","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","Array","restoreValuePrototypeToJson","getPrototypeOf","restoreValueToJson","createCircularReferenceChecker","_key","type","getType","hasAlreadyBeenSeen","objectToJson","toJSON","includes","candidate","search","indexOf","arrayFrom","arrayLike","from","array","Set","item","push","i","length","find","predicate","isPercentage","isNumber","objectValues","keys","map","objectEntries","isEmptyObject","startsWith","slice","getGlobalObject","globalThis","defineProperty","get","configurable","globalObject","_dd_temp_","self","window","getLinkElementOrigin","element","origin","sanitizedHost","host","protocol","findCommaSeparatedValue","rawString","name","matches","RegExp","exec","safeTruncate","suffix","lastChar","charCodeAt","correctedLength","addEventListener","emitter","event","listener","addEventListeners","events","once","capture","passive","wrappedListener","stop","removeEventListener","runOnReadyState","expectedReadyState","callback","document","readyState","isArray","WeakMap","has","set","mergeInto","destination","Date","getTime","flags","global","ignoreCase","multiline","sticky","unicode","join","merged","deepClone","combine","sources","matchList","list","some","test","cssEscape","str","CSS","escape","ch","asCodePoint","createContextManager","add","remove","newContext","getContext","setContext","setContextProperty","property","removeContextProperty","clearContext","navigationStart","buffer","splice","drain","relativeToClocks","relative","timeStamp","getCorrectedTimeStamp","relativeTime","correctedOrigin","dateNow","performance","now","getNavigationStart","addDuration","getTimeStamp","toServerDuration","duration","timeStampNow","relativeNow","clocksNow","clocksOrigin","elapsed","start","end","a","b","getRelativeTime","timestamp","timing","getCookieOverride","setCookieOverride","getCurrentSiteCache","setCookieHandling","getCookie","setCookie","expireDelay","date","setTime","expires","toUTCString","sameSite","crossSite","domain","secure","cookie","deleteCookie","willSyntheticsInjectRum","Boolean","_DATADOG_SYNTHETICS_INJECTS_RUM","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getAllowedWebViewHosts","parse","send","eventType","canUseEventBridge","currentHost","location","hostname","bridge","allowedHost","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","String","split","line","stackFrame","parts","CHROME_LINE_RE","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","url","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","enabledExperimentalFeatures","isURLSupported","ErrorSource","computeRawError","stackTrace","originalError","handlingStack","startClocks","nonErrorPrefix","handling","Error","toStackTraceString","causes","flattenErrorCauses","result","formatErrorMessage","frame","createHandlingStack","formattedStack","parentSource","currentError","cause","isExperimentalFeatureEnabled","featureName","getExperimentalFeatures","normalizeUrl","buildUrl","href","getOrigin","base","URL","checkURLSupported","doc","anchorElement","createElement","baseElement","implementation","createHTMLDocument","head","appendChild","body","INTAKE_SITE_US1","ENDPOINTS","logs","rum","sessionReplay","INTAKE_TRACKS","createEndpointBuilder","initConfiguration","endpointType","tags","site","clientToken","domainParts","extension","pop","baseUrl","proxyUrl","build","encodeURIComponent","concat","endpointUrl","buildIntakeUrl","FORBIDDEN_CHARACTERS","buildTag","rawValue","valueSizeLimit","sanitizedValue","computeTransportConfiguration","configuration","env","service","version","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","intakeEndpoints","builder","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","isIntakeUrl","intakeEndpoint","DefaultPrivacyLevel","ALLOW","MASK","MASK_USER_INPUT","validateAndBuildConfiguration","sampleRate","telemetrySampleRate","telemetryConfigurationSampleRate","enabledFeatures","enableExperimentalFeatures","filter","flag","beforeSend","cookieOptions","buildCookieOptions","silentMultipleInit","batchBytesLimit","eventRateLimiterThreshold","maxTelemetryEventsPerPage","flushTimeout","batchMessagesLimit","messageBytesLimit","useSecureSessionCookie","useCrossSiteSessionCookie","mustUseSecureCookie","trackSessionAcrossSubdomains","testCookieName","domainLevels","candidateDomain","getCurrentSite","onFirstSubscribe","observers","subscribe","f","onLastUnsubscribe","unsubscribe","other","notify","data","observer","mergeObservables","globalObservable","Observable","subscriptions","observables","observable","subscription","onRawTelemetryEventCollected","TelemetryType","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","telemetryConfiguration","maxEventsPerPage","sentEventCount","telemetryEnabled","telemetryConfigurationEnabled","startTelemetry","telemetryService","contextProvider","_dd","format_version","telemetry","experimental_features","toTelemetryEvent","addTelemetryError","setContextProvider","provider","addTelemetryDebug","addTelemetry","status","kind","scrubCustomerFrames","formatError","allowedFrameUrl","getMutationObserverConstructor","constructor","browserWindow","Zone","zoneSymbol","__symbol__","MutationObserver","originalInstance","FAKE_INITIAL_DOCUMENT","RESOURCE_TYPES","initiatorType","_","path","computeResourceKind","isValidUrl","pathname","getPathName","isType","areInOrder","numbers","computePerformanceResourceDetails","entry","validEntry","toValidEntry","startTime","fetchStart","redirectStart","redirectEnd","domainLookupStart","domainLookupEnd","connectStart","secureConnectionStart","connectEnd","requestStart","responseStart","details","download","formatTiming","first_byte","connect","ssl","dns","hasRedirection","redirect","responseEnd","computeSize","decodedBodySize","isAllowedRequestUrl","viewportObservable","viewport","getDocumentTraceId","traceIdMeta","querySelector","traceTimeMeta","createDocumentTraceData","content","getDocumentTraceDataFromMeta","comment","childNodes","getTraceCommentFromNode","node","isTextNode","findTraceComment","getDocumentTraceDataFromComment","traceTime","traceId","rawTraceTime","Number","nodeName","isCommentNode","match","supportPerformanceObject","supportPerformanceTimingEvent","entryType","PerformanceObserver","supportedEntryTypes","startPerformanceCollection","lifeCycle","handleRumPerformanceEntries","forcedAttributes","getEntriesByType","relativePerformanceTiming","computeRelativePerformanceTiming","getEntries","entries","mainEntries","experimentalEntries","observe","buffered","entryTypes","clearResourceTimings","sendFakeTiming","retrieveNavigationTiming","startTimeStamp","timingSent","removeEventListeners","evt","cancelable","processingStart","sendTimingIfPointerIsNotCancelled","sendTiming","delay","retrieveFirstInputTiming","numberKey","timingElement","rumAllowedPerformanceEntries","loadEventEnd","isIncompleteNavigation","isForbiddenResource","createEventRateLimiter","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","current","field","isValidObjectContaining","fields","getSyntheticsContext","testId","_DATADOG_SYNTHETICS_PUBLIC_ID","resultId","_DATADOG_SYNTHETICS_RESULT_ID","getSyntheticsResultId","test_id","result_id","injected","initViewportObservable","updateDimension","getViewportDimension","visual","visualViewport","width","scale","height","innerWidth","innerHeight","getDisplayContext","viewportDimension","VIEW_EVENTS_MODIFIABLE_FIELD_PATHS","OTHER_EVENTS_MODIFIABLE_FIELD_PATHS","startRumAssembly","sessionManager","viewContexts","urlContexts","actionContexts","getCommonContext","reportError","eventRateLimiters","syntheticsContext","ciTestContext","testExecutionId","Cypress","test_execution_id","getCiTestContext","rawRumEvent","domainContext","savedCommonContext","customerContext","viewContext","findView","urlContext","findUrl","session","findTrackedSession","commonContext","actionId","findActionId","serverRumEvent","drift","plan","browser_sdk_version","application","id","view","referrer","action","synthetics","ci_test","has_replay","hasReplay","user","usr","modifiableFieldPaths","modifier","clone","originalValue","newValue","originalType","newType","limitModification","shouldSend","foregroundPeriods","startForegroundContexts","hasFocus","addNewForegroundPeriod","onFocusChange","onBlurChange","stopForegroundTracking","isTrusted","stopBlurTracking","closeForegroundPeriod","isInForegroundAt","selectInForegroundPeriodsFor","currentForegroundPeriod","foregroundPeriod","eventStartTime","eventEndTime","filteredForegroundPeriods","earliestIndex","max","startDuration","endDuration","unshift","xhrObservable","callbacks","eventCallbacks","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","END_OF_TIMES","Infinity","clearOldContextsInterval","setInterval","clearOldContexts","endTime","index","close","closeActive","latestEntry","findAll","reset","clearInterval","oldTimeThreshold","instrumentMethod","method","instrumentationFactory","original","instrumentation","instrumentationWrapper","instrumentMethodAndCallOriginal","before","after","instrumentSetter","originalDescriptor","getOwnPropertyDescriptor","thisObject","fetchObservable","xhrContexts","initXhrObservable","stopInstrumentingStart","XMLHttpRequest","openXhr","stopInstrumentingSend","sendXhr","stopInstrumentingAbort","abortXhr","state","startContext","isAborted","xhr","hasBeenReported","stopInstrumentingOnReadyStateChange","DONE","onEnd","completeContext","initFetchObservable","fetch","originalFetch","input","init","responsePromise","afterSend","reportFetch","response","DOMException","code","ABORT_ERR","responseType","then","clearTracingIfNeeded","spanId","traceSampled","injectHeadersIfTracingAllowed","inject","getCrypto","requestUrl","allowedTracingOrigins","isAllowedUrl","TraceIdentifier","tracingSampleRate","toDecimalString","crypto","msCrypto","Uint8Array","getRandomValues","radix","high","readInt32","low","mod","floor","offset","nextRequestIndex","startRequestCollection","tracer","traceFetch","tracingHeaders","Request","headers","append","Headers","header","traceXhr","setRequestHeader","startTracer","rawContext","requestIndex","getNextRequestIndex","trackXhr","trackFetch","trackEventCounts","eventCounts","errorCount","longTaskCount","resourceCount","actionCount","frustrationCount","frustration","waitPageActivityEnd","domMutationObservable","pageActivityEndCallback","maxDuration","pageActivityObservable","firstRequestIndex","pendingRequestsCount","notifyPageActivity","isExcludedUrl","startEvent","request","stopTrackingWindowOpen","s","isBusy","createPageActivityObservable","pageActivityEndTimeoutId","hasCompleted","validationTimeoutId","complete","hadActivity","maxDurationTimeoutId","pageActivitySubscription","lastChangeTime","doWaitPageActivityEnd","excludedActivityUrls","MAX_DURATION_BETWEEN_CLICKS","createClickChain","firstClick","onFinalize","maxDurationBetweenClicksTimeout","bufferedClicks","appendClick","click","stopObservable","tryFinalize","dontAcceptMoreClick","every","isStopped","tryAppend","first","second","sqrt","pow","clientX","clientY","DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE","getActionNameFromElement","userProgrammaticAttribute","getActionNameFromElementProgrammatically","getActionNameFromElementForStrategies","priorityStrategies","fallbackStrategies","targetElement","programmaticAttribute","elementWithAttribute","supportsElementClosestResult","HTMLElement","supportsElementClosest","closest","hasAttribute","parentElement","truncate","normalizeWhitespace","getAttribute","trim","supportsLabelPropertyResult","HTMLInputElement","supportsLabelProperty","labels","getTextualContent","label","ownerDocument","querySelectorAll","htmlFor","labelledByAttribute","refElement","getElementById","strategies","recursionCounter","strategy","trimmedName","isContentEditable","innerText","removeTextFromElements","query","textToReplace","documentMode","textContent","stableAttributeSelectorsCache","supportScopeSelectorCache","STABLE_ATTRIBUTES","getSelectorsFromElement","actionNameAttribute","attributeSelectors","attribute","getAttributeSelector","getStableAttributeSelectors","globallyUniqueSelectorStrategies","getIDSelector","uniqueAmongChildrenSelectorStrategies","getClassSelector","getTagNameSelector","selector","getSelectorFromElement","selector_combined","useCombinedSelectors","selector_stopping_when_unique","selector_all_together","isGeneratedValue","targetElementSelector","globallyUniqueSelector","findSelector","isSelectorUniqueGlobally","combineSelector","isSelectorUniqueAmongSiblings","getPositionSelector","tagName","classList","className","attributeName","elementIndex","sibling","firstElementChild","currentIndex","nextElementSibling","selectorGetters","childSelector","elementSelector","selectorGetter","fullSelector","supportScopeSelector","parent","child","isSelectionEmpty","selection","getSelection","isCollapsed","isMouseEventOnElement","Element","computeFrustration","clicks","rageClick","getUserActivity","isRage","addFrustration","isDead","hasError","hasSelectionChanged","hasPageActivity","msMatchesSelector","trackClickActions","currentClickChain","history","ContextHistory","stopClickChain","stopActionEventsListener","selectionEmptyAtPointerDown","clickContext","onPointerDown","onClick","hasInputChanged","listeners","clickEvent","listenActionEvents","pointerDownEvent","trackFrustrations","clickActionBase","position","rect","getBoundingClientRect","x","left","y","top","computeClickActionBase","processPointerDown","appendClickToClickChain","newClick","stopWaitPageActivityEnd","pageActivityEndEvent","discard","validate","viewEndedSubscription","endClocks","stopSubscription","processClick","finalizeClicks","activityEndTime","historyEntry","eventCountsSubscription","frustrationTypes","newActivityEndTime","frustrationType","domEvents","clickAction","counts","processAction","foregroundContexts","autoActionProperties","isAutoAction","loading_time","count","long_task","resource","actionEvent","inForeground","in_foreground","ERROR_TYPES_RE","startUnhandledErrorCollection","stopInstrumentingOnError","lineNo","columnNo","errorObj","msg","groups","instrumentOnError","stopInstrumentingOnUnhandledRejection","reason","instrumentUnhandledRejection","consoleObservablesByApi","initConsoleObservable","apis","consoleObservables","originalConsoleApi","params","buildConsoleLog","createConsoleObservable","param","formatConsoleParameters","firstErrorParam","trackFirstHiddenSingleton","RawReportType","initReportObservable","handleCspViolation","blockedURI","effectiveDirective","subtype","buildStack","originalPolicy","sourceFile","lineNumber","columnNumber","buildRawReportFromCspViolation","reportTypes","ReportingObserver","handleReports","reports","report","buildRawReportFromReport","types","disconnect","createReportObservable","startErrorCollection","errorObservable","consoleError","trackConsoleError","trackRuntimeError","trackReportError","handling_stack","source_type","processError","addError","rawError","doStartErrorCollection","matchRequestTiming","sameNameEntries","getEntriesByName","correspondingEntries","candidates","errorMargin","startResourceCollection","matchingTiming","correspondingTimingOverrides","computePerformanceEntryMetrics","tracingInfo","span_id","trace_id","rule_psr","getRulePsr","computeRequestTracingInfo","indexingInfo","computeIndexingInfo","resourceEvent","status_code","performanceEntry","requestInput","requestInit","processRequest","processResourceEntry","entryMetrics","computeEntryTracingInfo","size","resourceStart","discarded","resourceAllowed","trackFirstHidden","visibilityState","TIMING_MAXIMUM_DELAY","trackInitialViewTimings","timings","setTimings","newTimings","stopNavigationTracking","domComplete","domContentLoaded","domContentLoadedEventEnd","domInteractive","loadEvent","firstByte","trackNavigationTimings","stopFCPTracking","firstHidden","fcpEntry","trackFirstContentfulPaintTiming","firstContentfulPaint","stopLCPTracking","firstInteractionTimestamp","stopEventListener","unsubscribeLifeCycle","lcpEntry","findLast","trackLargestContentfulPaintTiming","largestContentfulPaint","stopFIDTracking","firstInputEntry","firstInputDelay","firstInputTime","trackFirstInputTimings","trackViewMetrics","scheduleViewUpdate","loadingType","viewStart","stopCLSTracking","viewMetrics","stopEventCountsTracking","newEventCounts","loadType","isWaitingForLoadEvent","isWaitingForActivityLoadingTime","loadingTimeCandidates","invokeCallbackIfAllCandidatesAreReceived","setLoadEvent","trackLoadingTime","newLoadingTime","loadingTime","stopLoadingTimeTracking","cumulativeLayoutShift","maxClsValue","update","slidingSessionWindow","hadRecentInput","trackCumulativeLayoutShift","trackViews","locationChangeObservable","areViewsTrackedAutomatically","initialViewOptions","locationChangeSubscription","initialView","newView","updateTimings","scheduleUpdate","trackInitialView","stopInitialViewTracking","currentView","stopViewLifeCycle","trackViewChange","triggerUpdate","keepAliveInterval","startViewLifeCycle","viewOptions","currentLocation","otherLocation","hash","correspondingId","oldLocation","newLocation","substr","getPathFromHash","renewViewOnLocationChange","addTiming","time","startView","initialLocation","customTimings","documentVersion","triggerViewUpdate","cancelScheduleViewUpdate","stopViewMetricsTracking","currentEnd","isActive","clocks","looksLikeRelativeTime","sanitized","sanitizeTiming","startViewCollection","recorderApi","replayStats","getReplayStats","viewEvent","document_version","replay_stats","cumulative_layout_shift","dom_complete","dom_content_loaded","dom_interactive","first_contentful_paint","first_input_delay","first_input_time","is_active","largest_contentful_paint","load_event","discardNegativeDuration","loading_type","time_spent","in_foreground_periods","custom_timings","newObject","mapValues","processViewUpdate","trackViewsManually","ongoingOperations","SESSION_ENTRY_REGEXP","SESSION_ENTRY_SEPARATOR","SESSION_COOKIE_NAME","bufferedOperations","withCookieLockAccess","operations","numberOfRetries","next","currentLock","currentSession","retrieveSession","isCookieLockEnabled","lock","retryLater","setSession","processedSession","process","persistSession","isExpiredState","chrome","navigator","userAgent","currentNumberOfRetries","nextOperations","shift","clearSession","expire","toSessionString","sessionString","isValidSessionString","startSessionStore","productKey","computeSessionState","renewObservable","expireObservable","watchSessionTimeoutId","cookieSession","isActiveSession","synchronizeSession","sessionCache","retrieveActiveSession","hasSessionInCache","isSessionInCacheOutdated","created","expandOrRenewSession","isTracked","synchronizedSession","trackingType","expandOrRenewCookie","renewSession","expandSession","getSession","stopCallbacks","startSessionManager","oldSessionId","oldRumType","oldLogsType","tryOldCookiesMigration","sessionStore","sessionContextHistory","buildSessionContext","expandSessionWhenVisible","visibilityCheckInterval","trackVisibility","findActiveSession","startRumSessionManager","rawTrackingType","hasValidRumSession","sessionReplaySampleRate","isTypeTracked","sessionReplayAllowed","longTaskAllowed","trackLongTasks","oldPlansBehavior","trackResources","rumSessionType","HAS_MULTI_BYTES_CHARACTERS","beforeUnloadCallback","pushOnlyBuffer","upsertBuffer","bufferBytesCount","bufferMessagesCount","setupFlushOnExit","flushPeriodically","addOrUpdate","upsert","flush","sendFn","messages","bytesCount","flushOnExit","sendOnExit","computeBytesCount","TextEncoder","encode","Blob","processedMessage","messageBytesCount","hasMessageFor","willReachedBytesLimitWith","isFull","removedMessage","sendBeacon","MAX_QUEUE_BYTES_COUNT","sendWithRetryStrategy","payload","sendStrategy","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","dequeue","currentBackoffTime","min","shouldRetryRequest","ongoingRequestCount","queueFullReported","previousQueue","newPayloadQueue","queue","createHttpRequest","endpointBuilder","bytesLimit","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","isKeepAliveSupported","keepalive","sendXHR","fetchKeepAliveStrategy","hasReportedBeaconError","reportBeaconError","sendBeaconStrategy","onLoadEnd","open","startRumBatch","telemetryEventObservable","batch","replicaBatch","primaryBatch","createRumBatch","unloadCallback","Batch","withReplicaApplicationId","replicated","makeRumBatch","isTelemetryReplicationAllowed","createLocationChangeObservable","onHistoryChange","stopInstrumentingPushState","stopInstrumentingReplaceState","removeListener","onHashChange","stopHistoryTracking","onLocationChange","stopHashTracking","RecordType","NodeType","IncrementalSource","MouseInteractionType","MediaInteractionType","NodePrivacyLevel","IGNORE","HIDDEN","PRIVACY_ATTR_NAME","PRIVACY_ATTR_VALUE_HIDDEN","CENSORED_STRING_MARK","FORM_PRIVATE_TAG_NAMES","INPUT","OUTPUT","TEXTAREA","SELECT","OPTION","DATALIST","OPTGROUP","getNodePrivacyLevel","defaultPrivacyLevel","parentNodePrivacyLevel","parentNode","reducePrivacyLevel","getNodeSelfPrivacyLevel","childPrivacyLevel","nodeType","ELEMENT_NODE","isElement","privAttr","inputElement","autocomplete","contains","relAttribute","getLowerCaseAttribute","nameAttribute","propertyAttribute","toLowerCase","shouldIgnoreElement","shouldMaskNode","privacyLevel","TEXT_NODE","isFormElement","getTextContent","textNode","ignoreWhiteSpace","parentTagName","isStyle","serializedNodeIds","hasSerializedNode","getSerializedNodeId","getElementInputValue","nodePrivacyLevel","URL_IN_CSS_REF","ABSOLUTE_URL","DATA_URI","switchToAbsoluteUrl","cssText","cssHref","matchingSubstring","singleQuote","urlWrappedInSingleQuotes","doubleQuote","urlWrappedInDoubleQuotes","urlNotWrappedInQuotes","quote","makeUrlAbsolute","isTouchEvent","changedTouches","assembleIncrementalSnapshot","getPathToNestedCSSRule","rule","currentRule","parentRule","cssRules","parentStyleSheet","serializeDocument","serializationContext","serializeNodeWithId","serializedNode","DOCUMENT_NODE","serializeChildNodes","serializeDocumentNode","DOCUMENT_TYPE_NODE","documentType","publicId","systemId","getValidTagName","isSVG","el","SVGElement","attributes","rr_width","rr_height","safeAttrs","attributeValue","serializeAttribute","formValue","optionElement","selected","stylesheet","styleSheets","getCssRulesString","rel","_cssText","sheet","scrollTop","scrollLeft","checked","mediaElement","rr_mediaState","paused","elementsScrollPositions","rr_scrollLeft","rr_scrollTop","getAttributesForPrivacyLevel","serializeElementNode","serializeTextNode","CDATA_SECTION_NODE","serializeNode","_nextId","serializedNodeWithId","serializeNodeId","setSerializedNodeId","childNode","serializedChildNode","TAG_NAME_REGEX","processedTagName","rules","getCssRuleString","isCSSImportRule","styleSheet","createMutationBatch","processMutationBatch","cancelScheduledFlush","pendingMutations","addMutations","mutations","opts","requestIdleCallback","cancelIdleCallback","requestAnimationFrame","cancelAnimationFrame","timeout","startMutationObserver","controller","mutationCallback","mutationBatch","filteredMutations","mutation","nodeAndAncestorsHaveSerializedNode","addedAndMovedNodes","removedNodes","Map","addedNodes","delete","sortedAddedAndMovedNodes","nodes","sort","compareDocumentPosition","Node","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","addedNodeMutations","hasBeenSerialized","nextId","getNextSibling","parentId","removedNodeMutations","adds","removes","nextSibling","processChildListMutations","texts","textMutations","handledNodes","oldValue","processCharacterDataMutations","attributeMutations","handledElements","handledAttributes","emittedMutations","transformedValue","inputValue","emittedMutation","processAttributesMutations","processMutations","takeRecords","attributeOldValue","characterData","characterDataOldValue","childList","subtree","onFlush","flushListener","convertMouseEventToLayoutCoordinates","normalised","layoutViewportX","layoutViewportY","visualViewportX","visualViewportY","abs","pageTop","offsetTop","scrollY","pageLeft","offsetLeft","scrollX","isVisualViewportFactoredIn","getVisualViewport","getScrollX","pageXOffset","getScrollY","pageYOffset","recordIds","getRecordIdForEvent","initObservers","o","mutationController","cb","mediaInteractionCb","focusCb","frustrationCb","mutationHandler","mutationCb","mousemoveHandler","updatePosition","timeOffset","initMoveObserver","mousemoveCb","mouseInteractionHandler","handler","eventTypeToMouseInteraction","record","initMouseInteractionObserver","mouseInteractionCb","scrollHandler","scrollPositions","initScrollObserver","scrollCb","viewportResizeHandler","initViewportResizeObserver","viewportResizeCb","inputHandler","lastInputStateMap","onElementChange","inputState","isChecked","text","cbWithDedup","lastInputState","stopEventListeners","HTMLTextAreaElement","HTMLSelectElement","instrumentationStoppers","stopper","initInputObserver","inputCb","mediaInteractionHandler","styleSheetObserver","checkStyleSheetAndCallback","ownerNode","CSSStyleSheet","CSSGroupingRule","instrumentGroupingCSSRuleClass","CSSMediaRule","CSSSupportsRule","cls","initStyleSheetObserver","styleSheetCb","focusHandler","has_focus","visualViewportResizeHandler","cancelThrottle","initVisualViewportResizeObserver","visualViewportResizeCb","frustrationHandler","emit","scrollPositionsByElement","MutationController","scrollingElement","takeFullSnapshot","initialOffset","v","p","mouseInteractionRecord","positions","m","r","d","frustrationRecord","takeSubsequentFullSnapshot","flushMutations","statsPerView","getSegmentsCount","viewId","getOrCreateReplayStats","segments_count","addRecord","records_count","segments_total_raw_size","_value","deleteOldestStats","workerURL","worker","creationReason","initialRecord","onWrote","onFlushed","isFlushed","metadata","creation_reason","has_full_snapshot","index_in_view","additionalBytesCount","rawBytesCount","compressedBytesCount","postMessage","SEGMENT_BYTES_LIMIT","startSegmentCollection","getSegmentContext","nextSegmentCreationReason","unsubscribeViewCreated","flushSegment","unsubscribeBeforeUnload","unsubscribeVisibilityChange","segment","expirationTimeoutId","createNewSegment","Segment","compressedSegmentBytesCount","rawSegmentBytesCount","doStartSegmentCollection","computeSegmentContext","createDeflateWorker","createObjectURL","workerCodeFn","Worker","Z_FIXED","Z_BINARY","Z_TEXT","Z_UNKNOWN","zero","buf","len","STORED_BLOCK","STATIC_TREES","DYN_TREES","MIN_MATCH","MAX_MATCH","LENGTH_CODES","LITERALS","L_CODES","D_CODES","BL_CODES","HEAP_SIZE","MAX_BITS","Buf_size","MAX_BL_BITS","END_BLOCK","REP_3_6","REPZ_3_10","REPZ_11_138","extra_lbits","extra_dbits","extra_blbits","bl_order","DIST_CODE_LEN","static_ltree","static_dtree","_dist_code","_length_code","base_length","static_l_desc","static_d_desc","static_bl_desc","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","w","pending_buf","pending","send_bits","bi_valid","bi_buf","send_code","c","tree","bi_reverse","res","bi_flush","gen_bitlen","desc","h","n","bits","xbits","stree","extra","overflow","bl_count","heap","heap_max","opt_len","static_len","gen_codes","next_code","tr_static_init","init_block","dyn_ltree","dyn_dtree","bl_tree","last_lit","bi_windup","copy_block","subarray","smaller","depth","_n2","_m2","pqdownheap","k","j","heap_len","compress_block","ltree","dtree","lc","lx","d_buf","l_buf","build_tree","scan_tree","curlen","prevlen","nextlen","max_count","min_count","send_tree","build_bl_tree","max_blindex","l_desc","d_desc","bl_desc","send_all_trees","lcodes","dcodes","blcodes","rank","detect_data_type","black_mask","static_init_done","_tr_stored_block","stored_len","last","_tr_flush_block","opt_lenb","static_lenb","level","strm","data_type","trees","_tr_init","_tr_tally","lit_bufsize","_tr_align","adler32_1","adler","pos","s1","s2","crcTable","Uint32Array","table","makeTable","crc32_1","crc","t","constants","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_DEFAULT_STRATEGY","Z_DEFLATED","_tr_init$1","_tr_stored_block$1","_tr_flush_block$1","_tr_tally$1","_tr_align$1","Z_FIXED$1","Z_UNKNOWN$1","MAX_MEM_LEVEL","MAX_WBITS","DEF_MEM_LEVEL","L_CODES$1","LITERALS$1","D_CODES$1","BL_CODES$1","HEAP_SIZE$1","MAX_BITS$1","MIN_MATCH$1","MAX_MATCH$1","MIN_LOOKAHEAD","PRESET_DICT","INIT_STATE","EXTRA_STATE","NAME_STATE","COMMENT_STATE","HCRC_STATE","BUSY_STATE","FINISH_STATE","BS_NEED_MORE","BS_BLOCK_DONE","BS_FINISH_STARTED","BS_FINISH_DONE","OS_CODE","errorCode","zero$1","HASH","prev","hash_shift","hash_mask","flush_pending","avail_out","output","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","putShortMSB","read_buf","avail_in","next_in","wrap","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","w_size","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","more","_w_size","window_size","hash_size","insert","ins_h","deflate_fast","hash_head","bflush","match_length","max_lazy_match","deflate_slow","max_insert","prev_match","match_available","deflate_rle","deflate_huff","Config","good_length","max_lazy","nice_length","max_chain","configuration_table","max_block_size","pending_buf_size","max_start","lm_init","DeflateState","gzhead","gzindex","last_flush","w_bits","hash_bits","Uint16Array","deflateResetKeep","deflateReset","ret","deflateInit2","windowBits","memLevel","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","deflate_1","deflateInit","deflateSetHeader","deflate","beg","val","old_flush","hcrc","os","bstate","deflateEnd","deflateInfo","flattenChunks","chunks","l","_i","_l","chunk","_utf8len","q","ZStream","zstream","Z_NO_FLUSH$1","Z_FULL_FLUSH$1","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$1","Deflate","chunkSize","opt","raw","gzip","ended","dict","_dict_set","string2buf","c2","m_pos","str_len","buf_len","flush_mode","_flush_mode","onData","makePakoDeflate","pushData","binaryData","reduce","total","startDeflateWorker","createDeflateWorkerImpl","onError","doStartDeflateWorker","Event","httpRequest","formData","FormData","toFormEntries","byteLength","onEntry","prefix","existingGlobalVariable","startRecordingImpl","startDeflateWorkerImpl","onRumStart","isRecording","startStrategy","stopStrategy","stopRecording","makeRecorderApi","replayRequest","stopSegmentCollection","unsubscribeViewEnded","datadogRum","startRumImpl","ignoreInitIfSyntheticsWillInjectRum","isAlreadyInitialized","globalContextManager","userContextManager","getInternalContextStrategy","getInitConfigurationStrategy","bufferApiCalls","BoundedBuffer","addTimingStrategy","startViewStrategy","addActionStrategy","addErrorStrategy","providedError","doStartRum","startRumResults","stub","publicApi","rumPublicApi","overrideInitConfigurationForBridge","testCookieValue","isCookieCorrectlySet","areCookiesAuthorized","canHandleSession","canInitRum","premiumSampleRate","replaySampleRate","baseConfiguration","trackInteractions","validateAndBuildRumConfiguration","beforeInitCalls","addRumGlobalContext","setGlobalContextProperty","removeRumGlobalContext","removeGlobalContextProperty","getRumGlobalContext","getGlobalContext","setRumGlobalContext","setGlobalContext","clearGlobalContext","getInternalContext","getInitConfiguration","addAction","setUser","newUser","sanitizeUser","getUser","setUserProperty","sanitizedProperty","removeUserProperty","removeUser","clearUser","startSessionReplayRecording","stopSessionReplayRecording","onReady","enumerable","shallowClonedUser","email","makeRumPublicApi","LifeCycle","startRumTelemetry","startRumEventBridge","startRumSessionManagerStub","viewContextHistory","buildViewContext","startViewContexts","previousViewUrl","urlContextHistory","viewUrl","buildUrlContext","changeTime","startUrlContexts","startActionCollection","startRumEventCollection","addTelemetryConfiguration","baseSerializedConfiguration","session_sample_rate","telemetry_sample_rate","telemetry_configuration_sample_rate","use_before_send","use_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","serializeConfiguration","premium_sample_rate","replay_sample_rate","session_replay_sample_rate","trace_sample_rate","action_name_attribute","use_allowed_tracing_origins","default_privacy_level","use_excluded_activity_urls","track_frustrations","track_views_manually","track_interactions","serializeRumConfiguration","startLongTaskCollection","internalContext","application_id","session_id","user_action","startInternalContext"],"mappings":"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","file":"datadog-rum.js","sourcesContent":["/* eslint-disable no-console, local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = typeof ConsoleApiName[keyof typeof ConsoleApiName]\n\ninterface Display {\n  (api: ConsoleApiName, ...args: any[]): void\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\nexport const display: Display = (api, ...args) => {\n  if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {\n    api = ConsoleApiName.log\n  }\n  display[api](...args)\n}\n\ndisplay.debug = console.debug.bind(console)\ndisplay.log = console.log.bind(console)\ndisplay.info = console.info.bind(console)\ndisplay.warn = console.warn.bind(console)\ndisplay.error = console.error.bind(console)\n","import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n","import { ConsoleApiName, display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    displayIfDebugEnabled(ConsoleApiName.error, e)\n    if (onMonitorErrorCollected) {\n      try {\n        onMonitorErrorCollected(e)\n      } catch (e) {\n        displayIfDebugEnabled(ConsoleApiName.error, e)\n      }\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(api: ConsoleApiName, ...args: any[]) {\n  if (debugMode) {\n    display(api, '[MONITOR]', ...args)\n  }\n}\n","import { display } from './display'\nimport { monitor } from './monitor'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\nexport const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\nexport const enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n}\n\nexport const enum ResourceType {\n  DOCUMENT = 'document',\n  XHR = 'xhr',\n  BEACON = 'beacon',\n  FETCH = 'fetch',\n  CSS = 'css',\n  JS = 'js',\n  IMAGE = 'image',\n  FONT = 'font',\n  MEDIA = 'media',\n  OTHER = 'other',\n}\n\nexport const enum RequestType {\n  FETCH = ResourceType.FETCH,\n  XHR = ResourceType.XHR,\n}\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\ninterface Assignable {\n  [key: string]: any\n}\n\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W\nexport function assign(target: Assignable, ...toAssign: Assignable[]) {\n  toAssign.forEach((source: Assignable) => {\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  })\n  return target\n}\n\nexport function shallowClone<T>(object: T): T & Record<string, never> {\n  return assign({}, object)\n}\n\n/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\n/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(value: unknown, space?: string | number): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matters here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, getCyclicReplacer(), space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\ninterface ObjectWithToJsonMethod {\n  toJSON: unknown\n}\nfunction detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n\nexport function includes(candidate: string, search: string): boolean\nexport function includes<T>(candidate: T[], search: T): boolean\nexport function includes(candidate: string | unknown[], search: any) {\n  return candidate.indexOf(search) !== -1\n}\n\nexport function arrayFrom<T>(arrayLike: ArrayLike<T> | Set<T>): T[] {\n  if (Array.from) {\n    return Array.from(arrayLike)\n  }\n\n  const array = []\n\n  if (arrayLike instanceof Set) {\n    arrayLike.forEach((item) => array.push(item))\n  } else {\n    for (let i = 0; i < arrayLike.length; i++) {\n      array.push(arrayLike[i])\n    }\n  }\n\n  return array\n}\n\nexport function find<T, S extends T>(\n  array: ArrayLike<T>,\n  predicate: (item: T, index: number) => item is S\n): S | undefined\nexport function find<T>(array: ArrayLike<T>, predicate: (item: T, index: number) => boolean): T | undefined\nexport function find(\n  array: ArrayLike<unknown>,\n  predicate: (item: unknown, index: number) => boolean\n): unknown | undefined {\n  for (let i = 0; i < array.length; i += 1) {\n    const item = array[i]\n    if (predicate(item, i)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.keys(object).map((key) => object[key])\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function objectEntries(object: { [key: string]: unknown }): Array<[string, unknown]> {\n  return Object.keys(object).map((key) => [key, object[key]])\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n\nexport function startsWith(candidate: string, search: string) {\n  return candidate.slice(0, search.length) === search\n}\n\nexport function endsWith(candidate: string, search: string) {\n  return candidate.slice(-search.length) === search\n}\n\n/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\nexport function getGlobalObject<T>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n\nexport function getLocationOrigin() {\n  return getLinkElementOrigin(window.location)\n}\n\n/**\n * IE fallback\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin\n */\nexport function getLinkElementOrigin(element: Location | HTMLAnchorElement | URL) {\n  if (element.origin) {\n    return element.origin\n  }\n  const sanitizedHost = element.host.replace(/(:80|:443)$/, '')\n  return `${element.protocol}//${sanitizedHost}`\n}\n\nexport function findCommaSeparatedValue(rawString: string, name: string) {\n  const regex = new RegExp(`(?:^|;)\\\\s*${name}\\\\s*=\\\\s*([^;]+)`)\n  const matches = regex.exec(rawString)\n  return matches ? matches[1] : undefined\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) return candidate\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n\nexport interface EventEmitter {\n  addEventListener(\n    event: DOM_EVENT,\n    listener: (event: Event) => void,\n    options?: boolean | { capture?: boolean; passive?: boolean }\n  ): void\n  removeEventListener(\n    event: DOM_EVENT,\n    listener: (event: Event) => void,\n    options?: boolean | { capture?: boolean; passive?: boolean }\n  ): void\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\n/**\n * Add an event listener to an event emitter object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<E extends Event>(\n  emitter: EventEmitter,\n  event: DOM_EVENT,\n  listener: (event: E) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(emitter, [event], listener, options)\n}\n\n/**\n * Add event listeners to an event emitter object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<E extends Event>(\n  emitter: EventEmitter,\n  events: DOM_EVENT[],\n  listener: (event: E) => void,\n  { once, capture, passive }: { once?: boolean; capture?: boolean; passive?: boolean } = {}\n) {\n  const wrappedListener = monitor(\n    once\n      ? (event: Event) => {\n          stop()\n          listener(event as E)\n        }\n      : (listener as (event: Event) => void)\n  )\n\n  const options = passive ? { capture, passive } : capture\n  events.forEach((event) => emitter.addEventListener(event, wrappedListener, options))\n  const stop = () => events.forEach((event) => emitter.removeEventListener(event, wrappedListener, options))\n\n  return {\n    stop,\n  }\n}\n\nexport function elementMatches(element: Element & { msMatchesSelector?(selector: string): boolean }, selector: string) {\n  if (element.matches) {\n    return element.matches(selector)\n  }\n  // IE11 support\n  if (element.msMatchesSelector) {\n    return element.msMatchesSelector(selector)\n  }\n  return false\n}\n\nexport function runOnReadyState(expectedReadyState: 'complete' | 'interactive', callback: () => void) {\n  if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n    callback()\n  } else {\n    const eventName = expectedReadyState === 'complete' ? DOM_EVENT.LOAD : DOM_EVENT.DOM_CONTENT_LOADED\n    addEventListener(window, eventName, callback, { once: true })\n  }\n}\n\n/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n    TDestination extends undefined\n    ? TSource\n    : // case 3 - source is an array - see if it merges or overwrites\n    TSource extends any[]\n    ? TDestination extends any[]\n      ? TDestination & TSource\n      : TSource\n    : // case 4 - source is an object - see if it merges or overwrites\n    TSource extends object\n    ? TDestination extends object\n      ? TDestination extends any[]\n        ? TSource\n        : TDestination & TSource\n      : TSource\n    : // case 5 - cannot merge - return source\n      TSource\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  // Using a weakmap instead of a weakset to support IE11\n  const map: WeakMap<any, boolean> = new WeakMap()\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = map.has(value)\n      if (!has) {\n        map.set(value, true)\n      }\n      return has\n    },\n  }\n}\n\n/**\n * Returns a replacer function that can be used with JSON.stringify\n * to remove cyclic references.\n */\nfunction getCyclicReplacer(): (key: string, value: unknown) => unknown {\n  const circularReferenceChecker = createCircularReferenceChecker()\n  return (_key: string, value: unknown) => {\n    const type = getType(value)\n    if ((type === 'object' || type === 'array') && circularReferenceChecker.hasAlreadyBeenSeen(value)) {\n      return '<warning: cyclic reference not serialized>'\n    }\n    return value\n  }\n}\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged: Record<any, any> = getType(destination) === 'object' ? destination : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are dereferenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\nexport type TimeoutId = ReturnType<typeof setTimeout>\n\nexport function requestIdleCallback(callback: () => void, opts?: { timeout?: number }) {\n  // Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n  // browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n  // fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n  // browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes\n  // efficiently.\n  if (window.requestIdleCallback) {\n    const id = window.requestIdleCallback(monitor(callback), opts)\n    return () => window.cancelIdleCallback(id)\n  }\n  const id = window.requestAnimationFrame(monitor(callback))\n  return () => window.cancelAnimationFrame(id)\n}\n\nexport function removeDuplicates<T>(array: T[]) {\n  const set = new Set<T>()\n  array.forEach((item) => set.add(item))\n  return arrayFrom(set)\n}\n\nexport type MatchOption = string | RegExp | ((value: string) => boolean)\nexport function matchList(list: MatchOption[], value: string): boolean {\n  return list.some((item) => {\n    if (typeof item === 'function') {\n      try {\n        return item(value)\n      } catch (e) {\n        display.error(e)\n        return false\n      }\n    }\n    if (item instanceof RegExp) {\n      return item.test(value)\n    }\n    return item === value\n  })\n}\n\n// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js\nexport function cssEscape(str: string) {\n  if (window.CSS && window.CSS.escape) {\n    return window.CSS.escape(str)\n  }\n\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g, function (ch, asCodePoint) {\n    if (asCodePoint) {\n      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n      if (ch === '\\0') {\n        return '\\uFFFD'\n      }\n      // Control characters and (dependent upon position) numbers get escaped as code points\n      return `${ch.slice(0, -1)}\\\\${ch.charCodeAt(ch.length - 1).toString(16)} `\n    }\n    // Other potentially-special ASCII characters get backslash-escaped\n    return `\\\\${ch}`\n  })\n}\n","import { deepClone } from './utils'\n\nimport type { Context, ContextValue } from './context'\n\nexport function createContextManager() {\n  let context: Context = {}\n\n  return {\n    /** @deprecated use getContext instead */\n    get: () => context,\n\n    /** @deprecated use setContextProperty instead */\n    add: (key: string, value: any) => {\n      context[key] = value as ContextValue\n    },\n\n    /** @deprecated renamed to removeContextProperty */\n    remove: (key: string) => {\n      delete context[key]\n    },\n\n    /** @deprecated use setContext instead */\n    set: (newContext: object) => {\n      context = newContext as Context\n    },\n\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: Context) => {\n      context = deepClone(newContext)\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context[key] = deepClone(property)\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n    },\n\n    clearContext: () => {\n      context = {}\n    },\n  }\n}\n","const BUFFER_LIMIT = 500\n\nexport class BoundedBuffer {\n  private buffer: Array<() => void> = []\n\n  add(callback: () => void) {\n    const length = this.buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      this.buffer.splice(0, 1)\n    }\n  }\n\n  drain() {\n    this.buffer.forEach((callback) => callback())\n    this.buffer.length = 0\n  }\n}\n","import { isNumber, ONE_YEAR, round } from './utils'\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n\nexport function resetNavigationStart() {\n  navigationStart = undefined\n}\n","import { display } from '../tools/display'\nimport { findCommaSeparatedValue, generateUUID, ONE_SECOND } from '../tools/utils'\n\nexport const COOKIE_ACCESS_DELAY = ONE_SECOND\n\nexport type SetCookieOverride = (name: string, value: string, expireDelay: number) => void\nexport type GetCookieOverride = (name: string) => string | undefined\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  domain?: string,\n  setCookie?: SetCookieOverride\n  getCookie?: GetCookieOverride\n}\n\n\nlet getCookieOverride: GetCookieOverride, setCookieOverride: SetCookieOverride\nexport function setCookieHandling(getCookie: GetCookieOverride, setCookie: SetCookieOverride): void {\n  getCookieOverride = getCookie\n  setCookieOverride = setCookie\n}\n\nexport function setCookie(name: string, value: string, expireDelay: number, options?: CookieOptions) {\n  if (setCookieOverride) {\n    setCookieOverride(name, value, expireDelay);\n    return\n  }\n  const date = new Date()\n  date.setTime(date.getTime() + expireDelay)\n  const expires = `expires=${date.toUTCString()}`\n  const sameSite = options && options.crossSite ? 'none' : 'strict'\n  const domain = options && options.domain ? `;domain=${options.domain}` : ''\n  const secure = options && options.secure ? ';secure' : ''\n  document.cookie = `${name}=${value};${expires};path=/;samesite=${sameSite}${domain}${secure}`\n}\n\nexport function getCookie(name: string): string | undefined {\n  if (getCookieOverride) {\n    return getCookieOverride(name)\n  }\n  return findCommaSeparatedValue(document.cookie, name)\n}\n\nexport function deleteCookie(name: string, options?: CookieOptions) {\n  setCookie(name, '', 0, options)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (!!getCookieOverride && !!setCookieHandling) {\n    return true\n  }\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_SECOND, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n","import { getCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n","import { endsWith, getGlobalObject } from '../tools/utils'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E) {\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event }))\n    },\n  }\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || endsWith(currentHost, `.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n","import { startsWith } from '../../tools/utils'\nimport type { StackTrace, StackFrame } from './types'\n\nconst UNKNOWN_FUNCTION = '?'\n\n/**\n * Computes a stack trace for an exception.\n */\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && startsWith(stackProperty, exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n","import type { StackTrace } from '../domain/tracekit'\nimport { computeStackTrace } from '../domain/tracekit'\nimport { callMonitored } from './monitor'\nimport type { ClocksState } from './timeUtils'\nimport { jsonStringify, noop } from './utils'\n\nexport interface ErrorWithCause extends Error {\n  cause?: Error\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: string\n  type?: string\n  stack?: string\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  causes?: RawErrorCause[]\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = typeof ErrorSource[keyof typeof ErrorSource]\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n\n  handlingStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: string\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  startClocks,\n  nonErrorPrefix,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  if (!stackTrace || (stackTrace.message === undefined && !(originalError instanceof Error))) {\n    return {\n      startClocks,\n      source,\n      handling,\n      originalError,\n      message: `${nonErrorPrefix} ${jsonStringify(originalError)!}`,\n      stack: 'No stack, consider using an instance of Error',\n      handlingStack,\n      type: stackTrace && stackTrace.name,\n    }\n  }\n\n  return {\n    startClocks,\n    source,\n    handling,\n    originalError,\n    message: stackTrace.message || 'Empty message',\n    stack: toStackTraceString(stackTrace),\n    handlingStack,\n    type: stackTrace.name,\n    causes: flattenErrorCauses(originalError as ErrorWithCause, source),\n  }\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n\n/**\n Creates a stacktrace without SDK internal frames.\n \n Constraints:\n - Has to be called at the utmost position of the call stack.\n - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error()\n  let formattedStack: string\n\n  // IE needs to throw the error to fill in the stack trace\n  if (!error.stack) {\n    try {\n      throw error\n    } catch (e) {\n      noop()\n    }\n  }\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (currentError?.cause instanceof Error && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n */\nimport { includes } from '../../tools/utils'\nimport { display } from '../../tools/display'\n\nlet enabledExperimentalFeatures: Set<string> | undefined\n\nexport function updateExperimentalFeatures(enabledFeatures: string[] | undefined): void {\n  // Safely handle external data\n  if (!Array.isArray(enabledFeatures)) {\n    return\n  }\n\n  if (!enabledExperimentalFeatures) {\n    enabledExperimentalFeatures = new Set(enabledFeatures)\n  }\n\n  enabledFeatures\n    .filter((flag) => typeof flag === 'string')\n    .forEach((flag: string) => {\n      if (includes(flag, '-')) {\n        display.warn(`please use snake case for '${flag}'`)\n      }\n      enabledExperimentalFeatures!.add(flag)\n    })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: string): boolean {\n  return !!enabledExperimentalFeatures && enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures = new Set()\n}\n\nexport function getExperimentalFeatures(): Set<string> {\n  return enabledExperimentalFeatures || new Set()\n}\n","import { getLinkElementOrigin, getLocationOrigin } from './utils'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, getLocationOrigin()).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function haveSameOrigin(url1: string, url2: string) {\n  return getOrigin(url1) === getOrigin(url2)\n}\n\nexport function getOrigin(url: string) {\n  return getLinkElementOrigin(buildUrl(url))\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function getSearch(url: string) {\n  return buildUrl(url).search\n}\n\nexport function getHash(url: string) {\n  return buildUrl(url).hash\n}\n\nexport function buildUrl(url: string, base?: string) {\n  if (checkURLSupported()) {\n    return base !== undefined ? new URL(url, base) : new URL(url)\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nlet isURLSupported: boolean | undefined\nfunction checkURLSupported() {\n  if (isURLSupported !== undefined) {\n    return isURLSupported\n  }\n  try {\n    const url = new URL('http://test/path')\n    isURLSupported = url.href === 'http://test/path'\n    return isURLSupported\n  } catch {\n    isURLSupported = false\n  }\n  return isURLSupported\n}\n","export const INTAKE_SITE_STAGING = 'datad0g.com'\nexport const INTAKE_SITE_US1 = 'datadoghq.com'\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com'\n","import { timeStampNow } from '../../tools/timeUtils'\nimport { normalizeUrl } from '../../tools/urlPolyfill'\nimport { generateUUID } from '../../tools/utils'\nimport type { InitConfiguration } from './configuration'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport const ENDPOINTS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'session-replay',\n} as const\n\nconst INTAKE_TRACKS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'replay',\n}\n\nexport type EndpointType = keyof typeof ENDPOINTS\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType,\n  tags: string[]\n) {\n  const { site = INTAKE_SITE_US1, clientToken } = initConfiguration\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  const host = `${ENDPOINTS[endpointType]}.browser-intake-${domainParts.join('-')}.${extension!}`\n  const baseUrl = `https://${host}/api/v2/${INTAKE_TRACKS[endpointType]}`\n  const proxyUrl = initConfiguration.proxyUrl && normalizeUrl(initConfiguration.proxyUrl)\n\n  return {\n    build() {\n      let parameters =\n        'ddsource=browser' +\n        `&ddtags=${encodeURIComponent([`sdk_version:${__BUILD_ENV__SDK_VERSION__}`].concat(tags).join(','))}` +\n        `&dd-api-key=${clientToken}` +\n        `&dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}` +\n        '&dd-evp-origin=browser' +\n        `&dd-request-id=${generateUUID()}`\n\n      if (endpointType === 'rum') {\n        parameters += `&batch_time=${timeStampNow()}`\n      }\n      const endpointUrl = `${baseUrl}?${parameters}`\n\n      return proxyUrl ? `${proxyUrl}?ddforward=${encodeURIComponent(endpointUrl)}` : endpointUrl\n    },\n    buildIntakeUrl() {\n      return proxyUrl ? `${proxyUrl}?ddforward` : baseUrl\n    },\n    endpointType,\n  }\n}\n","import { display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nconst FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {\n    display.warn(`${key} value doesn't meet tag requirements and will be sanitized`)\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n","import { assign, objectValues } from '../../tools/utils'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  isIntakeUrl: (url: string) => boolean\n  replica?: ReplicaConfiguration\n  site: string\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const intakeEndpoints = objectValues(endpointBuilders).map((builder) => builder.buildIntakeUrl())\n\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeEndpoints, tags)\n\n  return assign(\n    {\n      isIntakeUrl: (url: string) => intakeEndpoints.some((intakeEndpoint) => url.indexOf(intakeEndpoint) === 0),\n      replica: replicaConfiguration,\n      site: initConfiguration.site || INTAKE_SITE_US1,\n    },\n    endpointBuilders\n  )\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'sessionReplay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  intakeEndpoints: string[],\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = assign({}, initConfiguration, {\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  })\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  intakeEndpoints.push(...objectValues(replicaEndpointBuilders).map((builder) => builder.buildIntakeUrl()))\n\n  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders)\n}\n","import { CookieOptions, GetCookieOverride, setCookieHandling, SetCookieOverride } from '../../browser/cookie'\nimport { getCurrentSite } from '../../browser/cookie'\nimport { catchUserErrors } from '../../tools/catchUserErrors'\nimport { display } from '../../tools/display'\nimport { assign, isPercentage, ONE_KIBI_BYTE, ONE_SECOND } from '../../tools/utils'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport { updateExperimentalFeatures } from './experimentalFeatures'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = typeof DefaultPrivacyLevel[keyof typeof DefaultPrivacyLevel]\n\nexport interface InitConfiguration {\n  // global options\n  clientToken: string\n  beforeSend?: GenericBeforeSendCallback | undefined\n  sampleRate?: number | undefined\n  telemetrySampleRate?: number | undefined\n  silentMultipleInit?: boolean | undefined\n\n  // transport options\n  proxyUrl?: string | undefined\n  site?: string | undefined\n\n  // tag and context options\n  service?: string | undefined\n  env?: string | undefined\n  version?: string | undefined\n\n  // cookie options\n  useCrossSiteSessionCookie?: boolean | undefined\n  useSecureSessionCookie?: boolean | undefined\n  trackSessionAcrossSubdomains?: boolean | undefined\n  getCookie?: GetCookieOverride\n  setCookie?: SetCookieOverride\n\n  // internal options\n  enableExperimentalFeatures?: string[] | undefined\n  replica?: ReplicaUserConfiguration | undefined\n  datacenter?: string\n  telemetryConfigurationSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\ninterface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  cookieOptions: CookieOptions\n  sampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: number\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  if (initConfiguration.sampleRate !== undefined && !isPercentage(initConfiguration.sampleRate)) {\n    display.error('Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.telemetrySampleRate !== undefined && !isPercentage(initConfiguration.telemetrySampleRate)) {\n    display.error('Telemetry Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryConfigurationSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryConfigurationSampleRate)\n  ) {\n    display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (!!initConfiguration.setCookie !== !!initConfiguration.getCookie) {\n    display.error('Both setCookie and getCookie must be set or undefined.')\n    return\n  }\n\n  // Set the experimental feature flags as early as possible, so we can use them in most places\n  updateExperimentalFeatures(initConfiguration.enableExperimentalFeatures)\n\n  return assign(\n    {\n      beforeSend:\n        initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n      cookieOptions: buildCookieOptions(initConfiguration),\n      sampleRate: initConfiguration.sampleRate ?? 100,\n      telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n      telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n      service: initConfiguration.service,\n      silentMultipleInit: !!initConfiguration.silentMultipleInit,\n\n      /**\n       * beacon payload max queue size implementation is 64kb\n       * ensure that we leave room for logs, rum and potential other users\n       */\n      batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n      eventRateLimiterThreshold: 3000,\n      maxTelemetryEventsPerPage: 15,\n\n      /**\n       * flush automatically, aim to be lower than ALB connection timeout\n       * to maximize connection reuse.\n       */\n      flushTimeout: 30 * ONE_SECOND,\n\n      /**\n       * Logs intake limit\n       */\n      batchMessagesLimit: 50,\n      messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    },\n    computeTransportConfiguration(initConfiguration)\n  )\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  setCookieHandling(initConfiguration.getCookie!, initConfiguration.setCookie!);\n  \n  cookieOptions.secure = mustUseSecureCookie(initConfiguration)\n  cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n\nfunction mustUseSecureCookie(initConfiguration: InitConfiguration) {\n  return !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie\n}\n\nexport function serializeConfiguration(configuration: InitConfiguration): Partial<RawTelemetryConfiguration> {\n  return {\n    session_sample_rate: configuration.sampleRate,\n    telemetry_sample_rate: configuration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: configuration.telemetryConfigurationSampleRate,\n    use_before_send: !!configuration.beforeSend,\n    use_cross_site_session_cookie: configuration.useCrossSiteSessionCookie,\n    use_secure_session_cookie: configuration.useSecureSessionCookie,\n    use_proxy: configuration.proxyUrl !== undefined ? !!configuration.proxyUrl : undefined,\n    silent_multiple_init: configuration.silentMultipleInit,\n    track_session_across_subdomains: configuration.trackSessionAcrossSubdomains,\n  }\n}\n","export interface Subscription {\n  unsubscribe: () => void\n}\n\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: () => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    if (!this.observers.length && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe() || undefined\n    }\n    this.observers.push(f)\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  const globalObservable = new Observable<T>(() => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n\n  return globalObservable\n}\n","import type { TelemetryEvent, TelemetryConfigurationEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  log: 'log',\n  configuration: 'configuration',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\n","import type { Context } from '../../tools/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { toStackTraceString } from '../../tools/error'\nimport { assign, combine, jsonStringify, performDraw, includes, startsWith, arrayFrom } from '../../tools/utils'\nimport type { Configuration } from '../configuration'\nimport { getExperimentalFeatures, INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration'\nimport type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type { RawTelemetryConfiguration, RawTelemetryEvent } from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (provider: () => Context) => void\n  observable: Observable<TelemetryEvent & Context>\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\nconst telemetryConfiguration: {\n  maxEventsPerPage: number\n  sentEventCount: number\n  telemetryEnabled: boolean\n  telemetryConfigurationEnabled: boolean\n} = { maxEventsPerPage: 0, sentEventCount: 0, telemetryEnabled: false, telemetryConfigurationEnabled: false }\n\nlet onRawTelemetryEventCollected: ((event: RawTelemetryEvent) => void) | undefined\n\nexport function startTelemetry(telemetryService: TelemetryService, configuration: Configuration): Telemetry {\n  let contextProvider: () => Context\n  const observable = new Observable<TelemetryEvent & Context>()\n\n  telemetryConfiguration.telemetryEnabled = performDraw(configuration.telemetrySampleRate)\n  telemetryConfiguration.telemetryConfigurationEnabled =\n    telemetryConfiguration.telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate)\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    if (!includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && telemetryConfiguration.telemetryEnabled) {\n      observable.notify(toTelemetryEvent(telemetryService, event))\n    }\n  }\n  startMonitorErrorCollection(addTelemetryError)\n\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: configuration.maxTelemetryEventsPerPage,\n    sentEventCount: 0,\n  })\n\n  function toTelemetryEvent(telemetryService: TelemetryService, event: RawTelemetryEvent): TelemetryEvent & Context {\n    return combine(\n      {\n        type: 'telemetry' as const,\n        date: timeStampNow(),\n        service: telemetryService,\n        version: __BUILD_ENV__SDK_VERSION__,\n        source: 'browser' as const,\n        _dd: {\n          format_version: 2 as const,\n        },\n        telemetry: event as any, // https://github.com/microsoft/TypeScript/issues/48457\n        experimental_features: arrayFrom(getExperimentalFeatures()),\n      },\n      contextProvider !== undefined ? contextProvider() : {}\n    )\n  }\n\n  return {\n    setContextProvider: (provider: () => Context) => {\n      contextProvider = provider\n    },\n    observable,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: Infinity,\n    sentEventCount: 0,\n  })\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\nexport function resetTelemetry() {\n  onRawTelemetryEventCollected = undefined\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        message,\n        status: StatusType.debug,\n      },\n      context\n    )\n  )\n}\n\nexport function addTelemetryError(e: unknown) {\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        status: StatusType.error,\n      },\n      formatError(e)\n    )\n  )\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  if (telemetryConfiguration.telemetryConfigurationEnabled) {\n    addTelemetry({\n      type: TelemetryType.configuration,\n      configuration,\n    })\n  }\n}\n\nfunction addTelemetry(event: RawTelemetryEvent) {\n  if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {\n    telemetryConfiguration.sentEventCount += 1\n    onRawTelemetryEventCollected(event)\n  }\n}\n\nexport function formatError(e: unknown) {\n  if (e instanceof Error) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: 'Not an instance of error',\n    },\n    message: `Uncaught ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => startsWith(frame.url!, allowedFrameUrl))\n  )\n  return stackTrace\n}\n","import { monitor, noop, Observable } from '@datadog/browser-core'\n\nexport function createDOMMutationObservable() {\n  const MutationObserver = getMutationObserverConstructor()\n\n  const observable: Observable<void> = new Observable<void>(() => {\n    if (!MutationObserver) {\n      return\n    }\n    const observer = new MutationObserver(monitor(() => observable.notify()))\n    observer.observe(document, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n    return () => observer.disconnect()\n  })\n\n  return observable\n}\n\ntype MutationObserverConstructor = new (callback: MutationCallback) => MutationObserver\nexport interface BrowserWindow extends Window {\n  MutationObserver?: MutationObserverConstructor\n  Zone?: {\n    __symbol__: (name: string) => string\n  }\n}\n\nexport function getMutationObserverConstructor(): MutationObserverConstructor | undefined {\n  let constructor: MutationObserverConstructor | undefined\n  const browserWindow: BrowserWindow = window\n\n  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n  // global MutationObserver constructor with a patched version to support the context propagation.\n  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n  // component: on some occasions, the callback is being called in an infinite loop, causing the\n  // page to freeze (even if the callback is completely empty).\n  //\n  // To work around this issue, we try to get the original MutationObserver constructor stored by\n  // Zone.js.\n  //\n  // [1] https://github.com/angular/angular/issues/26948\n  // [2] https://github.com/angular/angular/issues/31712\n  if (browserWindow.Zone) {\n    const zoneSymbol = browserWindow.Zone.__symbol__\n\n    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n    //\n    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n    constructor = browserWindow[zoneSymbol('MutationObserver') as any] as unknown as\n      | MutationObserverConstructor\n      | undefined\n\n    if (!constructor && browserWindow.MutationObserver) {\n      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n      // instance in its properties[4]. Let's get the original MutationObserver constructor from\n      // there.\n      //\n      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n\n      const patchedInstance = new browserWindow.MutationObserver(noop) as any\n      const originalInstance = patchedInstance[zoneSymbol('originalInstance')] as\n        | { constructor: MutationObserverConstructor }\n        | undefined\n\n      constructor = originalInstance && originalInstance.constructor\n    }\n  }\n\n  if (!constructor) {\n    constructor = browserWindow.MutationObserver\n  }\n\n  return constructor\n}\n","import type { RelativeTime, ServerDuration } from '@datadog/browser-core'\nimport {\n  assign,\n  addTelemetryDebug,\n  elapsed,\n  getPathName,\n  includes,\n  isValidUrl,\n  ResourceType,\n  toServerDuration,\n} from '@datadog/browser-core'\n\nimport type { RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\n\nimport type { PerformanceResourceDetailsElement } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\n\nexport interface PerformanceResourceDetails {\n  redirect?: PerformanceResourceDetailsElement\n  dns?: PerformanceResourceDetailsElement\n  connect?: PerformanceResourceDetailsElement\n  ssl?: PerformanceResourceDetailsElement\n  first_byte: PerformanceResourceDetailsElement\n  download: PerformanceResourceDetailsElement\n}\n\nexport const FAKE_INITIAL_DOCUMENT = 'initial_document'\n\nconst RESOURCE_TYPES: Array<[ResourceType, (initiatorType: string, path: string) => boolean]> = [\n  [ResourceType.DOCUMENT, (initiatorType: string) => FAKE_INITIAL_DOCUMENT === initiatorType],\n  [ResourceType.XHR, (initiatorType: string) => 'xmlhttprequest' === initiatorType],\n  [ResourceType.FETCH, (initiatorType: string) => 'fetch' === initiatorType],\n  [ResourceType.BEACON, (initiatorType: string) => 'beacon' === initiatorType],\n  [ResourceType.CSS, (_: string, path: string) => /\\.css$/i.test(path)],\n  [ResourceType.JS, (_: string, path: string) => /\\.js$/i.test(path)],\n  [\n    ResourceType.IMAGE,\n    (initiatorType: string, path: string) =>\n      includes(['image', 'img', 'icon'], initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null,\n  ],\n  [ResourceType.FONT, (_: string, path: string) => /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null],\n  [\n    ResourceType.MEDIA,\n    (initiatorType: string, path: string) =>\n      includes(['audio', 'video'], initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null,\n  ],\n]\n\nexport function computeResourceKind(timing: RumPerformanceResourceTiming) {\n  const url = timing.name\n  if (!isValidUrl(url)) {\n    addTelemetryDebug(`Failed to construct URL for \"${timing.name}\"`)\n    return ResourceType.OTHER\n  }\n  const path = getPathName(url)\n  for (const [type, isType] of RESOURCE_TYPES) {\n    if (isType(timing.initiatorType, path)) {\n      return type\n    }\n  }\n  return ResourceType.OTHER\n}\n\nfunction areInOrder(...numbers: number[]) {\n  for (let i = 1; i < numbers.length; i += 1) {\n    if (numbers[i - 1] > numbers[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function isRequestKind(timing: RumPerformanceResourceTiming) {\n  return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch'\n}\n\nexport function computePerformanceResourceDuration(entry: RumPerformanceResourceTiming): ServerDuration {\n  const { duration, startTime, responseEnd } = entry\n\n  // Safari duration is always 0 on timings blocked by cross origin policies.\n  if (duration === 0 && startTime < responseEnd) {\n    return toServerDuration(elapsed(startTime, responseEnd))\n  }\n\n  return toServerDuration(duration)\n}\n\nexport function computePerformanceResourceDetails(\n  entry: RumPerformanceResourceTiming\n): PerformanceResourceDetails | undefined {\n  const validEntry = toValidEntry(entry)\n\n  if (!validEntry) {\n    return undefined\n  }\n  const {\n    startTime,\n    fetchStart,\n    redirectStart,\n    redirectEnd,\n    domainLookupStart,\n    domainLookupEnd,\n    connectStart,\n    secureConnectionStart,\n    connectEnd,\n    requestStart,\n    responseStart,\n    responseEnd,\n  } = validEntry\n\n  const details: PerformanceResourceDetails = {\n    download: formatTiming(startTime, responseStart, responseEnd),\n    first_byte: formatTiming(startTime, requestStart, responseStart),\n  }\n\n  // Make sure a connection occurred\n  if (connectEnd !== fetchStart) {\n    details.connect = formatTiming(startTime, connectStart, connectEnd)\n\n    // Make sure a secure connection occurred\n    if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {\n      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd)\n    }\n  }\n\n  // Make sure a domain lookup occurred\n  if (domainLookupEnd !== fetchStart) {\n    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd)\n  }\n\n  if (hasRedirection(entry)) {\n    details.redirect = formatTiming(startTime, redirectStart, redirectEnd)\n  }\n\n  return details\n}\n\nexport function toValidEntry(entry: RumPerformanceResourceTiming) {\n  // Ensure timings are in the right order. On top of filtering out potential invalid\n  // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n  // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n  // it.\n  if (\n    !areInOrder(\n      entry.startTime,\n      entry.fetchStart,\n      entry.domainLookupStart,\n      entry.domainLookupEnd,\n      entry.connectStart,\n      entry.connectEnd,\n      entry.requestStart,\n      entry.responseStart,\n      entry.responseEnd\n    )\n  ) {\n    return undefined\n  }\n\n  if (!hasRedirection(entry)) {\n    return entry\n  }\n\n  let { redirectStart, redirectEnd } = entry\n  // Firefox doesn't provide redirect timings on cross origin requests.\n  // Provide a default for those.\n  if (redirectStart < entry.startTime) {\n    redirectStart = entry.startTime\n  }\n  if (redirectEnd < entry.startTime) {\n    redirectEnd = entry.fetchStart\n  }\n\n  // Make sure redirect timings are in order\n  if (!areInOrder(entry.startTime, redirectStart, redirectEnd, entry.fetchStart)) {\n    return undefined\n  }\n\n  return assign({}, entry, {\n    redirectEnd,\n    redirectStart,\n  })\n}\n\nfunction hasRedirection(entry: RumPerformanceResourceTiming) {\n  // The only time fetchStart is different than startTime is if a redirection occurred.\n  return entry.fetchStart !== entry.startTime\n}\n\nfunction formatTiming(origin: RelativeTime, start: RelativeTime, end: RelativeTime) {\n  return {\n    duration: toServerDuration(elapsed(start, end)),\n    start: toServerDuration(elapsed(origin, start)),\n  }\n}\n\nexport function computeSize(entry: RumPerformanceResourceTiming) {\n  // Make sure a request actually occurred\n  if (entry.startTime < entry.responseStart) {\n    return entry.decodedBodySize\n  }\n  return undefined\n}\n\nexport function isAllowedRequestUrl(configuration: RumConfiguration, url: string) {\n  return url && !configuration.isIntakeUrl(url)\n}\n","import type { TimeStamp } from '@datadog/browser-core'\nimport { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core'\n\ninterface DocumentTraceData {\n  traceId: string\n  traceTime: TimeStamp\n}\n\nexport const INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE\n\nexport function getDocumentTraceId(document: Document): string | undefined {\n  const data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document)\n\n  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n    return undefined\n  }\n\n  return data.traceId\n}\n\nexport function getDocumentTraceDataFromMeta(document: Document): DocumentTraceData | undefined {\n  const traceIdMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-id]')\n  const traceTimeMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-time]')\n  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content)\n}\n\nexport function getDocumentTraceDataFromComment(document: Document): DocumentTraceData | undefined {\n  const comment = findTraceComment(document)\n  if (!comment) {\n    return undefined\n  }\n  return createDocumentTraceData(\n    findCommaSeparatedValue(comment, 'trace-id'),\n    findCommaSeparatedValue(comment, 'trace-time')\n  )\n}\n\nexport function createDocumentTraceData(\n  traceId: string | undefined | null,\n  rawTraceTime: string | undefined | null\n): DocumentTraceData | undefined {\n  const traceTime = rawTraceTime && (Number(rawTraceTime) as TimeStamp)\n  if (!traceId || !traceTime) {\n    return undefined\n  }\n\n  return {\n    traceId,\n    traceTime,\n  }\n}\n\nexport function findTraceComment(document: Document): string | undefined {\n  // 1. Try to find the comment as a direct child of the document\n  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n  // value is not an array or string (here, a NodeList).\n  for (let i = 0; i < document.childNodes.length; i += 1) {\n    const comment = getTraceCommentFromNode(document.childNodes[i])\n    if (comment) {\n      return comment\n    }\n  }\n\n  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n  // reverse order, stopping if we come across a non-text node.\n  if (document.body) {\n    for (let i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n      const node = document.body.childNodes[i]\n      const comment = getTraceCommentFromNode(node)\n      if (comment) {\n        return comment\n      }\n      if (!isTextNode(node)) {\n        break\n      }\n    }\n  }\n}\n\nfunction getTraceCommentFromNode(node: Node | null) {\n  if (node && isCommentNode(node)) {\n    const match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data)\n    if (match) {\n      return match[1]\n    }\n  }\n}\n\nfunction isCommentNode(node: Node): node is Comment {\n  return node.nodeName === '#comment'\n}\n\nfunction isTextNode(node: Node): node is Text {\n  return node.nodeName === '#text'\n}\n","import { monitor, Observable, throttle, addEventListener, DOM_EVENT } from '@datadog/browser-core'\n\nexport interface ViewportDimension {\n  height: number\n  width: number\n}\n\nlet viewportObservable: Observable<ViewportDimension> | undefined\n\nexport function initViewportObservable() {\n  if (!viewportObservable) {\n    viewportObservable = createViewportObservable()\n  }\n  return viewportObservable\n}\n\nexport function createViewportObservable() {\n  const observable = new Observable<ViewportDimension>(() => {\n    const { throttled: updateDimension } = throttle(\n      monitor(() => {\n        observable.notify(getViewportDimension())\n      }),\n      200\n    )\n\n    return addEventListener(window, DOM_EVENT.RESIZE, updateDimension, { capture: true, passive: true }).stop\n  })\n\n  return observable\n}\n\n// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport\nexport function getViewportDimension(): ViewportDimension {\n  const visual = window.visualViewport\n  if (visual) {\n    return {\n      width: Number(visual.width * visual.scale),\n      height: Number(visual.height * visual.scale),\n    }\n  }\n\n  return {\n    width: Number(window.innerWidth || 0),\n    height: Number(window.innerHeight || 0),\n  }\n}\n","import { isExperimentalFeatureEnabled } from '@datadog/browser-core'\nimport { getViewportDimension, initViewportObservable } from '../../browser/viewportObservable'\n\nlet viewport: { width: number; height: number } | undefined\nlet stopListeners: (() => void) | undefined\n\nexport function getDisplayContext() {\n  if (!isExperimentalFeatureEnabled('clickmap')) return\n\n  if (!viewport) {\n    viewport = getViewportDimension()\n    stopListeners = initViewportObservable().subscribe((viewportDimension) => {\n      viewport = viewportDimension\n    }).unsubscribe\n  }\n\n  return {\n    viewport,\n  }\n}\n\nexport function resetDisplayContext() {\n  if (stopListeners) stopListeners()\n  viewport = undefined\n}\n","import type { Duration, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  dateNow,\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  getRelativeTime,\n  isNumber,\n  monitor,\n  relativeNow,\n  runOnReadyState,\n} from '@datadog/browser-core'\n\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { FAKE_INITIAL_DOCUMENT, isAllowedRequestUrl } from '../domain/rumEventsCollection/resource/resourceUtils'\n\nimport { getDocumentTraceId } from '../domain/tracing/getDocumentTraceId'\nimport type { PerformanceEntryRepresentation } from '../domainContext.types'\n\nexport interface RumPerformanceResourceTiming {\n  entryType: 'resource'\n  initiatorType: string\n  name: string\n  startTime: RelativeTime\n  duration: Duration\n  fetchStart: RelativeTime\n  domainLookupStart: RelativeTime\n  domainLookupEnd: RelativeTime\n  connectStart: RelativeTime\n  secureConnectionStart: RelativeTime\n  connectEnd: RelativeTime\n  requestStart: RelativeTime\n  responseStart: RelativeTime\n  responseEnd: RelativeTime\n  redirectStart: RelativeTime\n  redirectEnd: RelativeTime\n  decodedBodySize: number\n  traceId?: string\n}\n\nexport interface RumPerformanceLongTaskTiming {\n  entryType: 'longtask'\n  startTime: RelativeTime\n  duration: Duration\n  toJSON(): PerformanceEntryRepresentation\n}\n\nexport interface RumPerformancePaintTiming {\n  entryType: 'paint'\n  name: 'first-paint' | 'first-contentful-paint'\n  startTime: RelativeTime\n}\n\nexport interface RumPerformanceNavigationTiming {\n  entryType: 'navigation'\n  domComplete: RelativeTime\n  domContentLoadedEventEnd: RelativeTime\n  domInteractive: RelativeTime\n  loadEventEnd: RelativeTime\n  responseStart: RelativeTime\n}\n\nexport interface RumLargestContentfulPaintTiming {\n  entryType: 'largest-contentful-paint'\n  startTime: RelativeTime\n  size: number\n}\n\nexport interface RumFirstInputTiming {\n  entryType: 'first-input'\n  startTime: RelativeTime\n  processingStart: RelativeTime\n}\n\nexport interface RumLayoutShiftTiming {\n  entryType: 'layout-shift'\n  startTime: RelativeTime\n  value: number\n  hadRecentInput: boolean\n}\n\nexport type RumPerformanceEntry =\n  | RumPerformanceResourceTiming\n  | RumPerformanceLongTaskTiming\n  | RumPerformancePaintTiming\n  | RumPerformanceNavigationTiming\n  | RumLargestContentfulPaintTiming\n  | RumFirstInputTiming\n  | RumLayoutShiftTiming\n\nfunction supportPerformanceObject() {\n  return window.performance !== undefined && 'getEntries' in performance\n}\n\nexport function supportPerformanceTimingEvent(entryType: string) {\n  return (\n    window.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes !== undefined &&\n    PerformanceObserver.supportedEntryTypes.includes(entryType)\n  )\n}\n\nexport function startPerformanceCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  retrieveInitialDocumentResourceTiming((timing) => {\n    handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n  })\n\n  if (supportPerformanceObject()) {\n    const performanceEntries = performance.getEntries()\n    // Because the performance entry list can be quite large\n    // delay the computation to prevent the SDK from blocking the main thread on init\n    setTimeout(monitor(() => handleRumPerformanceEntries(lifeCycle, configuration, performanceEntries)))\n  }\n\n  if (window.PerformanceObserver) {\n    const handlePerformanceEntryList = monitor((entries: PerformanceObserverEntryList) =>\n      handleRumPerformanceEntries(lifeCycle, configuration, entries.getEntries())\n    )\n    const mainEntries = ['resource', 'navigation', 'longtask', 'paint']\n    const experimentalEntries = ['largest-contentful-paint', 'first-input', 'layout-shift']\n\n    try {\n      // Experimental entries are not retrieved by performance.getEntries()\n      // use a single PerformanceObserver with buffered flag by type\n      // to get values that could happen before SDK init\n      experimentalEntries.forEach((type) => {\n        const observer = new PerformanceObserver(handlePerformanceEntryList)\n        observer.observe({ type, buffered: true })\n      })\n    } catch (e) {\n      // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options\n      // In these cases, fallback to PerformanceObserver with entryTypes\n      mainEntries.push(...experimentalEntries)\n    }\n\n    const mainObserver = new PerformanceObserver(handlePerformanceEntryList)\n    mainObserver.observe({ entryTypes: mainEntries })\n\n    if (supportPerformanceObject() && 'addEventListener' in performance) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n      performance.addEventListener('resourcetimingbufferfull', () => {\n        performance.clearResourceTimings()\n      })\n    }\n  }\n  if (!supportPerformanceTimingEvent('navigation')) {\n    retrieveNavigationTiming((timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n  if (!supportPerformanceTimingEvent('first-input')) {\n    retrieveFirstInputTiming((timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n}\n\nexport function retrieveInitialDocumentResourceTiming(callback: (timing: RumPerformanceResourceTiming) => void) {\n  runOnReadyState('interactive', () => {\n    let timing: RumPerformanceResourceTiming\n\n    const forcedAttributes = {\n      entryType: 'resource' as const,\n      initiatorType: FAKE_INITIAL_DOCUMENT,\n      traceId: getDocumentTraceId(document),\n    }\n    if (supportPerformanceTimingEvent('navigation') && performance.getEntriesByType('navigation').length > 0) {\n      const navigationEntry = performance.getEntriesByType('navigation')[0]\n      timing = assign(navigationEntry.toJSON(), forcedAttributes)\n    } else {\n      const relativePerformanceTiming = computeRelativePerformanceTiming()\n      timing = assign(\n        relativePerformanceTiming,\n        {\n          decodedBodySize: 0,\n          duration: relativePerformanceTiming.responseEnd,\n          name: window.location.href,\n          startTime: 0 as RelativeTime,\n        },\n        forcedAttributes\n      )\n    }\n    callback(timing)\n  })\n}\n\nfunction retrieveNavigationTiming(callback: (timing: RumPerformanceNavigationTiming) => void) {\n  function sendFakeTiming() {\n    callback(\n      assign(computeRelativePerformanceTiming(), {\n        entryType: 'navigation' as const,\n      })\n    )\n  }\n\n  runOnReadyState('complete', () => {\n    // Send it a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n    setTimeout(monitor(sendFakeTiming))\n  })\n}\n\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nfunction retrieveFirstInputTiming(callback: (timing: RumFirstInputTiming) => void) {\n  const startTimeStamp = dateNow()\n  let timingSent = false\n\n  const { stop: removeEventListeners } = addEventListeners(\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.MOUSE_DOWN, DOM_EVENT.KEY_DOWN, DOM_EVENT.TOUCH_START, DOM_EVENT.POINTER_DOWN],\n    (evt) => {\n      // Only count cancelable events, which should trigger behavior important to the user.\n      if (!evt.cancelable) {\n        return\n      }\n\n      // This timing will be used to compute the \"first Input delay\", which is the delta between\n      // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n      // (e.g. performance.now()).\n      const timing: RumFirstInputTiming = {\n        entryType: 'first-input',\n        processingStart: relativeNow(),\n        startTime: evt.timeStamp as RelativeTime,\n      }\n\n      if (evt.type === DOM_EVENT.POINTER_DOWN) {\n        sendTimingIfPointerIsNotCancelled(timing)\n      } else {\n        sendTiming(timing)\n      }\n    },\n    { passive: true, capture: true }\n  )\n\n  /**\n   * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n   * We differentiate these cases based on whether or not we see a pointercancel event, which are\n   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n   * scrolling and pinch/zooming.\n   */\n  function sendTimingIfPointerIsNotCancelled(timing: RumFirstInputTiming) {\n    addEventListeners(\n      window,\n      [DOM_EVENT.POINTER_UP, DOM_EVENT.POINTER_CANCEL],\n      (event) => {\n        if (event.type === DOM_EVENT.POINTER_UP) {\n          sendTiming(timing)\n        }\n      },\n      { once: true }\n    )\n  }\n\n  function sendTiming(timing: RumFirstInputTiming) {\n    if (!timingSent) {\n      timingSent = true\n      removeEventListeners()\n      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n      // the time between now and when the page was loaded.\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n      const delay = timing.processingStart - timing.startTime\n      if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n        callback(timing)\n      }\n    }\n  }\n}\n\nexport type RelativePerformanceTiming = {\n  -readonly [key in keyof Omit<PerformanceTiming, 'toJSON'>]: RelativeTime\n}\n\nfunction computeRelativePerformanceTiming() {\n  const result: Partial<RelativePerformanceTiming> = {}\n  const timing = performance.timing\n  for (const key in timing) {\n    if (isNumber(timing[key as keyof PerformanceTiming])) {\n      const numberKey = key as keyof RelativePerformanceTiming\n      const timingElement = timing[numberKey] as TimeStamp\n      result[numberKey] = timingElement === 0 ? (0 as RelativeTime) : getRelativeTime(timingElement)\n    }\n  }\n  return result as RelativePerformanceTiming\n}\n\nfunction handleRumPerformanceEntries(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  entries: Array<PerformanceEntry | RumPerformanceEntry>\n) {\n  const rumPerformanceEntries = entries.filter(\n    (entry) =>\n      entry.entryType === 'resource' ||\n      entry.entryType === 'navigation' ||\n      entry.entryType === 'paint' ||\n      entry.entryType === 'longtask' ||\n      entry.entryType === 'largest-contentful-paint' ||\n      entry.entryType === 'first-input' ||\n      entry.entryType === 'layout-shift'\n  ) as RumPerformanceEntry[]\n\n  const rumAllowedPerformanceEntries = rumPerformanceEntries.filter(\n    (entry) => !isIncompleteNavigation(entry) && !isForbiddenResource(configuration, entry)\n  )\n\n  if (rumAllowedPerformanceEntries.length) {\n    lifeCycle.notify(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, rumAllowedPerformanceEntries)\n  }\n}\n\nfunction isIncompleteNavigation(entry: RumPerformanceEntry) {\n  return entry.entryType === 'navigation' && entry.loadEventEnd <= 0\n}\n\nfunction isForbiddenResource(configuration: RumConfiguration, entry: RumPerformanceEntry) {\n  return entry.entryType === 'resource' && !isAllowedRequestUrl(configuration, entry.name)\n}\n","import type { RawError } from './error'\nimport { ErrorSource } from './error'\nimport { clocksNow } from './timeUtils'\nimport { ONE_MINUTE } from './utils'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n","import type { Context } from './context'\nimport { deepClone, getType } from './utils'\n\n/**\n * Current limitation:\n * - field path do not support array, 'a.b.c' only\n */\nexport function limitModification<T extends Context, Result>(\n  object: T,\n  modifiableFieldPaths: string[],\n  modifier: (object: T) => Result\n): Result | undefined {\n  const clone = deepClone(object)\n  const result = modifier(clone)\n  modifiableFieldPaths.forEach((path) => {\n    const originalValue = get(object, path)\n    const newValue = get(clone, path)\n    const originalType = getType(originalValue)\n    const newType = getType(newValue)\n    if (newType === originalType) {\n      set(object, path, newValue)\n    } else if (originalType === 'object' && (newType === 'undefined' || newType === 'null')) {\n      set(object, path, {})\n    }\n  })\n  return result\n}\n\nfunction get(object: unknown, path: string) {\n  let current = object\n  for (const field of path.split('.')) {\n    if (!isValidObjectContaining(current, field)) {\n      return\n    }\n    current = current[field]\n  }\n  return current\n}\n\nfunction set(object: unknown, path: string, value: unknown) {\n  let current = object\n  const fields = path.split('.')\n  for (let i = 0; i < fields.length; i += 1) {\n    const field = fields[i]\n    if (!isValidObjectContaining(current, field)) {\n      return\n    }\n    if (i !== fields.length - 1) {\n      current = current[field]\n    } else {\n      current[field] = value\n    }\n  }\n}\n\nfunction isValidObjectContaining(object: unknown, field: string): object is { [key: string]: unknown } {\n  return typeof object === 'object' && object !== null && Object.prototype.hasOwnProperty.call(object, field)\n}\n","import { getSyntheticsResultId, getSyntheticsTestId, willSyntheticsInjectRum } from '@datadog/browser-core'\n\nexport function getSyntheticsContext() {\n  const testId = getSyntheticsTestId()\n  const resultId = getSyntheticsResultId()\n\n  if (testId && resultId) {\n    return {\n      test_id: testId,\n      result_id: resultId,\n      injected: willSyntheticsInjectRum(),\n    }\n  }\n}\n","import type { Context, RawError, EventRateLimiter } from '@datadog/browser-core'\nimport {\n  combine,\n  isEmptyObject,\n  limitModification,\n  timeStampNow,\n  currentDrift,\n  display,\n  createEventRateLimiter,\n  canUseEventBridge,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type {\n  CommonContext,\n  RawRumErrorEvent,\n  RawRumEvent,\n  RawRumLongTaskEvent,\n  RawRumResourceEvent,\n  RumContext,\n  User,\n} from '../rawRumEvent.types'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport { getSyntheticsContext } from './contexts/syntheticsContext'\nimport { getCiTestContext } from './contexts/ciTestContext'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { ViewContexts } from './contexts/viewContexts'\nimport type { RumSessionManager } from './rumSessionManager'\nimport type { UrlContexts } from './contexts/urlContexts'\nimport type { RumConfiguration } from './configuration'\nimport type { ActionContexts } from './rumEventsCollection/action/actionCollection'\nimport { getDisplayContext } from './contexts/displayContext'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst enum SessionType {\n  SYNTHETICS = 'synthetics',\n  USER = 'user',\n  CI_TEST = 'ci_test',\n}\n\nconst VIEW_EVENTS_MODIFIABLE_FIELD_PATHS = [\n  // Fields with sensitive data\n  'view.url',\n  'view.referrer',\n  'action.target.name',\n  'error.message',\n  'error.stack',\n  'error.resource.url',\n  'resource.url',\n]\n\nconst OTHER_EVENTS_MODIFIABLE_FIELD_PATHS = VIEW_EVENTS_MODIFIABLE_FIELD_PATHS.concat([\n  // User-customizable field\n  'context',\n])\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] }\n\nexport function startRumAssembly(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  urlContexts: UrlContexts,\n  actionContexts: ActionContexts,\n  getCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  const eventRateLimiters = {\n    [RumEventType.ERROR]: createEventRateLimiter(\n      RumEventType.ERROR,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n    [RumEventType.ACTION]: createEventRateLimiter(\n      RumEventType.ACTION,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n  }\n\n  const syntheticsContext = getSyntheticsContext()\n  const ciTestContext = getCiTestContext()\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n    ({ startTime, rawRumEvent, domainContext, savedCommonContext, customerContext }) => {\n      const viewContext = viewContexts.findView(startTime)\n      const urlContext = urlContexts.findUrl(startTime)\n      // allow to send events if the session was tracked when they start\n      // except for views which are continuously updated\n      // TODO: stop sending view updates when session is expired\n      const session = sessionManager.findTrackedSession(rawRumEvent.type !== RumEventType.VIEW ? startTime : undefined)\n      if (session && viewContext && urlContext) {\n        const commonContext = savedCommonContext || getCommonContext()\n        const actionId = actionContexts.findActionId(startTime)\n\n        const rumContext: RumContext = {\n          _dd: {\n            format_version: 2,\n            drift: currentDrift(),\n            session: {\n              plan: session.plan,\n            },\n            browser_sdk_version: canUseEventBridge() ? __BUILD_ENV__SDK_VERSION__ : undefined,\n          },\n          application: {\n            id: configuration.applicationId,\n          },\n          date: timeStampNow(),\n          service: viewContext.service || configuration.service,\n          version: viewContext.version || configuration.version,\n          source: 'browser',\n          session: {\n            id: session.id,\n            type: syntheticsContext ? SessionType.SYNTHETICS : ciTestContext ? SessionType.CI_TEST : SessionType.USER,\n          },\n          view: {\n            id: viewContext.id,\n            name: viewContext.name,\n            url: urlContext.url,\n            referrer: urlContext.referrer,\n          },\n          action: needToAssembleWithAction(rawRumEvent) && actionId ? { id: actionId } : undefined,\n          synthetics: syntheticsContext,\n          ci_test: ciTestContext,\n          display: getDisplayContext(),\n        }\n\n        const serverRumEvent = combine(rumContext as RumContext & Context, rawRumEvent) as RumEvent & Context\n        serverRumEvent.context = combine(commonContext.context, customerContext)\n\n        if (!('has_replay' in serverRumEvent.session)) {\n          ;(serverRumEvent.session as Mutable<RumEvent['session']>).has_replay = commonContext.hasReplay\n        }\n\n        if (!isEmptyObject(commonContext.user)) {\n          ;(serverRumEvent.usr as Mutable<RumEvent['usr']>) = commonContext.user as User & Context\n        }\n\n        if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {\n          if (isEmptyObject(serverRumEvent.context)) {\n            delete serverRumEvent.context\n          }\n          lifeCycle.notify(LifeCycleEventType.RUM_EVENT_COLLECTED, serverRumEvent)\n        }\n      }\n    }\n  )\n}\n\nfunction shouldSend(\n  event: RumEvent & Context,\n  beforeSend: RumConfiguration['beforeSend'],\n  domainContext: RumEventDomainContext,\n  eventRateLimiters: { [key in RumEventType]?: EventRateLimiter }\n) {\n  if (beforeSend) {\n    const result = limitModification(\n      event,\n      event.type === RumEventType.VIEW ? VIEW_EVENTS_MODIFIABLE_FIELD_PATHS : OTHER_EVENTS_MODIFIABLE_FIELD_PATHS,\n      (event) => beforeSend(event, domainContext)\n    )\n    if (result === false && event.type !== RumEventType.VIEW) {\n      return false\n    }\n    if (result === false) {\n      display.warn(\"Can't dismiss view events using beforeSend!\")\n    }\n  }\n\n  const rateLimitReached = eventRateLimiters[event.type]?.isLimitReached()\n  return !rateLimitReached\n}\n\nfunction needToAssembleWithAction(\n  event: RawRumEvent\n): event is RawRumErrorEvent | RawRumResourceEvent | RawRumLongTaskEvent {\n  return [RumEventType.ERROR, RumEventType.RESOURCE, RumEventType.LONG_TASK].indexOf(event.type) !== -1\n}\n","export interface CiTestWindow extends Window {\n  Cypress?: {\n    env: (key: string) => string | undefined\n  }\n}\n\nexport function getCiTestContext() {\n  const testExecutionId = (window as CiTestWindow).Cypress?.env('traceId')\n\n  if (typeof testExecutionId === 'string') {\n    return {\n      test_execution_id: testExecutionId,\n    }\n  }\n}\n","import type { RelativeTime, Duration } from '@datadog/browser-core'\nimport { addDuration, addEventListener, DOM_EVENT, elapsed, relativeNow, toServerDuration } from '@datadog/browser-core'\nimport type { InForegroundPeriod } from '../../rawRumEvent.types'\n\n// Arbitrary value to cap number of element mostly for backend & to save bandwidth\nexport const MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS = 500\n// Arbitrary value to cap number of element mostly for memory consumption in the browser\nexport const MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS = 2500\n\nexport interface ForegroundContexts {\n  isInForegroundAt: (startTime: RelativeTime) => boolean | undefined\n  selectInForegroundPeriodsFor: (startTime: RelativeTime, duration: Duration) => InForegroundPeriod[] | undefined\n  stop: () => void\n}\n\nexport interface ForegroundPeriod {\n  start: RelativeTime\n  end?: RelativeTime\n}\n\nlet foregroundPeriods: ForegroundPeriod[] = []\n\nexport function startForegroundContexts(): ForegroundContexts {\n  if (document.hasFocus()) {\n    addNewForegroundPeriod()\n  }\n\n  const { stop: stopForegroundTracking } = trackFocus(addNewForegroundPeriod)\n  const { stop: stopBlurTracking } = trackBlur(closeForegroundPeriod)\n  return {\n    isInForegroundAt,\n    selectInForegroundPeriodsFor,\n    stop: () => {\n      foregroundPeriods = []\n      stopForegroundTracking()\n      stopBlurTracking()\n    },\n  }\n}\n\nexport function addNewForegroundPeriod() {\n  if (foregroundPeriods.length > MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS) {\n    return\n  }\n  const currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1]\n  const now = relativeNow()\n  if (currentForegroundPeriod !== undefined && currentForegroundPeriod.end === undefined) {\n    return\n  }\n  foregroundPeriods.push({\n    start: now,\n  })\n}\n\nexport function closeForegroundPeriod() {\n  if (foregroundPeriods.length === 0) {\n    return\n  }\n  const currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1]\n  const now = relativeNow()\n  if (currentForegroundPeriod.end !== undefined) {\n    return\n  }\n  currentForegroundPeriod.end = now\n}\n\nfunction trackFocus(onFocusChange: () => void) {\n  return addEventListener(window, DOM_EVENT.FOCUS, (event) => {\n    if (!event.isTrusted) {\n      return\n    }\n    onFocusChange()\n  })\n}\n\nfunction trackBlur(onBlurChange: () => void) {\n  return addEventListener(window, DOM_EVENT.BLUR, (event) => {\n    if (!event.isTrusted) {\n      return\n    }\n    onBlurChange()\n  })\n}\n\nfunction isInForegroundAt(startTime: RelativeTime): boolean {\n  for (let i = foregroundPeriods.length - 1; i >= 0; i--) {\n    const foregroundPeriod = foregroundPeriods[i]\n    if (foregroundPeriod.end !== undefined && startTime > foregroundPeriod.end) {\n      break\n    }\n    if (\n      startTime > foregroundPeriod.start &&\n      (foregroundPeriod.end === undefined || startTime < foregroundPeriod.end)\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction selectInForegroundPeriodsFor(eventStartTime: RelativeTime, duration: Duration): InForegroundPeriod[] {\n  const eventEndTime = addDuration(eventStartTime, duration)\n  const filteredForegroundPeriods: InForegroundPeriod[] = []\n\n  const earliestIndex = Math.max(0, foregroundPeriods.length - MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS)\n  for (let i = foregroundPeriods.length - 1; i >= earliestIndex; i--) {\n    const foregroundPeriod = foregroundPeriods[i]\n    if (foregroundPeriod.end !== undefined && eventStartTime > foregroundPeriod.end) {\n      // event starts after the end of the current focus period\n      // since the array is sorted, we can stop looking for foreground periods\n      break\n    }\n    if (eventEndTime < foregroundPeriod.start) {\n      // event ends before the start of the current focus period\n      // continue to previous one\n      continue\n    }\n    const startTime = eventStartTime > foregroundPeriod.start ? eventStartTime : foregroundPeriod.start\n    const startDuration = elapsed(eventStartTime, startTime)\n    const endTime =\n      foregroundPeriod.end === undefined || eventEndTime < foregroundPeriod.end ? eventEndTime : foregroundPeriod.end\n    const endDuration = elapsed(startTime, endTime)\n    filteredForegroundPeriods.unshift({\n      start: toServerDuration(startDuration),\n      duration: toServerDuration(endDuration),\n    })\n  }\n  return filteredForegroundPeriods\n}\n","import type { Context, RawError, RelativeTime, Subscription } from '@datadog/browser-core'\nimport type { RumPerformanceEntry } from '../browser/performanceCollection'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { CommonContext, RawRumEvent } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { RequestCompleteEvent, RequestStartEvent } from './requestCollection'\nimport type { AutoAction } from './rumEventsCollection/action/actionCollection'\nimport type { ViewEvent, ViewCreatedEvent, ViewEndedEvent } from './rumEventsCollection/view/trackViews'\n\nexport const enum LifeCycleEventType {\n  PERFORMANCE_ENTRIES_COLLECTED,\n  AUTO_ACTION_COMPLETED,\n  VIEW_CREATED,\n  VIEW_UPDATED,\n  VIEW_ENDED,\n  REQUEST_STARTED,\n  REQUEST_COMPLETED,\n\n  // The SESSION_EXPIRED lifecycle event has been introduced to represent when a session has expired\n  // and trigger cleanup tasks related to this, prior to renewing the session. Its implementation is\n  // slightly naive: it is not triggered as soon as the session is expired, but rather just before\n  // notifying that the session is renewed. Thus, the session id is already set to the newly renewed\n  // session.\n  //\n  // This implementation is \"good enough\" for our use-cases. Improving this is not trivial,\n  // primarily because multiple instances of the SDK may be managing the same session cookie at\n  // the same time, for example when using Logs and RUM on the same page, or opening multiple tabs\n  // on the same domain.\n  SESSION_EXPIRED,\n\n  SESSION_RENEWED,\n  BEFORE_UNLOAD,\n  RAW_RUM_EVENT_COLLECTED,\n  RUM_EVENT_COLLECTED,\n  RAW_ERROR_COLLECTED,\n}\n\nexport class LifeCycle {\n  private callbacks: { [key in LifeCycleEventType]?: Array<(data: any) => void> } = {}\n\n  notify(eventType: LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, data: RumPerformanceEntry[]): void\n  notify(eventType: LifeCycleEventType.REQUEST_STARTED, data: RequestStartEvent): void\n  notify(eventType: LifeCycleEventType.REQUEST_COMPLETED, data: RequestCompleteEvent): void\n  notify(eventType: LifeCycleEventType.AUTO_ACTION_COMPLETED, data: AutoAction): void\n  notify(eventType: LifeCycleEventType.VIEW_CREATED, data: ViewCreatedEvent): void\n  notify(eventType: LifeCycleEventType.VIEW_UPDATED, data: ViewEvent): void\n  notify(eventType: LifeCycleEventType.VIEW_ENDED, data: ViewEndedEvent): void\n  notify(\n    eventType: LifeCycleEventType.RAW_ERROR_COLLECTED,\n    data: { error: RawError; savedCommonContext?: CommonContext; customerContext?: Context }\n  ): void\n  notify(\n    eventType:\n      | LifeCycleEventType.SESSION_EXPIRED\n      | LifeCycleEventType.SESSION_RENEWED\n      | LifeCycleEventType.BEFORE_UNLOAD\n  ): void\n  notify(eventType: LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, data: RawRumEventCollectedData): void\n  notify(eventType: LifeCycleEventType.RUM_EVENT_COLLECTED, data: RumEvent & Context): void\n  notify(eventType: LifeCycleEventType, data?: any) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe(\n    eventType: LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    callback: (data: RumPerformanceEntry[]) => void\n  ): Subscription\n  subscribe(eventType: LifeCycleEventType.REQUEST_STARTED, callback: (data: RequestStartEvent) => void): Subscription\n  subscribe(\n    eventType: LifeCycleEventType.REQUEST_COMPLETED,\n    callback: (data: RequestCompleteEvent) => void\n  ): Subscription\n  subscribe(eventType: LifeCycleEventType.AUTO_ACTION_COMPLETED, callback: (data: AutoAction) => void): Subscription\n  subscribe(eventType: LifeCycleEventType.VIEW_CREATED, callback: (data: ViewCreatedEvent) => void): Subscription\n  subscribe(eventType: LifeCycleEventType.VIEW_UPDATED, callback: (data: ViewEvent) => void): Subscription\n  subscribe(eventType: LifeCycleEventType.VIEW_ENDED, callback: (data: ViewEndedEvent) => void): Subscription\n  subscribe(\n    eventType: LifeCycleEventType.RAW_ERROR_COLLECTED,\n    callback: (data: { error: RawError; savedCommonContext?: CommonContext; customerContext?: Context }) => void\n  ): Subscription\n  subscribe(\n    eventType:\n      | LifeCycleEventType.SESSION_EXPIRED\n      | LifeCycleEventType.SESSION_RENEWED\n      | LifeCycleEventType.BEFORE_UNLOAD,\n    callback: () => void\n  ): Subscription\n  subscribe(\n    eventType: LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n    callback: (data: RawRumEventCollectedData) => void\n  ): Subscription\n  subscribe(\n    eventType: LifeCycleEventType.RUM_EVENT_COLLECTED,\n    callback: (data: RumEvent & Context) => void\n  ): Subscription\n  subscribe(eventType: LifeCycleEventType, callback: (data?: any) => void) {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n\nexport interface RawRumEventCollectedData<E extends RawRumEvent = RawRumEvent> {\n  startTime: RelativeTime\n  savedCommonContext?: CommonContext\n  customerContext?: Context\n  rawRumEvent: E\n  domainContext: RumEventDomainContext<E['type']>\n}\n","import { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod'\nimport { monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { Duration, RelativeTime, ClocksState } from '../tools/timeUtils'\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/timeUtils'\nimport { normalizeUrl } from '../tools/urlPolyfill'\nimport { shallowClone } from '../tools/utils'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startTime: RelativeTime // deprecated\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable() {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable()\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable() {\n  const observable = new Observable<XhrContext>(() => {\n    const { stop: stopInstrumentingStart } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr,\n    })\n\n    const { stop: stopInstrumentingSend } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before() {\n        sendXhr.call(this, observable)\n      },\n    })\n\n    const { stop: stopInstrumentingAbort } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr,\n    })\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n  return observable\n}\n\nfunction openXhr(this: XMLHttpRequest, method: string, url: string | URL | undefined | null) {\n  xhrContexts.set(this, {\n    state: 'open',\n    method,\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(this: XMLHttpRequest, observable: Observable<XhrContext>) {\n  const context = xhrContexts.get(this)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startTime = relativeNow()\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = this\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before() {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd()\n      }\n    },\n  })\n\n  const onEnd = monitor(() => {\n    this.removeEventListener('loadend', onEnd)\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = this.status\n    observable.notify(shallowClone(completeContext))\n  })\n  this.addEventListener('loadend', onEnd)\n  observable.notify(startContext)\n}\n\nfunction abortXhr(this: XMLHttpRequest) {\n  const context = xhrContexts.get(this) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n","import { ONE_HOUR, ONE_MINUTE } from '../../tools/utils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\n","import type { RelativeTime } from './timeUtils'\nimport { relativeNow } from './timeUtils'\nimport type { TimeoutId } from './utils'\nimport { ONE_MINUTE } from './utils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ContextHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  context: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_CONTEXTS_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of contexts spans. This whole class assumes that contexts are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ContextHistory<Context> {\n  private entries: Array<ContextHistoryEntry<Context>> = []\n  private clearOldContextsInterval: TimeoutId\n\n  constructor(private expireDelay: number) {\n    this.clearOldContextsInterval = setInterval(() => this.clearOldContexts(), CLEAR_OLD_CONTEXTS_INTERVAL)\n  }\n\n  /**\n   * Add a context to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(context: Context, startTime: RelativeTime): ContextHistoryEntry<Context> {\n    const entry: ContextHistoryEntry<Context> = {\n      context,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        const index = this.entries.indexOf(entry)\n        if (index >= 0) {\n          this.entries.splice(index, 1)\n        }\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n    this.entries.unshift(entry)\n    return entry\n  }\n\n  /**\n   * Return the latest context that was active during `startTime`, or the currently active context\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  find(startTime: RelativeTime = END_OF_TIMES): Context | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.context\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active context, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all contexts that were active during `startTime`, or all currently active contexts if no\n   * `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES): Context[] {\n    return this.entries\n      .filter((entry) => entry.startTime <= startTime && startTime <= entry.endTime)\n      .map((entry) => entry.context)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldContextsInterval)\n  }\n\n  private clearOldContexts() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n","import { callMonitored, monitor } from './monitor'\nimport { noop } from './utils'\n\nexport function instrumentMethod<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  instrumentationFactory: (\n    original: OBJECT[METHOD]\n  ) => (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => ReturnType<OBJECT[METHOD]>\n) {\n  const original = object[method]\n\n  let instrumentation = instrumentationFactory(original)\n\n  const instrumentationWrapper = function (this: OBJECT): ReturnType<OBJECT[METHOD]> | undefined {\n    if (typeof instrumentation !== 'function') {\n      return undefined\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return instrumentation.apply(this, arguments as unknown as Parameters<OBJECT[METHOD]>)\n  }\n  object[method] = instrumentationWrapper as OBJECT[METHOD]\n\n  return {\n    stop: () => {\n      if (object[method] === instrumentationWrapper) {\n        object[method] = original\n      } else {\n        instrumentation = original\n      }\n    },\n  }\n}\n\nexport function instrumentMethodAndCallOriginal<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  {\n    before,\n    after,\n  }: {\n    before?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n    after?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n  }\n) {\n  return instrumentMethod(\n    object,\n    method,\n    (original) =>\n      function () {\n        const args = arguments as unknown as Parameters<OBJECT[METHOD]>\n        let result\n\n        if (before) {\n          callMonitored(before, this as ThisParameterType<OBJECT[METHOD]>, args)\n        }\n\n        if (typeof original === 'function') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          result = original.apply(this, args)\n        }\n\n        if (after) {\n          callMonitored(after, this as ThisParameterType<OBJECT[METHOD]>, args)\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result\n      }\n  )\n}\n\nexport function instrumentSetter<OBJECT extends { [key: string]: any }, PROPERTY extends keyof OBJECT>(\n  object: OBJECT,\n  property: PROPERTY,\n  after: (thisObject: OBJECT, value: OBJECT[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(object, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  let instrumentation = (thisObject: OBJECT, value: OBJECT[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(\n      monitor(() => {\n        after(thisObject, value)\n      }),\n      0\n    )\n  }\n\n  const instrumentationWrapper = function (this: OBJECT, value: OBJECT[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(object, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(object, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(object, property, originalDescriptor)\n      } else {\n        instrumentation = noop\n      }\n    },\n  }\n}\n","import { instrumentMethod } from '../tools/instrumentMethod'\nimport { callMonitored, monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { Duration, ClocksState } from '../tools/timeUtils'\nimport { elapsed, clocksNow, timeStampNow } from '../tools/timeUtils'\nimport { normalizeUrl } from '../tools/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: RequestInfo\n  init?: RequestInit\n  url: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchCompleteContext extends FetchContextBase {\n  state: 'complete'\n  duration: Duration\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchCompleteContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nfunction createFetchObservable() {\n  const observable = new Observable<FetchContext>(() => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(\n      window,\n      'fetch',\n      (originalFetch) =>\n        function (input, init) {\n          let responsePromise: Promise<Response>\n\n          const context = callMonitored(beforeSend, null, [observable, input, init])\n          if (context) {\n            responsePromise = originalFetch.call(this, context.input, context.init)\n            callMonitored(afterSend, null, [observable, responsePromise, context])\n          } else {\n            responsePromise = originalFetch.call(this, input, init)\n          }\n\n          return responsePromise\n        }\n    )\n\n    return stop\n  })\n\n  return observable\n}\n\nfunction beforeSend(observable: Observable<FetchContext>, input: RequestInfo, init?: RequestInit) {\n  const method = (init && init.method) || (typeof input === 'object' && input.method) || 'GET'\n  const url = normalizeUrl((typeof input === 'object' && input.url) || (input as string))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n  }\n\n  observable.notify(context)\n\n  return context\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const reportFetch = (response: Response | Error) => {\n    const context = startContext as unknown as FetchCompleteContext\n    context.state = 'complete'\n    context.duration = elapsed(context.startClocks.timeStamp, timeStampNow())\n\n    if ('stack' in response || response instanceof Error) {\n      context.status = 0\n      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR\n      context.error = response\n\n      observable.notify(context)\n    } else if ('status' in response) {\n      context.response = response\n      context.responseType = response.type\n      context.status = response.status\n      context.isAborted = false\n\n      observable.notify(context)\n    }\n  }\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch))\n}\n","import { getOrigin, matchList, objectEntries, shallowClone, performDraw, isNumber } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type {\n  RumFetchCompleteContext,\n  RumFetchStartContext,\n  RumXhrCompleteContext,\n  RumXhrStartContext,\n} from '../requestCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\n\nexport interface Tracer {\n  traceFetch: (context: Partial<RumFetchStartContext>) => void\n  traceXhr: (context: Partial<RumXhrStartContext>, xhr: XMLHttpRequest) => void\n  clearTracingIfNeeded: (context: RumFetchCompleteContext | RumXhrCompleteContext) => void\n}\n\ninterface TracingHeaders {\n  [key: string]: string\n}\n\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context: RumFetchCompleteContext | RumXhrCompleteContext) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined\n    context.spanId = undefined\n    context.traceSampled = undefined\n  }\n}\n\nexport function startTracer(configuration: RumConfiguration, sessionManager: RumSessionManager): Tracer {\n  return {\n    clearTracingIfNeeded,\n    traceFetch: (context) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        if (context.input instanceof Request && !context.init?.headers) {\n          context.input = new Request(context.input)\n          Object.keys(tracingHeaders).forEach((key) => {\n            ;(context.input as Request).headers.append(key, tracingHeaders[key])\n          })\n        } else {\n          context.init = shallowClone(context.init)\n          const headers: string[][] = []\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach((value, key) => {\n              headers.push([key, value])\n            })\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach((header) => {\n              headers.push(header)\n            })\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach((key) => {\n              headers.push([key, (context.init!.headers as Record<string, string>)[key]])\n            })\n          }\n          context.init.headers = headers.concat(objectEntries(tracingHeaders) as string[][])\n        }\n      }),\n    traceXhr: (context, xhr) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        Object.keys(tracingHeaders).forEach((name) => {\n          xhr.setRequestHeader(name, tracingHeaders[name])\n        })\n      }),\n  }\n}\n\nfunction injectHeadersIfTracingAllowed(\n  configuration: RumConfiguration,\n  context: Partial<RumFetchStartContext | RumXhrStartContext>,\n  sessionManager: RumSessionManager,\n  inject: (tracingHeaders: TracingHeaders) => void\n) {\n  if (!isTracingSupported() || !isAllowedUrl(configuration, context.url!) || !sessionManager.findTrackedSession()) {\n    return\n  }\n\n  context.traceId = new TraceIdentifier()\n  context.spanId = new TraceIdentifier()\n  context.traceSampled = !isNumber(configuration.tracingSampleRate) || performDraw(configuration.tracingSampleRate)\n  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled))\n}\n\nfunction isAllowedUrl(configuration: RumConfiguration, requestUrl: string) {\n  return matchList(configuration.allowedTracingOrigins, getOrigin(requestUrl))\n}\n\nexport function isTracingSupported() {\n  return getCrypto() !== undefined\n}\n\nfunction getCrypto() {\n  return window.crypto || (window as any).msCrypto\n}\n\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(traceId: TraceIdentifier, spanId: TraceIdentifier, traceSampled: boolean): TracingHeaders {\n  return {\n    'x-datadog-origin': 'rum',\n    'x-datadog-parent-id': spanId.toDecimalString(),\n    'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n    'x-datadog-trace-id': traceId.toDecimalString(),\n  }\n}\n\n/* eslint-disable no-bitwise */\nexport class TraceIdentifier {\n  private buffer: Uint8Array = new Uint8Array(8)\n\n  constructor() {\n    getCrypto().getRandomValues(this.buffer)\n    this.buffer[0] = this.buffer[0] & 0x7f // force 63-bit\n  }\n\n  toString(radix: number) {\n    let high = this.readInt32(0)\n    let low = this.readInt32(4)\n    let str = ''\n\n    do {\n      const mod = (high % radix) * 4294967296 + low\n      high = Math.floor(high / radix)\n      low = Math.floor(mod / radix)\n      str = (mod % radix).toString(radix) + str\n    } while (high || low)\n\n    return str\n  }\n\n  /**\n   * Format used everywhere except the trace intake\n   */\n  toDecimalString() {\n    return this.toString(10)\n  }\n\n  private readInt32(offset: number) {\n    return (\n      this.buffer[offset] * 16777216 +\n      (this.buffer[offset + 1] << 16) +\n      (this.buffer[offset + 2] << 8) +\n      this.buffer[offset + 3]\n    )\n  }\n}\n/* eslint-enable no-bitwise */\n","import type {\n  Duration,\n  XhrCompleteContext,\n  XhrStartContext,\n  ClocksState,\n  FetchStartContext,\n  FetchCompleteContext,\n} from '@datadog/browser-core'\nimport { RequestType, initFetchObservable, initXhrObservable } from '@datadog/browser-core'\nimport type { RumSessionManager } from '..'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { isAllowedRequestUrl } from './rumEventsCollection/resource/resourceUtils'\nimport type { TraceIdentifier, Tracer } from './tracing/tracer'\nimport { startTracer } from './tracing/tracer'\n\nexport interface CustomContext {\n  requestIndex: number\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n}\nexport interface RumFetchStartContext extends FetchStartContext, CustomContext {}\nexport interface RumFetchCompleteContext extends FetchCompleteContext, CustomContext {}\nexport interface RumXhrStartContext extends XhrStartContext, CustomContext {}\nexport interface RumXhrCompleteContext extends XhrCompleteContext, CustomContext {}\n\nexport interface RequestStartEvent {\n  requestIndex: number\n  url: string\n}\n\nexport interface RequestCompleteEvent {\n  requestIndex: number\n  type: RequestType\n  method: string\n  url: string\n  status: number\n  responseType?: string\n  startClocks: ClocksState\n  duration: Duration\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n  xhr?: XMLHttpRequest\n  response?: Response\n  input?: RequestInfo\n  init?: RequestInit\n  error?: Error\n}\n\nlet nextRequestIndex = 1\n\nexport function startRequestCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n) {\n  const tracer = startTracer(configuration, sessionManager)\n  trackXhr(lifeCycle, configuration, tracer)\n  trackFetch(lifeCycle, configuration, tracer)\n}\n\nexport function trackXhr(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initXhrObservable().subscribe((rawContext) => {\n    const context = rawContext as RumXhrStartContext | RumXhrCompleteContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceXhr(context, context.xhr)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.XHR,\n          url: context.url,\n          xhr: context.xhr,\n        })\n        break\n    }\n  })\n\n  return { stop: () => subscription.unsubscribe() }\n}\n\nexport function trackFetch(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initFetchObservable().subscribe((rawContext) => {\n    const context = rawContext as RumFetchCompleteContext | RumFetchStartContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceFetch(context)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          responseType: context.responseType,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.FETCH,\n          url: context.url,\n          response: context.response,\n          init: context.init,\n          input: context.input,\n        })\n        break\n    }\n  })\n  return { stop: () => subscription.unsubscribe() }\n}\n\nfunction getNextRequestIndex() {\n  const result = nextRequestIndex\n  nextRequestIndex += 1\n  return result\n}\n","import { noop } from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport interface EventCounts {\n  errorCount: number\n  actionCount: number\n  longTaskCount: number\n  resourceCount: number\n  frustrationCount: number\n}\n\nexport function trackEventCounts(lifeCycle: LifeCycle, callback: (eventCounts: EventCounts) => void = noop) {\n  const eventCounts: EventCounts = {\n    errorCount: 0,\n    longTaskCount: 0,\n    resourceCount: 0,\n    actionCount: 0,\n    frustrationCount: 0,\n  }\n\n  const subscription = lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event): void => {\n    switch (event.type) {\n      case RumEventType.ERROR:\n        eventCounts.errorCount += 1\n        callback(eventCounts)\n        break\n      case RumEventType.ACTION:\n        eventCounts.actionCount += 1\n        if (event.action.frustration) {\n          eventCounts.frustrationCount += event.action.frustration.type.length\n        }\n        callback(eventCounts)\n        break\n      case RumEventType.LONG_TASK:\n        eventCounts.longTaskCount += 1\n        callback(eventCounts)\n        break\n      case RumEventType.RESOURCE:\n        eventCounts.resourceCount += 1\n        callback(eventCounts)\n        break\n    }\n  })\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n    eventCounts,\n  }\n}\n","import type { Subscription, TimeoutId, TimeStamp } from '@datadog/browser-core'\nimport { instrumentMethodAndCallOriginal, matchList, monitor, Observable, timeStampNow } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100\n\nexport interface PageActivityEvent {\n  isBusy: boolean\n}\n\nexport type PageActivityEndEvent = { hadActivity: true; end: TimeStamp } | { hadActivity: false }\n\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration)\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration)\n}\n\nexport function doWaitPageActivityEnd(\n  pageActivityObservable: Observable<PageActivityEvent>,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  let pageActivityEndTimeoutId: TimeoutId\n  let hasCompleted = false\n\n  const validationTimeoutId = setTimeout(\n    monitor(() => complete({ hadActivity: false })),\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n  const maxDurationTimeoutId =\n    maxDuration &&\n    setTimeout(\n      monitor(() => complete({ hadActivity: true, end: timeStampNow() })),\n      maxDuration\n    )\n\n  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    const lastChangeTime = timeStampNow()\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(\n        monitor(() => complete({ hadActivity: true, end: lastChangeTime })),\n        PAGE_ACTIVITY_END_DELAY\n      )\n    }\n  })\n\n  const stop = () => {\n    hasCompleted = true\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    clearTimeout(maxDurationTimeoutId)\n    pageActivitySubscription.unsubscribe()\n  }\n\n  function complete(event: PageActivityEndEvent) {\n    if (hasCompleted) {\n      return\n    }\n    stop()\n    pageActivityEndCallback(event)\n  }\n  return { stop }\n}\n\nexport function createPageActivityObservable(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n): Observable<PageActivityEvent> {\n  const observable = new Observable<PageActivityEvent>(() => {\n    const subscriptions: Subscription[] = []\n    let firstRequestIndex: undefined | number\n    let pendingRequestsCount = 0\n\n    subscriptions.push(\n      domMutationObservable.subscribe(notifyPageActivity),\n      lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n        if (entries.some((entry) => entry.entryType === 'resource' && !isExcludedUrl(configuration, entry.name))) {\n          notifyPageActivity()\n        }\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, (startEvent) => {\n        if (isExcludedUrl(configuration, startEvent.url)) {\n          return\n        }\n        if (firstRequestIndex === undefined) {\n          firstRequestIndex = startEvent.requestIndex\n        }\n        pendingRequestsCount += 1\n        notifyPageActivity()\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request) => {\n        if (\n          isExcludedUrl(configuration, request.url) ||\n          firstRequestIndex === undefined ||\n          // If the request started before the tracking start, ignore it\n          request.requestIndex < firstRequestIndex\n        ) {\n          return\n        }\n        pendingRequestsCount -= 1\n        notifyPageActivity()\n      })\n    )\n\n    const { stop: stopTrackingWindowOpen } = trackWindowOpen(notifyPageActivity)\n\n    return () => {\n      stopTrackingWindowOpen()\n      subscriptions.forEach((s) => s.unsubscribe())\n    }\n\n    function notifyPageActivity() {\n      observable.notify({ isBusy: pendingRequestsCount > 0 })\n    }\n  })\n\n  return observable\n}\n\nfunction isExcludedUrl(configuration: RumConfiguration, requestUrl: string): boolean {\n  return matchList(configuration.excludedActivityUrls, requestUrl)\n}\n\nfunction trackWindowOpen(callback: () => void) {\n  return instrumentMethodAndCallOriginal(window, 'open', { before: callback })\n}\n","import { monitor, ONE_SECOND } from '@datadog/browser-core'\nimport type { Click } from './trackClickActions'\n\nexport interface ClickChain {\n  tryAppend: (click: Click) => boolean\n  stop: () => void\n}\n\nexport const MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND\nexport const MAX_DISTANCE_BETWEEN_CLICKS = 100\n\nconst enum ClickChainStatus {\n  WaitingForMoreClicks,\n  WaitingForClicksToStop,\n  Finalized,\n}\n\nexport function createClickChain(firstClick: Click, onFinalize: (clicks: Click[]) => void): ClickChain {\n  const bufferedClicks: Click[] = []\n  let status = ClickChainStatus.WaitingForMoreClicks\n  let maxDurationBetweenClicksTimeout: number | undefined\n  appendClick(firstClick)\n\n  function appendClick(click: Click) {\n    click.stopObservable.subscribe(tryFinalize)\n    bufferedClicks.push(click)\n    clearTimeout(maxDurationBetweenClicksTimeout)\n    maxDurationBetweenClicksTimeout = setTimeout(monitor(dontAcceptMoreClick), MAX_DURATION_BETWEEN_CLICKS)\n  }\n\n  function tryFinalize() {\n    if (status === ClickChainStatus.WaitingForClicksToStop && bufferedClicks.every((click) => click.isStopped())) {\n      status = ClickChainStatus.Finalized\n      onFinalize(bufferedClicks)\n    }\n  }\n\n  function dontAcceptMoreClick() {\n    clearTimeout(maxDurationBetweenClicksTimeout)\n    if (status === ClickChainStatus.WaitingForMoreClicks) {\n      status = ClickChainStatus.WaitingForClicksToStop\n      tryFinalize()\n    }\n  }\n\n  return {\n    tryAppend: (click) => {\n      if (status !== ClickChainStatus.WaitingForMoreClicks) {\n        return false\n      }\n\n      if (\n        bufferedClicks.length > 0 &&\n        !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)\n      ) {\n        dontAcceptMoreClick()\n        return false\n      }\n\n      appendClick(click)\n      return true\n    },\n    stop: () => {\n      dontAcceptMoreClick()\n    },\n  }\n}\n\n/**\n * Checks whether two events are similar by comparing their target, position and timestamp\n */\nfunction areEventsSimilar(first: MouseEvent, second: MouseEvent) {\n  return (\n    first.target === second.target &&\n    mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS &&\n    first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS\n  )\n}\n\nfunction mouseEventDistance(origin: MouseEvent, other: MouseEvent) {\n  return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2))\n}\n","import { safeTruncate, isIE, find } from '@datadog/browser-core'\n\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport const DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name'\n\nexport function getActionNameFromElement(element: Element, userProgrammaticAttribute?: string): string {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  return (\n    getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n    (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute)) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies) ||\n    ''\n  )\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement: Element, programmaticAttribute: string) {\n  let elementWithAttribute\n  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`)\n  } else {\n    let element: Element | null = targetElement\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element\n        break\n      }\n      element = element.parentElement\n    }\n  }\n\n  if (!elementWithAttribute) {\n    return\n  }\n  const name = elementWithAttribute.getAttribute(programmaticAttribute)!\n  return truncate(normalizeWhitespace(name.trim()))\n}\n\ntype NameStrategy = (\n  element: Element | HTMLElement | HTMLInputElement | HTMLSelectElement,\n  userProgrammaticAttribute: string | undefined\n) => string | undefined | null\n\nconst priorityStrategies: NameStrategy[] = [\n  // associated LABEL text\n  (element, userProgrammaticAttribute) => {\n    // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n    // instead\n    if (supportsLabelProperty()) {\n      if ('labels' in element && element.labels && element.labels.length > 0) {\n        return getTextualContent(element.labels[0], userProgrammaticAttribute)\n      }\n    } else if (element.id) {\n      const label =\n        element.ownerDocument &&\n        find(element.ownerDocument.querySelectorAll('label'), (label) => label.htmlFor === element.id)\n      return label && getTextualContent(label, userProgrammaticAttribute)\n    }\n  },\n  // INPUT button (and associated) value\n  (element) => {\n    if (element.nodeName === 'INPUT') {\n      const input = element as HTMLInputElement\n      const type = input.getAttribute('type')\n      if (type === 'button' || type === 'submit' || type === 'reset') {\n        return input.value\n      }\n    }\n  },\n  // BUTTON, LABEL or button-like element text\n  (element, userProgrammaticAttribute) => {\n    if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n      return getTextualContent(element, userProgrammaticAttribute)\n    }\n  },\n  (element) => element.getAttribute('aria-label'),\n  // associated element text designated by the aria-labelledby attribute\n  (element, userProgrammaticAttribute) => {\n    const labelledByAttribute = element.getAttribute('aria-labelledby')\n    if (labelledByAttribute) {\n      return labelledByAttribute\n        .split(/\\s+/)\n        .map((id) => getElementById(element, id))\n        .filter((label): label is HTMLElement => Boolean(label))\n        .map((element) => getTextualContent(element, userProgrammaticAttribute))\n        .join(' ')\n    }\n  },\n  (element) => element.getAttribute('alt'),\n  (element) => element.getAttribute('name'),\n  (element) => element.getAttribute('title'),\n  (element) => element.getAttribute('placeholder'),\n  // SELECT first OPTION text\n  (element, userProgrammaticAttribute) => {\n    if ('options' in element && element.options.length > 0) {\n      return getTextualContent(element.options[0], userProgrammaticAttribute)\n    }\n  },\n]\n\nconst fallbackStrategies: NameStrategy[] = [\n  (element, userProgrammaticAttribute) => getTextualContent(element, userProgrammaticAttribute),\n]\n\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nconst MAX_PARENTS_TO_CONSIDER = 10\nfunction getActionNameFromElementForStrategies(\n  targetElement: Element,\n  userProgrammaticAttribute: string | undefined,\n  strategies: NameStrategy[]\n) {\n  let element: Element | null = targetElement\n  let recursionCounter = 0\n  while (\n    recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n    element &&\n    element.nodeName !== 'BODY' &&\n    element.nodeName !== 'HTML' &&\n    element.nodeName !== 'HEAD'\n  ) {\n    for (const strategy of strategies) {\n      const name = strategy(element, userProgrammaticAttribute)\n      if (typeof name === 'string') {\n        const trimmedName = name.trim()\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName))\n        }\n      }\n    }\n    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n    if (element.nodeName === 'FORM') {\n      break\n    }\n    element = element.parentElement\n    recursionCounter += 1\n  }\n}\n\nfunction normalizeWhitespace(s: string) {\n  return s.replace(/\\s+/g, ' ')\n}\n\nfunction truncate(s: string) {\n  return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s\n}\n\nfunction getElementById(refElement: Element, id: string) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null\n}\n\nfunction getTextualContent(element: Element | HTMLElement, userProgrammaticAttribute: string | undefined) {\n  if ((element as HTMLElement).isContentEditable) {\n    return\n  }\n\n  if ('innerText' in element) {\n    let text = element.innerText\n\n    const removeTextFromElements = (query: string) => {\n      const list = element.querySelectorAll<Element | HTMLElement>(query)\n      for (let index = 0; index < list.length; index += 1) {\n        const element = list[index]\n        if ('innerText' in element) {\n          const textToReplace = element.innerText\n          if (textToReplace && textToReplace.trim().length > 0) {\n            text = text.replace(textToReplace, '')\n          }\n        }\n      }\n    }\n\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      removeTextFromElements('script, style')\n    }\n\n    // remove the text of elements with programmatic attribute value\n    removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`)\n\n    if (userProgrammaticAttribute) {\n      removeTextFromElements(`[${userProgrammaticAttribute}]`)\n    }\n\n    return text\n  }\n\n  return element.textContent\n}\n\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  return !isIE()\n}\n\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsLabelPropertyResult: boolean | undefined\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype\n  }\n  return supportsLabelPropertyResult\n}\n\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsElementClosestResult: boolean | undefined\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype\n  }\n  return supportsElementClosestResult\n}\n","export function isIE() {\n  return Boolean((document as any).documentMode)\n}\n\nexport function isChromium() {\n  return !!(window as any).chrome || /HeadlessChrome/.test(window.navigator.userAgent)\n}\n","import { cssEscape } from '@datadog/browser-core'\nimport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './getActionNameFromElement'\n\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport const STABLE_ATTRIBUTES = [\n  DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n  // Common test attributes (list provided by google recorder)\n  'data-testid',\n  'data-test',\n  'data-qa',\n  'data-cy',\n  'data-test-id',\n  'data-qa-id',\n  'data-testing',\n  // FullStory decorator attributes:\n  'data-component',\n  'data-element',\n  'data-source-file',\n]\n\nexport function getSelectorsFromElement(element: Element, actionNameAttribute: string | undefined) {\n  let attributeSelectors = getStableAttributeSelectors()\n  if (actionNameAttribute) {\n    attributeSelectors = [(element: Element) => getAttributeSelector(actionNameAttribute, element)].concat(\n      attributeSelectors\n    )\n  }\n  const globallyUniqueSelectorStrategies = attributeSelectors.concat(getIDSelector)\n  const uniqueAmongChildrenSelectorStrategies = attributeSelectors.concat([getClassSelector, getTagNameSelector])\n  return {\n    selector: getSelectorFromElement(element, globallyUniqueSelectorStrategies, uniqueAmongChildrenSelectorStrategies),\n    selector_combined: getSelectorFromElement(\n      element,\n      globallyUniqueSelectorStrategies,\n      uniqueAmongChildrenSelectorStrategies,\n      { useCombinedSelectors: true }\n    ),\n    selector_stopping_when_unique: getSelectorFromElement(\n      element,\n      globallyUniqueSelectorStrategies.concat([getClassSelector, getTagNameSelector]),\n      uniqueAmongChildrenSelectorStrategies\n    ),\n    selector_all_together: getSelectorFromElement(\n      element,\n      globallyUniqueSelectorStrategies.concat([getClassSelector, getTagNameSelector]),\n      uniqueAmongChildrenSelectorStrategies,\n      { useCombinedSelectors: true }\n    ),\n  }\n}\n\ntype GetSelector = (element: Element) => string | undefined\n\nfunction isGeneratedValue(value: string) {\n  // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n  // present.\n  //\n  // Here, we use the same strategy: if a the value contains a digit, we consider it generated. This\n  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n  // CSS selectors so it should be fine most of the time. We might want to allow customers to\n  // provide their own `isGeneratedValue` at some point.\n  return /[0-9]/.test(value)\n}\n\nfunction getSelectorFromElement(\n  targetElement: Element,\n  globallyUniqueSelectorStrategies: GetSelector[],\n  uniqueAmongChildrenSelectorStrategies: GetSelector[],\n  { useCombinedSelectors = false } = {}\n): string {\n  let targetElementSelector = ''\n  let element: Element | null = targetElement\n\n  while (element && element.nodeName !== 'HTML') {\n    const globallyUniqueSelector = findSelector(\n      element,\n      globallyUniqueSelectorStrategies,\n      isSelectorUniqueGlobally,\n      useCombinedSelectors ? targetElementSelector : undefined\n    )\n    if (globallyUniqueSelector) {\n      return combineSelector(globallyUniqueSelector, targetElementSelector)\n    }\n\n    const uniqueSelectorAmongChildren = findSelector(\n      element,\n      uniqueAmongChildrenSelectorStrategies,\n      isSelectorUniqueAmongSiblings,\n      useCombinedSelectors ? targetElementSelector : undefined\n    )\n    targetElementSelector = combineSelector(\n      uniqueSelectorAmongChildren || getPositionSelector(element) || getTagNameSelector(element),\n      targetElementSelector\n    )\n\n    element = element.parentElement\n  }\n\n  return targetElementSelector\n}\n\nfunction getIDSelector(element: Element): string | undefined {\n  if (element.id && !isGeneratedValue(element.id)) {\n    return `#${cssEscape(element.id)}`\n  }\n}\n\nfunction getClassSelector(element: Element): string | undefined {\n  if (element.tagName === 'BODY') {\n    return\n  }\n  if (element.classList.length > 0) {\n    for (let i = 0; i < element.classList.length; i += 1) {\n      const className = element.classList[i]\n      if (isGeneratedValue(className)) {\n        continue\n      }\n\n      return `${element.tagName}.${cssEscape(className)}`\n    }\n  }\n}\n\nfunction getTagNameSelector(element: Element): string {\n  return element.tagName\n}\n\nlet stableAttributeSelectorsCache: GetSelector[] | undefined\nfunction getStableAttributeSelectors() {\n  if (!stableAttributeSelectorsCache) {\n    stableAttributeSelectorsCache = STABLE_ATTRIBUTES.map(\n      (attribute) => (element: Element) => getAttributeSelector(attribute, element)\n    )\n  }\n  return stableAttributeSelectorsCache\n}\n\nfunction getAttributeSelector(attributeName: string, element: Element): string | undefined {\n  if (element.hasAttribute(attributeName)) {\n    return `${element.tagName}[${attributeName}=\"${cssEscape(element.getAttribute(attributeName)!)}\"]`\n  }\n}\n\nfunction getPositionSelector(element: Element): string | undefined {\n  const parent = element.parentElement!\n  let sibling = parent.firstElementChild\n  let currentIndex = 0\n  let elementIndex: number | undefined\n\n  while (sibling) {\n    if (sibling.tagName === element.tagName) {\n      currentIndex += 1\n      if (sibling === element) {\n        elementIndex = currentIndex\n      }\n\n      if (elementIndex !== undefined && currentIndex > 1) {\n        // Performance improvement: avoid iterating over all children, stop as soon as we are sure\n        // the element is not alone\n        break\n      }\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return currentIndex > 1 ? `${element.tagName}:nth-of-type(${elementIndex!})` : undefined\n}\n\nfunction findSelector(\n  element: Element,\n  selectorGetters: GetSelector[],\n  predicate: (element: Element, selector: string) => boolean,\n  childSelector?: string\n) {\n  for (const selectorGetter of selectorGetters) {\n    const elementSelector = selectorGetter(element)\n    const fullSelector = elementSelector && combineSelector(elementSelector, childSelector)\n    if (fullSelector && predicate(element, fullSelector)) {\n      return elementSelector\n    }\n  }\n}\n\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(element: Element, selector: string): boolean {\n  return element.ownerDocument.querySelectorAll(selector).length === 1\n}\n\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > SELECTOR\" returns a single element.\n *\n * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check\n * for any element matching the selector contained in the parent (in other words,\n * \"ELEMENT_PARENT SELECTOR\" returns a single element), regardless of whether the selector is a\n * direct descendent of the element parent. This should not impact results too much: if it\n * inaccurately returns false, we'll just fall back to another strategy.\n */\nfunction isSelectorUniqueAmongSiblings(element: Element, selector: string): boolean {\n  return (\n    element.parentElement!.querySelectorAll(supportScopeSelector() ? combineSelector(':scope', selector) : selector)\n      .length === 1\n  )\n}\n\nfunction combineSelector(parent: string, child: string | undefined): string {\n  return child ? `${parent}>${child}` : parent\n}\n\nlet supportScopeSelectorCache: boolean | undefined\nexport function supportScopeSelector() {\n  if (supportScopeSelectorCache === undefined) {\n    try {\n      document.querySelector(':scope')\n      supportScopeSelectorCache = true\n    } catch {\n      supportScopeSelectorCache = false\n    }\n  }\n  return supportScopeSelectorCache\n}\n","import { addEventListener, DOM_EVENT, monitor } from '@datadog/browser-core'\n\nexport type MouseEventOnElement = MouseEvent & { target: Element }\n\nexport type GetUserActivity = () => { selection: boolean; input: boolean }\nexport interface ActionEventsHooks<ClickContext> {\n  onPointerDown: (event: MouseEventOnElement) => ClickContext | undefined\n  onClick: (context: ClickContext, event: MouseEventOnElement, getUserActivity: GetUserActivity) => void\n}\n\nexport function listenActionEvents<ClickContext>({ onPointerDown, onClick }: ActionEventsHooks<ClickContext>) {\n  let hasSelectionChanged = false\n  let selectionEmptyAtPointerDown: boolean\n  let hasInputChanged = false\n  let clickContext: ClickContext | undefined\n\n  const listeners = [\n    addEventListener(\n      window,\n      DOM_EVENT.POINTER_DOWN,\n      (event) => {\n        hasSelectionChanged = false\n        selectionEmptyAtPointerDown = isSelectionEmpty()\n        if (isMouseEventOnElement(event)) {\n          clickContext = onPointerDown(event)\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.SELECTION_CHANGE,\n      () => {\n        if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {\n          hasSelectionChanged = true\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.CLICK,\n      (clickEvent: MouseEvent) => {\n        if (isMouseEventOnElement(clickEvent) && clickContext) {\n          // Use a scoped variable to make sure the value is not changed by other clicks\n          const userActivity = {\n            selection: hasSelectionChanged,\n            input: hasInputChanged,\n          }\n          if (!hasInputChanged) {\n            setTimeout(\n              monitor(() => {\n                userActivity.input = hasInputChanged\n              })\n            )\n          }\n\n          onClick(clickContext, clickEvent, () => userActivity)\n          clickContext = undefined\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.INPUT,\n      () => {\n        hasInputChanged = true\n      },\n      { capture: true }\n    ),\n  ]\n\n  return {\n    stop: () => {\n      listeners.forEach((listener) => listener.stop())\n    },\n  }\n}\n\nfunction isSelectionEmpty(): boolean {\n  const selection = window.getSelection()\n  return !selection || selection.isCollapsed\n}\n\nfunction isMouseEventOnElement(event: Event): event is MouseEventOnElement {\n  return event.target instanceof Element\n}\n","import { elementMatches, ONE_SECOND } from '@datadog/browser-core'\nimport { FrustrationType } from '../../../rawRumEvent.types'\nimport type { Click } from './trackClickActions'\n\nconst MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3\n\nexport function computeFrustration(clicks: Click[], rageClick: Click) {\n  if (isRage(clicks)) {\n    rageClick.addFrustration(FrustrationType.RAGE_CLICK)\n    if (clicks.some(isDead)) {\n      rageClick.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n    if (rageClick.hasError) {\n      rageClick.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    return { isRage: true }\n  }\n\n  const hasSelectionChanged = clicks.some((click) => click.getUserActivity().selection)\n  clicks.forEach((click) => {\n    if (click.hasError) {\n      click.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    if (\n      isDead(click) &&\n      // Avoid considering clicks part of a double-click or triple-click selections as dead clicks\n      !hasSelectionChanged\n    ) {\n      click.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n  })\n  return { isRage: false }\n}\n\nexport function isRage(clicks: Click[]) {\n  if (clicks.some((click) => click.getUserActivity().selection)) {\n    return false\n  }\n  for (let i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {\n    if (\n      clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <=\n      ONE_SECOND\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nconst DEAD_CLICK_EXCLUDE_SELECTOR =\n  // inputs that don't trigger a meaningful event like \"input\" when clicked, including textual\n  // inputs (using a negative selector is shorter here)\n  'input:not([type=\"checkbox\"]):not([type=\"radio\"]):not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]):not([type=\"range\"]),' +\n  'textarea,' +\n  'select,' +\n  // canvas, as there is no good way to detect activity occurring on them\n  'canvas,' +\n  // links that are interactive (have an href attribute) or any of their descendants, as they can\n  // open a new tab or navigate to a hash without triggering a meaningful event\n  'a[href],' +\n  'a[href] *'\n\nexport function isDead(click: Click) {\n  if (click.hasPageActivity || click.getUserActivity().input) {\n    return false\n  }\n  return !elementMatches(click.event.target, DEAD_CLICK_EXCLUDE_SELECTOR)\n}\n","import type { Duration, ClocksState, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  timeStampNow,\n  isExperimentalFeatureEnabled,\n  Observable,\n  assign,\n  getRelativeTime,\n  ONE_MINUTE,\n  ContextHistory,\n  generateUUID,\n  clocksNow,\n  ONE_SECOND,\n  elapsed,\n} from '@datadog/browser-core'\nimport type { FrustrationType } from '../../../rawRumEvent.types'\nimport { ActionType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { trackEventCounts } from '../../trackEventCounts'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\nimport type { ClickChain } from './clickChain'\nimport { createClickChain } from './clickChain'\nimport { getActionNameFromElement } from './getActionNameFromElement'\nimport { getSelectorsFromElement } from './getSelectorsFromElement'\nimport type { MouseEventOnElement, GetUserActivity } from './listenActionEvents'\nimport { listenActionEvents } from './listenActionEvents'\nimport { computeFrustration } from './computeFrustration'\n\ninterface ActionCounts {\n  errorCount: number\n  longTaskCount: number\n  resourceCount: number\n}\n\nexport interface ClickAction {\n  type: ActionType.CLICK\n  id: string\n  name: string\n  target?: {\n    selector: string\n    selector_with_stable_attributes?: string\n    width: number\n    height: number\n  }\n  position?: { x: number; y: number }\n  startClocks: ClocksState\n  duration?: Duration\n  counts: ActionCounts\n  event: MouseEventOnElement\n  frustrationTypes: FrustrationType[]\n  events: Event[]\n}\n\nexport interface ActionContexts {\n  findActionId: (startTime?: RelativeTime) => string | string[] | undefined\n}\n\ntype ClickActionIdHistory = ContextHistory<ClickAction['id']>\n\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE // arbitrary\n\nexport function trackClickActions(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  const history: ClickActionIdHistory = new ContextHistory(ACTION_CONTEXT_TIME_OUT_DELAY)\n  const stopObservable = new Observable<void>()\n  let currentClickChain: ClickChain | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    history.reset()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, stopClickChain)\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, stopClickChain)\n\n  const { stop: stopActionEventsListener } = listenActionEvents<ClickActionBase>({\n    onPointerDown: (pointerDownEvent) => processPointerDown(configuration, history, pointerDownEvent),\n    onClick: (clickActionBase, clickEvent, getUserActivity) =>\n      processClick(\n        configuration,\n        lifeCycle,\n        domMutationObservable,\n        history,\n        stopObservable,\n        appendClickToClickChain,\n        clickActionBase,\n        clickEvent,\n        getUserActivity\n      ),\n  })\n\n  const actionContexts: ActionContexts = {\n    findActionId: (startTime?: RelativeTime) =>\n      configuration.trackFrustrations ? history.findAll(startTime) : history.find(startTime),\n  }\n\n  return {\n    stop: () => {\n      stopClickChain()\n      stopObservable.notify()\n      stopActionEventsListener()\n    },\n    actionContexts,\n  }\n\n  function appendClickToClickChain(click: Click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      const rageClick = click.clone()\n      currentClickChain = createClickChain(click, (clicks) => {\n        finalizeClicks(clicks, rageClick)\n      })\n    }\n  }\n\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop()\n    }\n  }\n}\n\nfunction processPointerDown(\n  configuration: RumConfiguration,\n  history: ClickActionIdHistory,\n  pointerDownEvent: MouseEventOnElement\n) {\n  if (!configuration.trackFrustrations && history.find()) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any new\n    // action if another one is already occurring.\n    return\n  }\n\n  const clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute)\n  if (!configuration.trackFrustrations && !clickActionBase.name) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any action\n    // with a blank name\n    return\n  }\n\n  return clickActionBase\n}\n\nfunction processClick(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  stopObservable: Observable<void>,\n  appendClickToClickChain: (click: Click) => void,\n  clickActionBase: ClickActionBase,\n  clickEvent: MouseEventOnElement,\n  getUserActivity: GetUserActivity\n) {\n  const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, clickEvent)\n\n  if (configuration.trackFrustrations) {\n    appendClickToClickChain(click)\n  }\n\n  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n        // If the clock is looking weird, just discard the click\n        click.discard()\n      } else {\n        click.stop(pageActivityEndEvent.hadActivity ? pageActivityEndEvent.end : undefined)\n\n        // Validate or discard the click only if we don't track frustrations. It'll be done when\n        // the click chain is finalized.\n        if (!configuration.trackFrustrations) {\n          if (!pageActivityEndEvent.hadActivity) {\n            // If we are not tracking frustrations, we should discard the click to keep backward\n            // compatibility.\n            click.discard()\n          } else {\n            click.validate()\n          }\n        }\n      }\n    },\n    CLICK_ACTION_MAX_DURATION\n  )\n\n  const viewEndedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    click.stop(endClocks.timeStamp)\n  })\n\n  const stopSubscription = stopObservable.subscribe(() => {\n    click.stop()\n  })\n\n  click.stopObservable.subscribe(() => {\n    viewEndedSubscription.unsubscribe()\n    stopWaitPageActivityEnd()\n    stopSubscription.unsubscribe()\n  })\n}\n\ntype ClickActionBase = Pick<ClickAction, 'type' | 'name' | 'target' | 'position'>\n\nfunction computeClickActionBase(event: MouseEventOnElement, actionNameAttribute?: string): ClickActionBase {\n  let target: ClickAction['target']\n  let position: ClickAction['position']\n\n  if (isExperimentalFeatureEnabled('clickmap')) {\n    const rect = event.target.getBoundingClientRect()\n    target = assign(\n      {\n        width: Math.round(rect.width),\n        height: Math.round(rect.height),\n      },\n      getSelectorsFromElement(event.target, actionNameAttribute)\n    )\n    position = {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top),\n    }\n  }\n\n  return {\n    type: ActionType.CLICK,\n    target,\n    position,\n    name: getActionNameFromElement(event.target, actionNameAttribute),\n  }\n}\n\nconst enum ClickStatus {\n  // Initial state, the click is still ongoing.\n  ONGOING,\n  // The click is no more ongoing but still needs to be validated or discarded.\n  STOPPED,\n  // Final state, the click has been stopped and validated or discarded.\n  FINALIZED,\n}\n\nexport type Click = ReturnType<typeof newClick>\n\nfunction newClick(\n  lifeCycle: LifeCycle,\n  history: ClickActionIdHistory,\n  getUserActivity: GetUserActivity,\n  clickActionBase: ClickActionBase,\n  clickEvent: MouseEventOnElement\n) {\n  const id = generateUUID()\n  const startClocks = clocksNow()\n  const historyEntry = history.add(id, startClocks.relative)\n  const eventCountsSubscription = trackEventCounts(lifeCycle)\n  let status = ClickStatus.ONGOING\n  let activityEndTime: undefined | TimeStamp\n  const frustrationTypes: FrustrationType[] = []\n  const stopObservable = new Observable<void>()\n\n  function stop(newActivityEndTime?: TimeStamp) {\n    if (status !== ClickStatus.ONGOING) {\n      return\n    }\n    activityEndTime = newActivityEndTime\n    status = ClickStatus.STOPPED\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime))\n    } else {\n      historyEntry.remove()\n    }\n    eventCountsSubscription.stop()\n    stopObservable.notify()\n  }\n\n  return {\n    event: clickEvent,\n    stop,\n    stopObservable,\n\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined\n    },\n    getUserActivity,\n    addFrustration: (frustrationType: FrustrationType) => {\n      frustrationTypes.push(frustrationType)\n    },\n    startClocks,\n\n    isStopped: () => status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED,\n\n    clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, clickEvent),\n\n    validate: (domEvents?: Event[]) => {\n      stop()\n      if (status !== ClickStatus.STOPPED) {\n        return\n      }\n\n      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts\n      const clickAction: ClickAction = assign(\n        {\n          type: ActionType.CLICK as const,\n          duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n          startClocks,\n          id,\n          frustrationTypes,\n          counts: {\n            resourceCount,\n            errorCount,\n            longTaskCount,\n          },\n          events: domEvents ?? [clickEvent],\n          event: clickEvent,\n        },\n        clickActionBase\n      )\n      lifeCycle.notify(LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction)\n      status = ClickStatus.FINALIZED\n    },\n\n    discard: () => {\n      stop()\n      status = ClickStatus.FINALIZED\n    },\n  }\n}\n\nexport function finalizeClicks(clicks: Click[], rageClick: Click) {\n  const { isRage } = computeFrustration(clicks, rageClick)\n  if (isRage) {\n    clicks.forEach((click) => click.discard())\n    rageClick.stop(timeStampNow())\n    rageClick.validate(clicks.map((click) => click.event))\n  } else {\n    rageClick.discard()\n    clicks.forEach((click) => click.validate())\n  }\n}\n","import type { ClocksState, Context, Observable } from '@datadog/browser-core'\nimport { noop, assign, combine, toServerDuration, generateUUID } from '@datadog/browser-core'\n\nimport type { CommonContext, RawRumActionEvent } from '../../../rawRumEvent.types'\nimport { ActionType, RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { ForegroundContexts } from '../../contexts/foregroundContexts'\nimport type { RumConfiguration } from '../../configuration'\nimport type { ActionContexts, ClickAction } from './trackClickActions'\nimport { trackClickActions } from './trackClickActions'\n\nexport type { ActionContexts }\n\nexport interface CustomAction {\n  type: ActionType.CUSTOM\n  name: string\n  startClocks: ClocksState\n  context?: Context\n}\n\nexport type AutoAction = ClickAction\n\nexport function startActionCollection(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  foregroundContexts: ForegroundContexts\n) {\n  lifeCycle.subscribe(LifeCycleEventType.AUTO_ACTION_COMPLETED, (action) =>\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processAction(action, foregroundContexts))\n  )\n\n  let actionContexts: ActionContexts = { findActionId: noop as () => undefined }\n  if (configuration.trackInteractions) {\n    actionContexts = trackClickActions(lifeCycle, domMutationObservable, configuration).actionContexts\n  }\n\n  return {\n    addAction: (action: CustomAction, savedCommonContext?: CommonContext) => {\n      lifeCycle.notify(\n        LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n        assign(\n          {\n            savedCommonContext,\n          },\n          processAction(action, foregroundContexts)\n        )\n      )\n    },\n    actionContexts,\n  }\n}\n\nfunction processAction(\n  action: AutoAction | CustomAction,\n  foregroundContexts: ForegroundContexts\n): RawRumEventCollectedData<RawRumActionEvent> {\n  const autoActionProperties = isAutoAction(action)\n    ? {\n        action: {\n          id: action.id,\n          loading_time: toServerDuration(action.duration),\n          frustration: {\n            type: action.frustrationTypes,\n          },\n          error: {\n            count: action.counts.errorCount,\n          },\n          long_task: {\n            count: action.counts.longTaskCount,\n          },\n          resource: {\n            count: action.counts.resourceCount,\n          },\n        },\n        _dd: {\n          action: {\n            target: action.target,\n            position: action.position,\n          },\n        },\n      }\n    : undefined\n  const customerContext = !isAutoAction(action) ? action.context : undefined\n  const actionEvent: RawRumActionEvent = combine(\n    {\n      action: {\n        id: generateUUID(),\n        target: {\n          name: action.name,\n        },\n        type: action.type,\n      },\n      date: action.startClocks.timeStamp,\n      type: RumEventType.ACTION as const,\n    },\n    autoActionProperties\n  )\n  const inForeground = foregroundContexts.isInForegroundAt(action.startClocks.relative)\n  if (inForeground !== undefined) {\n    actionEvent.view = { in_foreground: inForeground }\n  }\n  return {\n    customerContext,\n    rawRumEvent: actionEvent,\n    startTime: action.startClocks.relative,\n    domainContext: isAutoAction(action) ? { event: action.event, events: action.events } : {},\n  }\n}\n\nfunction isAutoAction(action: AutoAction | CustomAction): action is AutoAction {\n  return action.type !== ActionType.CUSTOM\n}\n","import { instrumentMethodAndCallOriginal } from '../../tools/instrumentMethod'\nimport { computeStackTrace } from './computeStackTrace'\nimport type { UnhandledErrorCallback, StackTrace } from './types'\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/\n\n/**\n * Cross-browser collection of unhandled errors\n *\n * Supports:\n * - Firefox: full stack trace with line numbers, plus column number\n * on top frame; column number is not guaranteed\n * - Opera: full stack trace with line and column numbers\n * - Chrome: full stack trace with line and column numbers\n * - Safari: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n * - IE: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n * - IE5.5+ (only 8.0 tested)\n * - Firefox 0.9+ (only 3.5+ tested)\n * - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n * Exceptions Have Stacktrace to be enabled in opera:config)\n * - Safari 3+ (only 4+ tested)\n * - Chrome 1+ (only 5+ tested)\n * - Konqueror 3.5+ (untested)\n *\n * Tries to catch all unhandled errors and report them to the\n * callback.\n *\n * Callbacks receive a StackTrace object as described in the\n * computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\n\nexport function startUnhandledErrorCollection(callback: UnhandledErrorCallback) {\n  const { stop: stopInstrumentingOnError } = instrumentOnError(callback)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(callback)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\n/**\n * Install a global onerror handler\n */\nfunction instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onerror', {\n    before(this: any, message: Event | string, url?: string, lineNo?: number, columnNo?: number, errorObj?: Error) {\n      let stack: StackTrace\n\n      if (errorObj) {\n        stack = computeStackTrace(errorObj)\n        callback(stack, errorObj)\n      } else {\n        const location = {\n          url,\n          column: columnNo,\n          line: lineNo,\n        }\n\n        let name\n        let msg = message\n        if ({}.toString.call(message) === '[object String]') {\n          const groups = ERROR_TYPES_RE.exec(msg as string)\n          if (groups) {\n            name = groups[1]\n            msg = groups[2]\n          }\n        }\n\n        stack = {\n          name,\n          message: typeof msg === 'string' ? msg : undefined,\n          stack: [location],\n        }\n\n        callback(stack, message)\n      }\n    },\n  })\n}\n\n/**\n * Install a global onunhandledrejection handler\n */\nfunction instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onunhandledrejection', {\n    before(e: PromiseRejectionEvent) {\n      const reason = e.reason || 'Empty reason'\n      const stack = computeStackTrace(reason)\n      callback(stack, reason)\n    },\n  })\n}\n","import { computeStackTrace } from '../tracekit'\nimport { createHandlingStack, formatErrorMessage, toStackTraceString } from '../../tools/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { find, jsonStringify } from '../../tools/utils'\nimport { ConsoleApiName } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\n\nexport interface ConsoleLog {\n  message: string\n  api: ConsoleApiName\n  stack?: string\n  handlingStack?: string\n}\n\nconst consoleObservablesByApi: { [k in ConsoleApiName]?: Observable<ConsoleLog> } = {}\n\nexport function initConsoleObservable(apis: ConsoleApiName[]) {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api)\n    }\n    return consoleObservablesByApi[api]!\n  })\n\n  return mergeObservables<ConsoleLog>(...consoleObservables)\n}\n\n/* eslint-disable no-console */\nfunction createConsoleObservable(api: ConsoleApiName) {\n  const observable = new Observable<ConsoleLog>(() => {\n    const originalConsoleApi = console[api]\n\n    console[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      console[api] = originalConsoleApi\n    }\n  })\n\n  return observable\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  // Todo: remove console error prefix in the next major version\n  let message = params.map((param) => formatConsoleParameters(param)).join(' ')\n  let stack\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = find(params, (param: unknown): param is Error => param instanceof Error)\n    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n    message = `console error: ${message}`\n  }\n\n  return {\n    api,\n    message,\n    stack,\n    handlingStack,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return param\n  }\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(param, 2)\n}\n","import { toStackTraceString } from '../../tools/error'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { DOM_EVENT, includes, addEventListener, safeTruncate } from '../../tools/utils'\nimport type { Report, BrowserWindow, ReportType } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = typeof RawReportType[keyof typeof RawReportType]\n\nexport interface RawReport {\n  type: RawReportType\n  subtype: string\n  message: string\n  stack?: string\n}\n\nexport function initReportObservable(apis: RawReportType[]) {\n  const observables: Array<Observable<RawReport>> = []\n\n  if (includes(apis, RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable())\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables<RawReport>(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  const observable = new Observable<RawReport>(() => {\n    if (!(window as BrowserWindow).ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Report[]) =>\n      reports.forEach((report) => {\n        observable.notify(buildRawReportFromReport(report))\n      })\n    )\n\n    const observer = new (window as BrowserWindow).ReportingObserver!(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n\n  return observable\n}\n\nfunction createCspViolationReportObservable() {\n  const observable = new Observable<RawReport>(() => {\n    const handleCspViolation = monitor((event: SecurityPolicyViolationEvent) => {\n      observable.notify(buildRawReportFromCspViolation(event))\n    })\n\n    const { stop } = addEventListener(document, DOM_EVENT.SECURITY_POLICY_VIOLATION, handleCspViolation)\n\n    return stop\n  })\n  return observable\n}\n\nfunction buildRawReportFromReport({ type, body }: Report): RawReport {\n  return {\n    type,\n    subtype: body.id,\n    message: `${type}: ${body.message}`,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  }\n}\n\nfunction buildRawReportFromCspViolation(event: SecurityPolicyViolationEvent): RawReport {\n  const type = RawReportType.cspViolation\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return {\n    type: RawReportType.cspViolation,\n    subtype: event.effectiveDirective,\n    message: `${type}: ${message}`,\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | undefined,\n  lineNumber: number | undefined,\n  columnNumber: number | undefined\n): string | undefined {\n  return (\n    sourceFile &&\n    toStackTraceString({\n      name,\n      message,\n      stack: [\n        {\n          func: '?',\n          url: sourceFile,\n          line: lineNumber,\n          column: columnNumber,\n        },\n      ],\n    })\n  )\n}\n","import type { EventEmitter, RelativeTime } from '@datadog/browser-core'\nimport { addEventListeners, DOM_EVENT } from '@datadog/browser-core'\n\nlet trackFirstHiddenSingleton: { timeStamp: RelativeTime } | undefined\nlet stopListeners: (() => void) | undefined\n\nexport function trackFirstHidden(emitter: EventEmitter = window) {\n  if (!trackFirstHiddenSingleton) {\n    if (document.visibilityState === 'hidden') {\n      trackFirstHiddenSingleton = {\n        timeStamp: 0 as RelativeTime,\n      }\n    } else {\n      trackFirstHiddenSingleton = {\n        timeStamp: Infinity as RelativeTime,\n      }\n      ;({ stop: stopListeners } = addEventListeners(\n        emitter,\n        [DOM_EVENT.PAGE_HIDE, DOM_EVENT.VISIBILITY_CHANGE],\n        (event) => {\n          if (event.type === 'pagehide' || document.visibilityState === 'hidden') {\n            trackFirstHiddenSingleton!.timeStamp = event.timeStamp as RelativeTime\n            stopListeners!()\n          }\n        },\n        { capture: true }\n      ))\n    }\n  }\n\n  return trackFirstHiddenSingleton\n}\n\nexport function resetFirstHidden() {\n  if (stopListeners) {\n    stopListeners()\n  }\n  trackFirstHiddenSingleton = undefined\n}\n","import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport {\n  assign,\n  ErrorSource,\n  generateUUID,\n  computeRawError,\n  ErrorHandling,\n  computeStackTrace,\n  Observable,\n  trackRuntimeError,\n} from '@datadog/browser-core'\nimport type { CommonContext, RawRumErrorEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { ForegroundContexts } from '../../contexts/foregroundContexts'\nimport { trackConsoleError } from './trackConsoleError'\nimport { trackReportError } from './trackReportError'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startErrorCollection(lifeCycle: LifeCycle, foregroundContexts: ForegroundContexts) {\n  const errorObservable = new Observable<RawError>()\n\n  trackConsoleError(errorObservable)\n  trackRuntimeError(errorObservable)\n  trackReportError(errorObservable)\n\n  errorObservable.subscribe((error) => lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error }))\n\n  return doStartErrorCollection(lifeCycle, foregroundContexts)\n}\n\nexport function doStartErrorCollection(lifeCycle: LifeCycle, foregroundContexts: ForegroundContexts) {\n  lifeCycle.subscribe(LifeCycleEventType.RAW_ERROR_COLLECTED, ({ error, customerContext, savedCommonContext }) => {\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      assign(\n        {\n          customerContext,\n          savedCommonContext,\n        },\n        processError(error, foregroundContexts)\n      )\n    )\n  })\n\n  return {\n    addError: (\n      { error, handlingStack, startClocks, context: customerContext }: ProvidedError,\n      savedCommonContext?: CommonContext\n    ) => {\n      const stackTrace = error instanceof Error ? computeStackTrace(error) : undefined\n      const rawError = computeRawError({\n        stackTrace,\n        originalError: error,\n        handlingStack,\n        startClocks,\n        nonErrorPrefix: 'Provided',\n        source: ErrorSource.CUSTOM,\n        handling: ErrorHandling.HANDLED,\n      })\n\n      lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, {\n        customerContext,\n        savedCommonContext,\n        error: rawError,\n      })\n    },\n  }\n}\n\nfunction processError(\n  error: RawError,\n  foregroundContexts: ForegroundContexts\n): RawRumEventCollectedData<RawRumErrorEvent> {\n  const rawRumEvent: RawRumErrorEvent = {\n    date: error.startClocks.timeStamp,\n    error: {\n      id: generateUUID(),\n      message: error.message,\n      source: error.source,\n      stack: error.stack,\n      handling_stack: error.handlingStack,\n      type: error.type,\n      handling: error.handling,\n      causes: error.causes,\n      source_type: 'browser',\n    },\n    type: RumEventType.ERROR as const,\n  }\n  const inForeground = foregroundContexts.isInForegroundAt(error.startClocks.relative)\n  if (inForeground !== undefined) {\n    rawRumEvent.view = { in_foreground: inForeground }\n  }\n\n  return {\n    rawRumEvent,\n    startTime: error.startClocks.relative,\n    domainContext: {\n      error: error.originalError,\n    },\n  }\n}\n","import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, initConsoleObservable, ErrorSource, ConsoleApiName } from '@datadog/browser-core'\n\nexport function trackConsoleError(errorObservable: Observable<RawError>) {\n  const subscription = initConsoleObservable([ConsoleApiName.error]).subscribe((consoleError) =>\n    errorObservable.notify({\n      startClocks: clocksNow(),\n      message: consoleError.message,\n      stack: consoleError.stack,\n      source: ErrorSource.CONSOLE,\n      handling: ErrorHandling.HANDLED,\n      handlingStack: consoleError.handlingStack,\n    })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n","import type { RawError } from '../../tools/error'\nimport { ErrorSource, computeRawError, ErrorHandling } from '../../tools/error'\nimport type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/timeUtils'\nimport { startUnhandledErrorCollection } from '../tracekit'\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  return startUnhandledErrorCollection((stackTrace, originalError) => {\n    errorObservable.notify(\n      computeRawError({\n        stackTrace,\n        originalError,\n        startClocks: clocksNow(),\n        nonErrorPrefix: 'Uncaught',\n        source: ErrorSource.SOURCE,\n        handling: ErrorHandling.UNHANDLED,\n      })\n    )\n  })\n}\n","import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, ErrorSource, initReportObservable, RawReportType } from '@datadog/browser-core'\n\nexport function trackReportError(errorObservable: Observable<RawError>) {\n  const subscription = initReportObservable([RawReportType.cspViolation, RawReportType.intervention]).subscribe(\n    (reportError) =>\n      errorObservable.notify({\n        startClocks: clocksNow(),\n        message: reportError.message,\n        stack: reportError.stack,\n        type: reportError.subtype,\n        source: ErrorSource.REPORT,\n        handling: ErrorHandling.UNHANDLED,\n      })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n","import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { addDuration } from '@datadog/browser-core'\nimport type { RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\nimport type { RequestCompleteEvent } from '../../requestCollection'\nimport { toValidEntry } from './resourceUtils'\n\ninterface Timing {\n  startTime: RelativeTime\n  duration: Duration\n}\n\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n * - Browsers generate a timing entry for OPTIONS request\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - if a single timing match, return the timing\n * - if two following timings match (OPTIONS request), return the timing for the actual request\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request: RequestCompleteEvent) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return\n  }\n  const sameNameEntries = performance.getEntriesByName(request.url, 'resource')\n\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return\n  }\n\n  const candidates = sameNameEntries\n    .map((entry) => entry.toJSON() as RumPerformanceResourceTiming)\n    .filter(toValidEntry)\n    .filter((entry) =>\n      isBetween(\n        entry,\n        request.startClocks.relative,\n        endTime({ startTime: request.startClocks.relative, duration: request.duration })\n      )\n    )\n\n  if (candidates.length === 1) {\n    return candidates[0]\n  }\n\n  if (candidates.length === 2 && firstCanBeOptionRequest(candidates)) {\n    return candidates[1]\n  }\n\n  return\n}\n\nfunction firstCanBeOptionRequest(correspondingEntries: RumPerformanceResourceTiming[]) {\n  return endTime(correspondingEntries[0]) <= correspondingEntries[1].startTime\n}\n\nfunction endTime(timing: Timing) {\n  return addDuration(timing.startTime, timing.duration)\n}\n\nfunction isBetween(timing: Timing, start: RelativeTime, end: RelativeTime) {\n  const errorMargin = 1 as Duration\n  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin)\n}\n","import {\n  combine,\n  generateUUID,\n  RequestType,\n  ResourceType,\n  toServerDuration,\n  relativeToClocks,\n  assign,\n  isNumber,\n} from '@datadog/browser-core'\nimport type { ClocksState } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport type { RumPerformanceEntry, RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\nimport type {\n  PerformanceEntryRepresentation,\n  RumXhrResourceEventDomainContext,\n  RumFetchResourceEventDomainContext,\n} from '../../../domainContext.types'\nimport type { RawRumResourceEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RequestCompleteEvent } from '../../requestCollection'\nimport type { RumSessionManager } from '../../rumSessionManager'\nimport { matchRequestTiming } from './matchRequestTiming'\nimport {\n  computePerformanceResourceDetails,\n  computePerformanceResourceDuration,\n  computeResourceKind,\n  computeSize,\n  isRequestKind,\n} from './resourceUtils'\n\nexport function startResourceCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n) {\n  lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request: RequestCompleteEvent) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processRequest(request, configuration, sessionManager))\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'resource' && !isRequestKind(entry)) {\n        lifeCycle.notify(\n          LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n          processResourceEntry(entry, configuration, sessionManager)\n        )\n      }\n    }\n  })\n}\n\nfunction processRequest(\n  request: RequestCompleteEvent,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n): RawRumEventCollectedData<RawRumResourceEvent> {\n  const type = request.type === RequestType.XHR ? ResourceType.XHR : ResourceType.FETCH\n\n  const matchingTiming = matchRequestTiming(request)\n  const startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks\n  const correspondingTimingOverrides = matchingTiming ? computePerformanceEntryMetrics(matchingTiming) : undefined\n\n  const tracingInfo = computeRequestTracingInfo(request, configuration)\n  const indexingInfo = computeIndexingInfo(sessionManager, startClocks)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        duration: toServerDuration(request.duration),\n        method: request.method,\n        status_code: request.status,\n        url: request.url,\n      },\n      type: RumEventType.RESOURCE as const,\n    },\n    tracingInfo,\n    correspondingTimingOverrides,\n    indexingInfo\n  )\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: matchingTiming && toPerformanceEntryRepresentation(matchingTiming),\n      xhr: request.xhr,\n      response: request.response,\n      requestInput: request.input,\n      requestInit: request.init,\n      error: request.error,\n    } as RumFetchResourceEventDomainContext | RumXhrResourceEventDomainContext,\n  }\n}\n\nfunction processResourceEntry(\n  entry: RumPerformanceResourceTiming,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n): RawRumEventCollectedData<RawRumResourceEvent> {\n  const type = computeResourceKind(entry)\n  const entryMetrics = computePerformanceEntryMetrics(entry)\n  const startClocks = relativeToClocks(entry.startTime)\n\n  const tracingInfo = computeEntryTracingInfo(entry, configuration)\n  const indexingInfo = computeIndexingInfo(sessionManager, startClocks)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        url: entry.name,\n      },\n      type: RumEventType.RESOURCE as const,\n    },\n    tracingInfo,\n    entryMetrics,\n    indexingInfo\n  )\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: toPerformanceEntryRepresentation(entry),\n    },\n  }\n}\n\nfunction computePerformanceEntryMetrics(timing: RumPerformanceResourceTiming) {\n  return {\n    resource: assign(\n      {\n        duration: computePerformanceResourceDuration(timing),\n        size: computeSize(timing),\n      },\n      computePerformanceResourceDetails(timing)\n    ),\n  }\n}\n\nfunction computeRequestTracingInfo(request: RequestCompleteEvent, configuration: RumConfiguration) {\n  const hasBeenTraced = request.traceSampled && request.traceId && request.spanId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      span_id: request.spanId!.toDecimalString(),\n      trace_id: request.traceId!.toDecimalString(),\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\nfunction computeEntryTracingInfo(entry: RumPerformanceResourceTiming, configuration: RumConfiguration) {\n  const hasBeenTraced = entry.traceId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      trace_id: entry.traceId,\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\n// TODO next major: use directly PerformanceEntry type in domain context\nfunction toPerformanceEntryRepresentation(entry: RumPerformanceEntry): PerformanceEntryRepresentation {\n  return entry as PerformanceEntryRepresentation\n}\n\n/**\n * @returns number between 0 and 1 which represents tracing sample rate\n */\nfunction getRulePsr(configuration: RumConfiguration) {\n  return isNumber(configuration.tracingSampleRate) ? configuration.tracingSampleRate / 100 : undefined\n}\n\nfunction computeIndexingInfo(sessionManager: RumSessionManager, resourceStart: ClocksState) {\n  const session = sessionManager.findTrackedSession(resourceStart.relative)\n  return {\n    _dd: {\n      discarded: !session || !session.resourceAllowed,\n    },\n  }\n}\n","import type { Duration, EventEmitter, RelativeTime } from '@datadog/browser-core'\nimport {\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  elapsed,\n  ONE_MINUTE,\n  find,\n  findLast,\n  relativeNow,\n} from '@datadog/browser-core'\n\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type {\n  RumFirstInputTiming,\n  RumLargestContentfulPaintTiming,\n  RumPerformancePaintTiming,\n} from '../../../browser/performanceCollection'\nimport { trackFirstHidden } from './trackFirstHidden'\n\n// Discard LCP and FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const TIMING_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\nexport interface Timings {\n  firstContentfulPaint?: Duration\n  firstByte?: Duration\n  domInteractive?: Duration\n  domContentLoaded?: Duration\n  domComplete?: Duration\n  loadEvent?: Duration\n  largestContentfulPaint?: Duration\n  firstInputDelay?: Duration\n  firstInputTime?: Duration\n}\n\nexport function trackInitialViewTimings(lifeCycle: LifeCycle, callback: (timings: Timings) => void) {\n  const timings: Timings = {}\n  function setTimings(newTimings: Partial<Timings>) {\n    assign(timings, newTimings)\n    callback(timings)\n  }\n\n  const { stop: stopNavigationTracking } = trackNavigationTimings(lifeCycle, setTimings)\n  const { stop: stopFCPTracking } = trackFirstContentfulPaintTiming(lifeCycle, (firstContentfulPaint) =>\n    setTimings({ firstContentfulPaint })\n  )\n  const { stop: stopLCPTracking } = trackLargestContentfulPaintTiming(lifeCycle, window, (largestContentfulPaint) => {\n    setTimings({\n      largestContentfulPaint,\n    })\n  })\n  const { stop: stopFIDTracking } = trackFirstInputTimings(lifeCycle, ({ firstInputDelay, firstInputTime }) => {\n    setTimings({\n      firstInputDelay,\n      firstInputTime,\n    })\n  })\n\n  return {\n    stop: () => {\n      stopNavigationTracking()\n      stopFCPTracking()\n      stopLCPTracking()\n      stopFIDTracking()\n    },\n  }\n}\n\nexport function trackNavigationTimings(lifeCycle: LifeCycle, callback: (timings: Partial<Timings>) => void) {\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'navigation') {\n        callback({\n          domComplete: entry.domComplete,\n          domContentLoaded: entry.domContentLoadedEventEnd,\n          domInteractive: entry.domInteractive,\n          loadEvent: entry.loadEventEnd,\n          // In some cases the value reported is negative or is larger\n          // than the current page time. Ignore these cases:\n          // https://github.com/GoogleChrome/web-vitals/issues/137\n          // https://github.com/GoogleChrome/web-vitals/issues/162\n          firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n        })\n      }\n    }\n  })\n\n  return { stop }\n}\n\nexport function trackFirstContentfulPaintTiming(lifeCycle: LifeCycle, callback: (fcpTiming: RelativeTime) => void) {\n  const firstHidden = trackFirstHidden()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const fcpEntry = find(\n      entries,\n      (entry): entry is RumPerformancePaintTiming =>\n        entry.entryType === 'paint' &&\n        entry.name === 'first-contentful-paint' &&\n        entry.startTime < firstHidden.timeStamp &&\n        entry.startTime < TIMING_MAXIMUM_DELAY\n    )\n    if (fcpEntry) {\n      callback(fcpEntry.startTime)\n    }\n  })\n  return { stop }\n}\n\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts\n */\nexport function trackLargestContentfulPaintTiming(\n  lifeCycle: LifeCycle,\n  emitter: EventEmitter,\n  callback: (lcpTiming: RelativeTime) => void\n) {\n  const firstHidden = trackFirstHidden()\n\n  // Ignore entries that come after the first user interaction.  According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  let firstInteractionTimestamp = Infinity\n  const { stop: stopEventListener } = addEventListeners(\n    emitter,\n    [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN],\n    (event) => {\n      firstInteractionTimestamp = event.timeStamp\n    },\n    { capture: true, once: true }\n  )\n\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const lcpEntry = findLast(\n        entries,\n        (entry): entry is RumLargestContentfulPaintTiming =>\n          entry.entryType === 'largest-contentful-paint' &&\n          entry.startTime < firstInteractionTimestamp &&\n          entry.startTime < firstHidden.timeStamp &&\n          entry.startTime < TIMING_MAXIMUM_DELAY\n      )\n      if (lcpEntry) {\n        callback(lcpEntry.startTime)\n      }\n    }\n  )\n\n  return {\n    stop: () => {\n      stopEventListener()\n      unsubscribeLifeCycle()\n    },\n  }\n}\n\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInputTimings(\n  lifeCycle: LifeCycle,\n  callback: ({ firstInputDelay, firstInputTime }: { firstInputDelay: Duration; firstInputTime: Duration }) => void\n) {\n  const firstHidden = trackFirstHidden()\n\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const firstInputEntry = find(\n      entries,\n      (entry): entry is RumFirstInputTiming =>\n        entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp\n    )\n    if (firstInputEntry) {\n      const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart)\n      callback({\n        // Ensure firstInputDelay to be positive, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n        firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : (0 as Duration),\n        firstInputTime: firstInputEntry.startTime as Duration,\n      })\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n","import type { Duration, RelativeTime, Observable, ClocksState } from '@datadog/browser-core'\nimport { noop, round, ONE_SECOND, elapsed } from '@datadog/browser-core'\nimport type { RumLayoutShiftTiming } from '../../../browser/performanceCollection'\nimport { supportPerformanceTimingEvent } from '../../../browser/performanceCollection'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { EventCounts } from '../../trackEventCounts'\nimport { trackEventCounts } from '../../trackEventCounts'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\n\nexport interface ViewMetrics {\n  eventCounts: EventCounts\n  loadingTime?: Duration\n  cumulativeLayoutShift?: number\n}\n\nexport function trackViewMetrics(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  scheduleViewUpdate: () => void,\n  loadingType: ViewLoadingType,\n  viewStart: ClocksState\n) {\n  const viewMetrics: ViewMetrics = {\n    eventCounts: {\n      errorCount: 0,\n      longTaskCount: 0,\n      resourceCount: 0,\n      actionCount: 0,\n      frustrationCount: 0,\n    },\n  }\n  const { stop: stopEventCountsTracking } = trackEventCounts(lifeCycle, (newEventCounts) => {\n    viewMetrics.eventCounts = newEventCounts\n    scheduleViewUpdate()\n  })\n\n  const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    loadingType,\n    viewStart,\n    (newLoadingTime) => {\n      viewMetrics.loadingTime = newLoadingTime\n      scheduleViewUpdate()\n    }\n  )\n\n  let stopCLSTracking: () => void\n  if (isLayoutShiftSupported()) {\n    viewMetrics.cumulativeLayoutShift = 0\n    ;({ stop: stopCLSTracking } = trackCumulativeLayoutShift(lifeCycle, (cumulativeLayoutShift) => {\n      viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift\n      scheduleViewUpdate()\n    }))\n  } else {\n    stopCLSTracking = noop\n  }\n  return {\n    stop: () => {\n      stopEventCountsTracking()\n      stopLoadingTimeTracking()\n      stopCLSTracking()\n    },\n    setLoadEvent,\n    viewMetrics,\n  }\n}\n\nfunction trackLoadingTime(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  loadType: ViewLoadingType,\n  viewStart: ClocksState,\n  callback: (loadingTime: Duration) => void\n) {\n  let isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD\n  let isWaitingForActivityLoadingTime = true\n  const loadingTimeCandidates: Duration[] = []\n\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      callback(Math.max(...loadingTimeCandidates) as Duration)\n    }\n  }\n\n  const { stop } = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, (event) => {\n    if (isWaitingForActivityLoadingTime) {\n      isWaitingForActivityLoadingTime = false\n      if (event.hadActivity) {\n        loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end))\n      }\n      invokeCallbackIfAllCandidatesAreReceived()\n    }\n  })\n\n  return {\n    stop,\n    setLoadEvent: (loadEvent: Duration) => {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false\n        loadingTimeCandidates.push(loadEvent)\n        invokeCallbackIfAllCandidatesAreReceived()\n      }\n    },\n  }\n}\n\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nfunction trackCumulativeLayoutShift(lifeCycle: LifeCycle, callback: (layoutShift: number) => void) {\n  let maxClsValue = 0\n  const window = slidingSessionWindow()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n        window.update(entry)\n        if (window.value() > maxClsValue) {\n          maxClsValue = window.value()\n          callback(round(maxClsValue, 4))\n        }\n      }\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n\nfunction slidingSessionWindow() {\n  let value = 0\n  let startTime: RelativeTime\n  let endTime: RelativeTime\n  return {\n    update: (entry: RumLayoutShiftTiming) => {\n      const shouldCreateNewWindow =\n        startTime === undefined ||\n        entry.startTime - endTime >= ONE_SECOND ||\n        entry.startTime - startTime >= 5 * ONE_SECOND\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime\n        value = entry.value\n      } else {\n        value += entry.value\n        endTime = entry.startTime\n      }\n    },\n    value: () => value,\n  }\n}\n\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nfunction isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent('layout-shift')\n}\n","import type { Duration, ClocksState, TimeStamp, Observable, Subscription, RelativeTime } from '@datadog/browser-core'\nimport {\n  shallowClone,\n  assign,\n  elapsed,\n  generateUUID,\n  monitor,\n  ONE_MINUTE,\n  throttle,\n  clocksNow,\n  clocksOrigin,\n  timeStampNow,\n  display,\n  looksLikeRelativeTime,\n} from '@datadog/browser-core'\n\nimport type { ViewCustomTimings } from '../../../rawRumEvent.types'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\n\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { EventCounts } from '../../trackEventCounts'\nimport type { LocationChange } from '../../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { Timings } from './trackInitialViewTimings'\nimport { trackInitialViewTimings } from './trackInitialViewTimings'\nimport { trackViewMetrics } from './trackViewMetrics'\n\nexport interface ViewEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  location: Readonly<Location>\n  timings: Timings\n  customTimings: ViewCustomTimings\n  eventCounts: EventCounts\n  documentVersion: number\n  startClocks: ClocksState\n  duration: Duration\n  isActive: boolean\n  loadingTime?: Duration\n  loadingType: ViewLoadingType\n  cumulativeLayoutShift?: number\n}\n\nexport interface ViewCreatedEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  startClocks: ClocksState\n}\n\nexport interface ViewEndedEvent {\n  endClocks: ClocksState\n}\n\nexport const THROTTLE_VIEW_UPDATE_PERIOD = 3000\nexport const SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE\n\nexport interface ViewOptions {\n  name?: string\n  service?: string\n  version?: string\n}\n\nexport function trackViews(\n  location: Location,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  locationChangeObservable: Observable<LocationChange>,\n  areViewsTrackedAutomatically: boolean,\n  initialViewOptions?: ViewOptions\n) {\n  const { stop: stopInitialViewTracking, initialView } = trackInitialView(initialViewOptions)\n  let currentView = initialView\n\n  const { stop: stopViewLifeCycle } = startViewLifeCycle()\n\n  let locationChangeSubscription: Subscription\n  if (areViewsTrackedAutomatically) {\n    locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable)\n  }\n\n  function trackInitialView(options?: ViewOptions) {\n    const initialView = newView(\n      lifeCycle,\n      domMutationObservable,\n      configuration,\n      location,\n      ViewLoadingType.INITIAL_LOAD,\n      clocksOrigin(),\n      options\n    )\n    const { stop } = trackInitialViewTimings(lifeCycle, (timings) => {\n      initialView.updateTimings(timings)\n      initialView.scheduleUpdate()\n    })\n    return { initialView, stop }\n  }\n\n  function trackViewChange(startClocks?: ClocksState, viewOptions?: ViewOptions) {\n    return newView(\n      lifeCycle,\n      domMutationObservable,\n      configuration,\n      location,\n      ViewLoadingType.ROUTE_CHANGE,\n      startClocks,\n      viewOptions\n    )\n  }\n\n  function startViewLifeCycle() {\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n      // do not trigger view update to avoid wrong data\n      currentView.end()\n      // Renew view on session renewal\n      currentView = trackViewChange(undefined, {\n        name: currentView.name,\n        service: currentView.service,\n        version: currentView.version,\n      })\n    })\n\n    // End the current view on page unload\n    lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, () => {\n      currentView.end()\n      currentView.triggerUpdate()\n    })\n\n    // Session keep alive\n    const keepAliveInterval = window.setInterval(\n      monitor(() => {\n        currentView.triggerUpdate()\n      }),\n      SESSION_KEEP_ALIVE_INTERVAL\n    )\n\n    return {\n      stop: () => {\n        clearInterval(keepAliveInterval)\n      },\n    }\n  }\n\n  function renewViewOnLocationChange(locationChangeObservable: Observable<LocationChange>) {\n    return locationChangeObservable.subscribe(({ oldLocation, newLocation }) => {\n      if (areDifferentLocation(oldLocation, newLocation)) {\n        currentView.end()\n        currentView.triggerUpdate()\n        currentView = trackViewChange()\n        return\n      }\n    })\n  }\n\n  return {\n    addTiming: (name: string, time: RelativeTime | TimeStamp = timeStampNow()) => {\n      currentView.addTiming(name, time)\n      currentView.scheduleUpdate()\n    },\n    startView: (options?: ViewOptions, startClocks?: ClocksState) => {\n      currentView.end(startClocks)\n      currentView.triggerUpdate()\n      currentView = trackViewChange(startClocks, options)\n    },\n    stop: () => {\n      locationChangeSubscription?.unsubscribe()\n      stopInitialViewTracking()\n      stopViewLifeCycle()\n      currentView.end()\n    },\n  }\n}\n\nfunction newView(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  initialLocation: Location,\n  loadingType: ViewLoadingType,\n  startClocks: ClocksState = clocksNow(),\n  viewOptions?: ViewOptions\n) {\n  // Setup initial values\n  const id = generateUUID()\n  let timings: Timings = {}\n  const customTimings: ViewCustomTimings = {}\n  let documentVersion = 0\n  let endClocks: ClocksState | undefined\n  const location = shallowClone(initialLocation)\n\n  let name: string | undefined\n  let service: string | undefined\n  let version: string | undefined\n  if (viewOptions) {\n    name = viewOptions.name\n    service = viewOptions.service\n    version = viewOptions.version\n  }\n\n  lifeCycle.notify(LifeCycleEventType.VIEW_CREATED, { id, name, startClocks, service, version })\n\n  // Update the view every time the measures are changing\n  const { throttled: scheduleViewUpdate, cancel: cancelScheduleViewUpdate } = throttle(\n    monitor(triggerViewUpdate),\n    THROTTLE_VIEW_UPDATE_PERIOD,\n    {\n      leading: false,\n    }\n  )\n\n  const {\n    setLoadEvent,\n    stop: stopViewMetricsTracking,\n    viewMetrics,\n  } = trackViewMetrics(lifeCycle, domMutationObservable, configuration, scheduleViewUpdate, loadingType, startClocks)\n\n  // Initial view update\n  triggerViewUpdate()\n\n  function triggerViewUpdate() {\n    documentVersion += 1\n    const currentEnd = endClocks === undefined ? timeStampNow() : endClocks.timeStamp\n    lifeCycle.notify(\n      LifeCycleEventType.VIEW_UPDATED,\n      assign(\n        {\n          customTimings,\n          documentVersion,\n          id,\n          name,\n          service,\n          version,\n          loadingType,\n          location,\n          startClocks,\n          timings,\n          duration: elapsed(startClocks.timeStamp, currentEnd),\n          isActive: endClocks === undefined,\n        },\n        viewMetrics\n      )\n    )\n  }\n\n  return {\n    name,\n    service,\n    version,\n    scheduleUpdate: scheduleViewUpdate,\n    end(clocks = clocksNow()) {\n      endClocks = clocks\n      lifeCycle.notify(LifeCycleEventType.VIEW_ENDED, { endClocks })\n      stopViewMetricsTracking()\n    },\n    triggerUpdate() {\n      // cancel any pending view updates execution\n      cancelScheduleViewUpdate()\n      triggerViewUpdate()\n    },\n    updateTimings(newTimings: Timings) {\n      timings = newTimings\n      if (newTimings.loadEvent !== undefined) {\n        setLoadEvent(newTimings.loadEvent)\n      }\n    },\n    addTiming(name: string, time: RelativeTime | TimeStamp) {\n      const relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time)\n      customTimings[sanitizeTiming(name)] = relativeTime\n    },\n  }\n}\n\n/**\n * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $\n */\nfunction sanitizeTiming(name: string) {\n  const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_')\n  if (sanitized !== name) {\n    display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`)\n  }\n  return sanitized\n}\n\nfunction areDifferentLocation(currentLocation: Location, otherLocation: Location) {\n  return (\n    currentLocation.pathname !== otherLocation.pathname ||\n    (!isHashAnAnchor(otherLocation.hash) &&\n      getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash))\n  )\n}\n\nfunction isHashAnAnchor(hash: string) {\n  const correspondingId = hash.substr(1)\n  return !!document.getElementById(correspondingId)\n}\n\nfunction getPathFromHash(hash: string) {\n  const index = hash.indexOf('?')\n  return index < 0 ? hash : hash.slice(0, index)\n}\n","import type { Duration, ServerDuration, Observable } from '@datadog/browser-core'\nimport { isEmptyObject, mapValues, toServerDuration, isNumber } from '@datadog/browser-core'\nimport type { RecorderApi } from '../../../boot/rumPublicApi'\nimport type { RawRumViewEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { ForegroundContexts } from '../../contexts/foregroundContexts'\nimport type { LocationChange } from '../../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { ViewEvent, ViewOptions } from './trackViews'\nimport { trackViews } from './trackViews'\n\nexport function startViewCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  domMutationObservable: Observable<void>,\n  locationChangeObservable: Observable<LocationChange>,\n  foregroundContexts: ForegroundContexts,\n  recorderApi: RecorderApi,\n  initialViewOptions?: ViewOptions\n) {\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_UPDATED, (view) =>\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      processViewUpdate(view, foregroundContexts, recorderApi)\n    )\n  )\n\n  return trackViews(\n    location,\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    locationChangeObservable,\n    !configuration.trackViewsManually,\n    initialViewOptions\n  )\n}\n\nfunction processViewUpdate(\n  view: ViewEvent,\n  foregroundContexts: ForegroundContexts,\n  recorderApi: RecorderApi\n): RawRumEventCollectedData<RawRumViewEvent> {\n  const replayStats = recorderApi.getReplayStats(view.id)\n  const viewEvent: RawRumViewEvent = {\n    _dd: {\n      document_version: view.documentVersion,\n      replay_stats: replayStats,\n    },\n    date: view.startClocks.timeStamp,\n    type: RumEventType.VIEW,\n    view: {\n      action: {\n        count: view.eventCounts.actionCount,\n      },\n      frustration: {\n        count: view.eventCounts.frustrationCount,\n      },\n      cumulative_layout_shift: view.cumulativeLayoutShift,\n      first_byte: toServerDuration(view.timings.firstByte),\n      dom_complete: toServerDuration(view.timings.domComplete),\n      dom_content_loaded: toServerDuration(view.timings.domContentLoaded),\n      dom_interactive: toServerDuration(view.timings.domInteractive),\n      error: {\n        count: view.eventCounts.errorCount,\n      },\n      first_contentful_paint: toServerDuration(view.timings.firstContentfulPaint),\n      first_input_delay: toServerDuration(view.timings.firstInputDelay),\n      first_input_time: toServerDuration(view.timings.firstInputTime),\n      is_active: view.isActive,\n      name: view.name,\n      largest_contentful_paint: toServerDuration(view.timings.largestContentfulPaint),\n      load_event: toServerDuration(view.timings.loadEvent),\n      loading_time: discardNegativeDuration(toServerDuration(view.loadingTime)),\n      loading_type: view.loadingType,\n      long_task: {\n        count: view.eventCounts.longTaskCount,\n      },\n      resource: {\n        count: view.eventCounts.resourceCount,\n      },\n      time_spent: toServerDuration(view.duration),\n      in_foreground_periods: foregroundContexts.selectInForegroundPeriodsFor(view.startClocks.relative, view.duration),\n    },\n    session: {\n      has_replay: replayStats ? true : undefined,\n    },\n  }\n  if (!isEmptyObject(view.customTimings)) {\n    viewEvent.view.custom_timings = mapValues(\n      view.customTimings,\n      toServerDuration as (duration: Duration) => ServerDuration\n    )\n  }\n  return {\n    rawRumEvent: viewEvent,\n    startTime: view.startClocks.relative,\n    domainContext: {\n      location: view.location,\n    },\n  }\n}\n\nfunction discardNegativeDuration(duration: ServerDuration | undefined): ServerDuration | undefined {\n  return isNumber(duration) && duration < 0 ? undefined : duration\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport { getCookie, setCookie } from '../../browser/cookie'\nimport { isChromium } from '../../tools/browserDetection'\nimport { monitor } from '../../tools/monitor'\nimport { dateNow } from '../../tools/timeUtils'\nimport * as utils from '../../tools/utils'\nimport { SESSION_EXPIRATION_DELAY } from './sessionConstants'\nimport type { SessionState } from './sessionStore'\n\nconst SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport const SESSION_COOKIE_NAME = '_dd_s'\n\n// arbitrary values\nexport const LOCK_RETRY_DELAY = 10\nexport const MAX_NUMBER_OF_LOCK_RETRIES = 100\n\ntype Operations = {\n  options: CookieOptions\n  process: (cookieSession: SessionState) => SessionState | undefined\n  after?: (cookieSession: SessionState) => void\n}\n\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function withCookieLockAccess(operations: Operations, numberOfRetries = 0) {\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (numberOfRetries >= MAX_NUMBER_OF_LOCK_RETRIES) {\n    next()\n    return\n  }\n  let currentLock: string\n  let currentSession = retrieveSession()\n  if (isCookieLockEnabled()) {\n    // if someone has lock, retry later\n    if (currentSession.lock) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = utils.generateUUID()\n    currentSession.lock = currentLock\n    setSession(currentSession, operations.options)\n    // if lock is not acquired, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentSession)\n  if (isCookieLockEnabled()) {\n    // if lock corrupted after process, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock!) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    persistSession(processedSession, operations.options)\n  }\n  if (isCookieLockEnabled()) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentSession = retrieveSession()\n      if (currentSession.lock !== currentLock!) {\n        retryLater(operations, numberOfRetries)\n        return\n      }\n      delete currentSession.lock\n      setSession(currentSession, operations.options)\n      processedSession = currentSession\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date cookie value, the value could have been modified by another tab\n  operations.after?.(processedSession || currentSession)\n  next()\n}\n\n/**\n * Cookie lock strategy allows mitigating issues due to concurrent access to cookie.\n * This issue concerns only chromium browsers and enabling this on firefox increase cookie write failures.\n */\nfunction isCookieLockEnabled() {\n  return isChromium()\n}\n\nfunction retryLater(operations: Operations, currentNumberOfRetries: number) {\n  setTimeout(\n    monitor(() => {\n      withCookieLockAccess(operations, currentNumberOfRetries + 1)\n    }),\n    LOCK_RETRY_DELAY\n  )\n}\n\nfunction next() {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    withCookieLockAccess(nextOperations)\n  }\n}\n\nexport function persistSession(session: SessionState, options: CookieOptions) {\n  if (isExpiredState(session)) {\n    clearSession(options)\n    return\n  }\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n  setSession(session, options)\n}\n\nfunction setSession(session: SessionState, options: CookieOptions) {\n  setCookie(SESSION_COOKIE_NAME, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n}\n\nexport function toSessionString(session: SessionState) {\n  return utils\n    .objectEntries(session)\n    .map(([key, value]) => `${key}=${value as string}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function retrieveSession(): SessionState {\n  const sessionString = getCookie(SESSION_COOKIE_NAME)\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined): sessionString is string {\n  return (\n    sessionString !== undefined &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n\nfunction isExpiredState(session: SessionState) {\n  return utils.isEmptyObject(session)\n}\n\nfunction clearSession(options: CookieOptions) {\n  setCookie(SESSION_COOKIE_NAME, '', 0, options)\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport { COOKIE_ACCESS_DELAY } from '../../browser/cookie'\nimport { monitor } from '../../tools/monitor'\nimport { Observable } from '../../tools/observable'\nimport { dateNow } from '../../tools/timeUtils'\nimport * as utils from '../../tools/utils'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { retrieveSession, withCookieLockAccess } from './sessionCookieStore'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  stop: () => void\n}\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  lock?: string\n\n  [key: string]: string | undefined\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  options: CookieOptions,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  const watchSessionTimeoutId = setInterval(monitor(watchSession), COOKIE_ACCESS_DELAY)\n  let sessionCache: SessionState = retrieveActiveSession()\n\n  function expandOrRenewSession() {\n    let isTracked: boolean\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => {\n        const synchronizedSession = synchronizeSession(cookieSession)\n        isTracked = expandOrRenewCookie(synchronizedSession)\n        return synchronizedSession\n      },\n      after: (cookieSession) => {\n        if (isTracked && !hasSessionInCache()) {\n          renewSession(cookieSession)\n        }\n        sessionCache = cookieSession\n      },\n    })\n  }\n\n  function expandSession() {\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => (hasSessionInCache() ? synchronizeSession(cookieSession) : undefined),\n    })\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session cookie\n   * - if the session is not active, clear the session cookie and expire the session cache\n   */\n  function watchSession() {\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => (!isActiveSession(cookieSession) ? {} : undefined),\n      after: synchronizeSession,\n    })\n  }\n\n  function synchronizeSession(cookieSession: SessionState) {\n    if (!isActiveSession(cookieSession)) {\n      cookieSession = {}\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(cookieSession)) {\n        expireSession()\n      } else {\n        sessionCache = cookieSession\n      }\n    }\n    return cookieSession\n  }\n\n  function expandOrRenewCookie(cookieSession: SessionState) {\n    const { trackingType, isTracked } = computeSessionState(cookieSession[productKey])\n    cookieSession[productKey] = trackingType\n    if (isTracked && !cookieSession.id) {\n      cookieSession.id = utils.generateUUID()\n      cookieSession.created = String(dateNow())\n    }\n    return isTracked\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(cookieSession: SessionState) {\n    return sessionCache.id !== cookieSession.id || sessionCache[productKey] !== cookieSession[productKey]\n  }\n\n  function expireSession() {\n    sessionCache = {}\n    expireObservable.notify()\n  }\n\n  function renewSession(cookieSession: SessionState) {\n    sessionCache = cookieSession\n    renewObservable.notify()\n  }\n\n  function retrieveActiveSession(): SessionState {\n    const session = retrieveSession()\n    if (isActiveSession(session)) {\n      return session\n    }\n    return {}\n  }\n\n  function isActiveSession(session: SessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return (\n      (session.created === undefined || dateNow() - Number(session.created) < SESSION_TIME_OUT_DELAY) &&\n      (session.expire === undefined || dateNow() < Number(session.expire))\n    )\n  }\n\n  return {\n    expandOrRenewSession: utils.throttle(monitor(expandOrRenewSession), COOKIE_ACCESS_DELAY).throttled,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n  }\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport type { Observable } from '../../tools/observable'\nimport * as utils from '../../tools/utils'\nimport type { Context } from '../../tools/context'\nimport { ContextHistory } from '../../tools/contextHistory'\nimport type { RelativeTime } from '../../tools/timeUtils'\nimport { relativeNow, clocksOrigin } from '../../tools/timeUtils'\nimport { monitor } from '../../tools/monitor'\nimport { tryOldCookiesMigration } from './oldCookiesMigration'\nimport { startSessionStore } from './sessionStore'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\n\nexport interface SessionManager<TrackingType extends string> {\n  findActiveSession: (startTime?: RelativeTime) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n}\n\nexport const VISIBILITY_CHECK_DELAY = utils.ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  options: CookieOptions,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionManager<TrackingType> {\n  tryOldCookiesMigration(options)\n  const sessionStore = startSessionStore(options, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ContextHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackActivity(() => sessionStore.expandOrRenewSession())\n  trackVisibility(() => sessionStore.expandSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n    }\n  }\n\n  return {\n    findActiveSession: (startTime) => sessionContextHistory.find(startTime),\n    renewObservable: sessionStore.renewObservable,\n    expireObservable: sessionStore.expireObservable,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(expandOrRenewSession: () => void) {\n  const { stop } = utils.addEventListeners(\n    window,\n    [utils.DOM_EVENT.CLICK, utils.DOM_EVENT.TOUCH_START, utils.DOM_EVENT.KEY_DOWN, utils.DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(expandSession: () => void) {\n  const expandSessionWhenVisible = monitor(() => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  })\n\n  const { stop } = utils.addEventListener(document, utils.DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport { getCookie } from '../../browser/cookie'\nimport type { SessionState } from './sessionStore'\nimport { SESSION_COOKIE_NAME, persistSession } from './sessionCookieStore'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(options: CookieOptions) {\n  const sessionString = getCookie(SESSION_COOKIE_NAME)\n  const oldSessionId = getCookie(OLD_SESSION_COOKIE_NAME)\n  const oldRumType = getCookie(OLD_RUM_COOKIE_NAME)\n  const oldLogsType = getCookie(OLD_LOGS_COOKIE_NAME)\n  if (!sessionString) {\n    const session: SessionState = {}\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n    persistSession(session, options)\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { performDraw, startSessionManager } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const RUM_SESSION_KEY = 'rum'\n\nexport interface RumSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => RumSession | undefined\n}\n\nexport type RumSession = {\n  id: string\n  plan: RumSessionPlan\n  sessionReplayAllowed: boolean\n  longTaskAllowed: boolean\n  resourceAllowed: boolean\n}\n\nexport const enum RumSessionPlan {\n  WITHOUT_SESSION_REPLAY = 1,\n  WITH_SESSION_REPLAY = 2,\n}\n\nexport const enum RumTrackingType {\n  NOT_TRACKED = '0',\n  // Note: the \"tracking type\" value (stored in the session cookie) does not match the \"session\n  // plan\" value (sent in RUM events). This is expected, and was done to keep retrocompatibility\n  // with active sessions when upgrading the SDK.\n  TRACKED_WITH_SESSION_REPLAY = '1',\n  TRACKED_WITHOUT_SESSION_REPLAY = '2',\n}\n\nexport function startRumSessionManager(configuration: RumConfiguration, lifeCycle: LifeCycle): RumSessionManager {\n  const sessionManager = startSessionManager(configuration.cookieOptions, RUM_SESSION_KEY, (rawTrackingType) =>\n    computeSessionState(configuration, rawTrackingType)\n  )\n\n  sessionManager.expireObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_EXPIRED)\n  })\n\n  sessionManager.renewObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_RENEWED)\n  })\n\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findActiveSession(startTime)\n      if (!session || !isTypeTracked(session.trackingType)) {\n        return\n      }\n      const plan =\n        session.trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n          ? RumSessionPlan.WITH_SESSION_REPLAY\n          : RumSessionPlan.WITHOUT_SESSION_REPLAY\n      return {\n        id: session.id,\n        plan,\n        sessionReplayAllowed: plan === RumSessionPlan.WITH_SESSION_REPLAY,\n        longTaskAllowed:\n          configuration.trackLongTasks !== undefined\n            ? configuration.trackLongTasks\n            : configuration.oldPlansBehavior && plan === RumSessionPlan.WITH_SESSION_REPLAY,\n        resourceAllowed:\n          configuration.trackResources !== undefined\n            ? configuration.trackResources\n            : configuration.oldPlansBehavior && plan === RumSessionPlan.WITH_SESSION_REPLAY,\n      }\n    },\n  }\n}\n\n/**\n * Start a tracked replay session stub\n */\nexport function startRumSessionManagerStub(): RumSessionManager {\n  const session: RumSession = {\n    id: '00000000-aaaa-0000-aaaa-000000000000',\n    plan: RumSessionPlan.WITHOUT_SESSION_REPLAY, // plan value should not be taken into account for mobile\n    sessionReplayAllowed: false,\n    longTaskAllowed: true,\n    resourceAllowed: true,\n  }\n  return {\n    findTrackedSession: () => session,\n  }\n}\n\nfunction computeSessionState(configuration: RumConfiguration, rawTrackingType?: string) {\n  let trackingType: RumTrackingType\n  if (hasValidRumSession(rawTrackingType)) {\n    trackingType = rawTrackingType\n  } else if (!performDraw(configuration.sampleRate)) {\n    trackingType = RumTrackingType.NOT_TRACKED\n  } else if (!performDraw(configuration.sessionReplaySampleRate)) {\n    trackingType = RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  } else {\n    trackingType = RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  }\n  return {\n    trackingType,\n    isTracked: isTypeTracked(trackingType),\n  }\n}\n\nfunction hasValidRumSession(trackingType?: string): trackingType is RumTrackingType {\n  return (\n    trackingType === RumTrackingType.NOT_TRACKED ||\n    trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY ||\n    trackingType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  )\n}\n\nfunction isTypeTracked(rumSessionType: RumTrackingType | undefined) {\n  return (\n    rumSessionType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY ||\n    rumSessionType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  )\n}\n","import { display } from '../tools/display'\nimport type { Context } from '../tools/context'\nimport { addEventListener, DOM_EVENT, jsonStringify, noop, objectValues } from '../tools/utils'\nimport { monitor } from '../tools/monitor'\nimport type { HttpRequest } from './httpRequest'\n\n// https://en.wikipedia.org/wiki/UTF-8\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport class Batch {\n  private pushOnlyBuffer: string[] = []\n  private upsertBuffer: { [key: string]: string } = {}\n  private bufferBytesCount = 0\n  private bufferMessagesCount = 0\n\n  constructor(\n    private request: HttpRequest,\n    private batchMessagesLimit: number,\n    private batchBytesLimit: number,\n    private messageBytesLimit: number,\n    private flushTimeout: number,\n    private beforeUnloadCallback: () => void = noop\n  ) {\n    this.setupFlushOnExit()\n    this.flushPeriodically()\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  flush(sendFn = this.request.send) {\n    if (this.bufferMessagesCount !== 0) {\n      const messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer))\n      const bytesCount = this.bufferBytesCount\n\n      this.pushOnlyBuffer = []\n      this.upsertBuffer = {}\n      this.bufferBytesCount = 0\n      this.bufferMessagesCount = 0\n\n      sendFn({ data: messages.join('\\n'), bytesCount })\n    }\n  }\n\n  flushOnExit() {\n    this.flush(this.request.sendOnExit)\n  }\n\n  computeBytesCount(candidate: string) {\n    // Accurate bytes count computations can degrade performances when there is a lot of events to process\n    if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n      return candidate.length\n    }\n\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(candidate).length\n    }\n\n    return new Blob([candidate]).size\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const { processedMessage, messageBytesCount } = this.process(message)\n    if (messageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB.`\n      )\n      return\n    }\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n    if (this.willReachedBytesLimitWith(messageBytesCount)) {\n      this.flush()\n    }\n\n    this.push(processedMessage, messageBytesCount, key)\n    if (this.isFull()) {\n      this.flush()\n    }\n  }\n\n  private process(message: Context) {\n    const processedMessage = jsonStringify(message)!\n    const messageBytesCount = this.computeBytesCount(processedMessage)\n    return { processedMessage, messageBytesCount }\n  }\n\n  private push(processedMessage: string, messageBytesCount: number, key?: string) {\n    if (this.bufferMessagesCount > 0) {\n      // \\n separator at serialization\n      this.bufferBytesCount += 1\n    }\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage\n    } else {\n      this.pushOnlyBuffer.push(processedMessage)\n    }\n    this.bufferBytesCount += messageBytesCount\n    this.bufferMessagesCount += 1\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = this.computeBytesCount(removedMessage)\n    this.bufferBytesCount -= messageBytesCount\n    this.bufferMessagesCount -= 1\n    if (this.bufferMessagesCount > 0) {\n      this.bufferBytesCount -= 1\n    }\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n\n  private willReachedBytesLimitWith(messageBytesCount: number) {\n    // byte of the separator at the end of the message\n    return this.bufferBytesCount + messageBytesCount + 1 >= this.batchBytesLimit\n  }\n\n  private isFull() {\n    return this.bufferMessagesCount === this.batchMessagesLimit || this.bufferBytesCount >= this.batchBytesLimit\n  }\n\n  private flushPeriodically() {\n    setTimeout(\n      monitor(() => {\n        this.flush()\n        this.flushPeriodically()\n      }),\n      this.flushTimeout\n    )\n  }\n\n  private setupFlushOnExit() {\n    /**\n     * With sendBeacon, requests are guaranteed to be successfully sent during document unload\n     */\n    // @ts-ignore this function is not always defined\n    if (navigator.sendBeacon) {\n      /**\n       * beforeunload is called before visibilitychange\n       * register first to be sure to be called before flush on beforeunload\n       * caveat: unload can still be canceled by another listener\n       */\n      addEventListener(window, DOM_EVENT.BEFORE_UNLOAD, this.beforeUnloadCallback)\n\n      /**\n       * Only event that guarantee to fire on mobile devices when the page transitions to background state\n       * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n       */\n      addEventListener(document, DOM_EVENT.VISIBILITY_CHANGE, () => {\n        if (document.visibilityState === 'hidden') {\n          this.flushOnExit()\n        }\n      })\n      /**\n       * Safari does not support yet to send a request during:\n       * - a visibility change during doc unload (cf: https://bugs.webkit.org/show_bug.cgi?id=194897)\n       * - a page hide transition (cf: https://bugs.webkit.org/show_bug.cgi?id=188329)\n       */\n      addEventListener(window, DOM_EVENT.BEFORE_UNLOAD, () => this.flushOnExit())\n    }\n  }\n}\n","import type { EndpointType } from '../domain/configuration'\nimport { monitor } from '../tools/monitor'\nimport type { RawError } from '../tools/error'\nimport { clocksNow } from '../tools/timeUtils'\nimport { ONE_KIBI_BYTE, ONE_MEBI_BYTE, ONE_SECOND, ONE_MINUTE } from '../tools/utils'\nimport { ErrorSource } from '../tools/error'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, endpointType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(\n    monitor(() => {\n      const payload = state.queuedPayloads.first()\n      send(payload, state, sendStrategy, {\n        onSuccess: () => {\n          state.queuedPayloads.dequeue()\n          state.currentBackoffTime = INITIAL_BACKOFF_TIME\n          retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, endpointType, reportError)\n        },\n        onFailure: () => {\n          state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n          scheduleRetry(state, sendStrategy, endpointType, reportError)\n        },\n      })\n    }),\n    state.currentBackoffTime\n  )\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${endpointType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, endpointType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return response.status === 0 || response.status === 408 || response.status === 429 || response.status >= 500\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n","import type { EndpointBuilder } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/context'\nimport { monitor } from '../tools/monitor'\nimport type { RawError } from '../tools/error'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n}\n\nexport interface Payload {\n  data: string | FormData\n  bytesCount: number\n}\n\nexport function createHttpRequest(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(endpointBuilder: EndpointBuilder, bytesLimit: number, { data, bytesCount }: Payload) {\n  const url = endpointBuilder.build()\n  const canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const isQueued = navigator.sendBeacon(url, data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  sendXHR(url, data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount }: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const url = endpointBuilder.build()\n  const canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    fetch(url, { method: 'POST', body: data, keepalive: true }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status })),\n      monitor(() => {\n        // failed to queue the request\n        sendXHR(url, data, onResponse)\n      })\n    )\n  } else {\n    sendXHR(url, data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(url: string, data: Payload['data'], onResponse?: (r: HttpResponse) => void) {\n  const request = new XMLHttpRequest()\n  const onLoadEnd = monitor(() => {\n    // prevent multiple onResponse callbacks\n    // if the xhr instance is reused by a third party\n    request.removeEventListener('loadend', onLoadEnd)\n    onResponse?.({ status: request.status })\n  })\n  request.open('POST', url, true)\n  request.addEventListener('loadend', onLoadEnd)\n  request.send(data)\n}\n","import type { Context, EndpointBuilder, TelemetryEvent, Observable, RawError } from '@datadog/browser-core'\nimport { Batch, combine, createHttpRequest, isTelemetryReplicationAllowed } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumBatch(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  telemetryEventObservable: Observable<TelemetryEvent & Context>,\n  reportError: (error: RawError) => void\n) {\n  const batch = makeRumBatch(configuration, lifeCycle, reportError)\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    if (serverRumEvent.type === RumEventType.VIEW) {\n      batch.upsert(serverRumEvent, serverRumEvent.view.id)\n    } else {\n      batch.add(serverRumEvent)\n    }\n  })\n\n  telemetryEventObservable.subscribe((event) => batch.add(event, isTelemetryReplicationAllowed(configuration)))\n}\n\ninterface RumBatch {\n  add: (message: Context, replicated?: boolean) => void\n  upsert: (message: Context, key: string) => void\n}\n\nfunction makeRumBatch(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  reportError: (error: RawError) => void\n): RumBatch {\n  const primaryBatch = createRumBatch(configuration.rumEndpointBuilder, () =>\n    lifeCycle.notify(LifeCycleEventType.BEFORE_UNLOAD)\n  )\n\n  let replicaBatch: Batch | undefined\n  const replica = configuration.replica\n  if (replica !== undefined) {\n    replicaBatch = createRumBatch(replica.rumEndpointBuilder)\n  }\n\n  function createRumBatch(endpointBuilder: EndpointBuilder, unloadCallback?: () => void) {\n    return new Batch(\n      createHttpRequest(endpointBuilder, configuration.batchBytesLimit, reportError),\n      configuration.batchMessagesLimit,\n      configuration.batchBytesLimit,\n      configuration.messageBytesLimit,\n      configuration.flushTimeout,\n      unloadCallback\n    )\n  }\n\n  function withReplicaApplicationId(message: Context) {\n    return combine(message, { application: { id: replica!.applicationId } })\n  }\n\n  return {\n    add: (message: Context, replicated = true) => {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(withReplicaApplicationId(message))\n      }\n    },\n    upsert: (message: Context, key: string) => {\n      primaryBatch.upsert(message, key)\n      if (replicaBatch) {\n        replicaBatch.upsert(withReplicaApplicationId(message), key)\n      }\n    },\n  }\n}\n","import {\n  addEventListener,\n  DOM_EVENT,\n  instrumentMethodAndCallOriginal,\n  Observable,\n  shallowClone,\n} from '@datadog/browser-core'\n\nexport interface LocationChange {\n  oldLocation: Readonly<Location>\n  newLocation: Readonly<Location>\n}\n\nexport function createLocationChangeObservable(location: Location) {\n  let currentLocation = shallowClone(location)\n  const observable = new Observable<LocationChange>(() => {\n    const { stop: stopHistoryTracking } = trackHistory(onLocationChange)\n    const { stop: stopHashTracking } = trackHash(onLocationChange)\n    return () => {\n      stopHistoryTracking()\n      stopHashTracking()\n    }\n  })\n\n  function onLocationChange() {\n    if (currentLocation.href === location.href) {\n      return\n    }\n    const newLocation = shallowClone(location)\n    observable.notify({\n      newLocation,\n      oldLocation: currentLocation,\n    })\n    currentLocation = newLocation\n  }\n\n  return observable\n}\n\nfunction trackHistory(onHistoryChange: () => void) {\n  const { stop: stopInstrumentingPushState } = instrumentMethodAndCallOriginal(history, 'pushState', {\n    after: onHistoryChange,\n  })\n  const { stop: stopInstrumentingReplaceState } = instrumentMethodAndCallOriginal(history, 'replaceState', {\n    after: onHistoryChange,\n  })\n  const { stop: removeListener } = addEventListener(window, DOM_EVENT.POP_STATE, onHistoryChange)\n\n  return {\n    stop: () => {\n      stopInstrumentingPushState()\n      stopInstrumentingReplaceState()\n      removeListener()\n    },\n  }\n}\n\nfunction trackHash(onHashChange: () => void) {\n  return addEventListener(window, DOM_EVENT.HASH_CHANGE, onHashChange)\n}\n","import type * as SessionReplay from './sessionReplay'\n\nexport const RecordType: {\n  FullSnapshot: SessionReplay.BrowserFullSnapshotRecord['type']\n  IncrementalSnapshot: SessionReplay.BrowserIncrementalSnapshotRecord['type']\n  Meta: SessionReplay.MetaRecord['type']\n  Focus: SessionReplay.FocusRecord['type']\n  ViewEnd: SessionReplay.ViewEndRecord['type']\n  VisualViewport: SessionReplay.VisualViewportRecord['type']\n  FrustrationRecord: SessionReplay.FrustrationRecord['type']\n} = {\n  FullSnapshot: 2,\n  IncrementalSnapshot: 3,\n  Meta: 4,\n  Focus: 6,\n  ViewEnd: 7,\n  VisualViewport: 8,\n  FrustrationRecord: 9,\n} as const\n\nexport type RecordType = typeof RecordType[keyof typeof RecordType]\n\nexport const NodeType: {\n  Document: SessionReplay.DocumentNode['type']\n  DocumentType: SessionReplay.DocumentTypeNode['type']\n  Element: SessionReplay.ElementNode['type']\n  Text: SessionReplay.TextNode['type']\n  CDATA: SessionReplay.CDataNode['type']\n} = {\n  Document: 0,\n  DocumentType: 1,\n  Element: 2,\n  Text: 3,\n  CDATA: 4,\n} as const\n\nexport type NodeType = typeof NodeType[keyof typeof NodeType]\n\nexport const IncrementalSource: {\n  Mutation: SessionReplay.BrowserMutationData['source']\n  MouseMove: Exclude<SessionReplay.MousemoveData['source'], 6>\n  MouseInteraction: SessionReplay.MouseInteractionData['source']\n  Scroll: SessionReplay.ScrollData['source']\n  ViewportResize: SessionReplay.ViewportResizeData['source']\n  Input: SessionReplay.InputData['source']\n  TouchMove: Exclude<SessionReplay.MousemoveData['source'], 1>\n  MediaInteraction: SessionReplay.MediaInteractionData['source']\n  StyleSheetRule: SessionReplay.StyleSheetRuleData['source']\n} = {\n  Mutation: 0,\n  MouseMove: 1,\n  MouseInteraction: 2,\n  Scroll: 3,\n  ViewportResize: 4,\n  Input: 5,\n  TouchMove: 6,\n  MediaInteraction: 7,\n  StyleSheetRule: 8,\n  // CanvasMutation : 9,\n  // Font : 10,\n} as const\n\nexport type IncrementalSource = typeof IncrementalSource[keyof typeof IncrementalSource]\n\nexport const MouseInteractionType = {\n  MouseUp: 0,\n  MouseDown: 1,\n  Click: 2,\n  ContextMenu: 3,\n  DblClick: 4,\n  Focus: 5,\n  Blur: 6,\n  TouchStart: 7,\n  TouchEnd: 9,\n} as const\n\nexport type MouseInteractionType = typeof MouseInteractionType[keyof typeof MouseInteractionType]\n\nexport const MediaInteractionType = {\n  Play: 0,\n  Pause: 1,\n} as const\n\nexport type MediaInteractionType = typeof MediaInteractionType[keyof typeof MediaInteractionType]\n","import { DefaultPrivacyLevel } from '@datadog/browser-core'\n\nexport const NodePrivacyLevel = {\n  IGNORE: 'ignore',\n  HIDDEN: 'hidden',\n  ALLOW: DefaultPrivacyLevel.ALLOW,\n  MASK: DefaultPrivacyLevel.MASK,\n  MASK_USER_INPUT: DefaultPrivacyLevel.MASK_USER_INPUT,\n} as const\nexport type NodePrivacyLevel = typeof NodePrivacyLevel[keyof typeof NodePrivacyLevel]\n\nexport const PRIVACY_ATTR_NAME = 'data-dd-privacy'\n\n// Privacy Attrs\nexport const PRIVACY_ATTR_VALUE_ALLOW = 'allow'\nexport const PRIVACY_ATTR_VALUE_MASK = 'mask'\nexport const PRIVACY_ATTR_VALUE_MASK_USER_INPUT = 'mask-user-input'\nexport const PRIVACY_ATTR_VALUE_HIDDEN = 'hidden'\n\n// Privacy Classes - not all customers can set plain HTML attributes, so support classes too\nexport const PRIVACY_CLASS_ALLOW = 'dd-privacy-allow'\nexport const PRIVACY_CLASS_MASK = 'dd-privacy-mask'\nexport const PRIVACY_CLASS_MASK_USER_INPUT = 'dd-privacy-mask-user-input'\nexport const PRIVACY_CLASS_HIDDEN = 'dd-privacy-hidden'\n\n// Private Replacement Templates\nexport const CENSORED_STRING_MARK = '***'\nexport const CENSORED_IMG_MARK = 'data:image/gif;base64,R0lGODlhAQABAIAAAMLCwgAAACH5BAAAAAAALAAAAAABAAEAAAICRAEAOw=='\n\nexport const FORM_PRIVATE_TAG_NAMES: { [tagName: string]: true } = {\n  INPUT: true,\n  OUTPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n  OPTION: true,\n  DATALIST: true,\n  OPTGROUP: true,\n}\n","import {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_ALLOW,\n  PRIVACY_ATTR_VALUE_MASK,\n  PRIVACY_ATTR_VALUE_MASK_USER_INPUT,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n  PRIVACY_CLASS_ALLOW,\n  PRIVACY_CLASS_MASK,\n  PRIVACY_CLASS_MASK_USER_INPUT,\n  PRIVACY_CLASS_HIDDEN,\n  FORM_PRIVATE_TAG_NAMES,\n  CENSORED_STRING_MARK,\n} from '../../constants'\n\nexport const MAX_ATTRIBUTE_VALUE_CHAR_LENGTH = 100_000\n\nconst TEXT_MASKING_CHAR = 'x'\n\n/**\n * Get node privacy level by iterating over its ancestors. When the direct parent privacy level is\n * know, it is best to use something like:\n *\n * derivePrivacyLevelGivenParent(getNodeSelfPrivacyLevel(node), parentNodePrivacyLevel)\n */\nexport function getNodePrivacyLevel(node: Node, defaultPrivacyLevel: NodePrivacyLevel): NodePrivacyLevel {\n  const parentNodePrivacyLevel = node.parentNode\n    ? getNodePrivacyLevel(node.parentNode, defaultPrivacyLevel)\n    : defaultPrivacyLevel\n  const selfNodePrivacyLevel = getNodeSelfPrivacyLevel(node)\n  return reducePrivacyLevel(selfNodePrivacyLevel, parentNodePrivacyLevel)\n}\n\n/**\n * Reduces the next privacy level based on self + parent privacy levels\n */\nexport function reducePrivacyLevel(\n  childPrivacyLevel: NodePrivacyLevel | undefined,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): NodePrivacyLevel {\n  switch (parentNodePrivacyLevel) {\n    // These values cannot be overridden\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return parentNodePrivacyLevel\n  }\n  switch (childPrivacyLevel) {\n    case NodePrivacyLevel.ALLOW:\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.MASK_USER_INPUT:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return childPrivacyLevel\n    default:\n      return parentNodePrivacyLevel\n  }\n}\n\n/**\n * Determines the node's own privacy level without checking for ancestors.\n */\nexport function getNodeSelfPrivacyLevel(node: Node): NodePrivacyLevel | undefined {\n  // Only Element types can have a privacy level set\n  if (!isElement(node)) {\n    return\n  }\n\n  const privAttr = node.getAttribute(PRIVACY_ATTR_NAME)\n\n  // Overrules for replay purpose\n  if (node.tagName === 'BASE') {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  // Overrules to enforce end-user protection\n  if (node.tagName === 'INPUT') {\n    const inputElement = node as HTMLInputElement\n    if (inputElement.type === 'password' || inputElement.type === 'email' || inputElement.type === 'tel') {\n      return NodePrivacyLevel.MASK\n    }\n    if (inputElement.type === 'hidden') {\n      return NodePrivacyLevel.MASK\n    }\n    const autocomplete = inputElement.getAttribute('autocomplete')\n    // Handle input[autocomplete=cc-number/cc-csc/cc-exp/cc-exp-month/cc-exp-year]\n    if (autocomplete && autocomplete.indexOf('cc-') === 0) {\n      return NodePrivacyLevel.MASK\n    }\n  }\n\n  // Check HTML privacy attributes and classes\n  if (privAttr === PRIVACY_ATTR_VALUE_HIDDEN || node.classList.contains(PRIVACY_CLASS_HIDDEN)) {\n    return NodePrivacyLevel.HIDDEN\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK || node.classList.contains(PRIVACY_CLASS_MASK)) {\n    return NodePrivacyLevel.MASK\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_MASK_USER_INPUT || node.classList.contains(PRIVACY_CLASS_MASK_USER_INPUT)) {\n    return NodePrivacyLevel.MASK_USER_INPUT\n  }\n\n  if (privAttr === PRIVACY_ATTR_VALUE_ALLOW || node.classList.contains(PRIVACY_CLASS_ALLOW)) {\n    return NodePrivacyLevel.ALLOW\n  }\n\n  if (shouldIgnoreElement(node)) {\n    return NodePrivacyLevel.IGNORE\n  }\n}\n\n/**\n * Helper aiming to unify `mask` and `mask-user-input` privacy levels:\n *\n * In the `mask` case, it is trivial: we should mask the element.\n *\n * In the `mask-user-input` case, we should mask the element only if it is a \"form\" element or the\n * direct parent is a form element for text nodes).\n *\n * Other `shouldMaskNode` cases are edge cases that should not matter too much (ex: should we mask a\n * node if it is ignored or hidden? it doesn't matter since it won't be serialized).\n */\nexport function shouldMaskNode(node: Node, privacyLevel: NodePrivacyLevel) {\n  switch (privacyLevel) {\n    case NodePrivacyLevel.MASK:\n    case NodePrivacyLevel.HIDDEN:\n    case NodePrivacyLevel.IGNORE:\n      return true\n    case NodePrivacyLevel.MASK_USER_INPUT:\n      return isTextNode(node) ? isFormElement(node.parentNode) : isFormElement(node)\n    default:\n      return false\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return node.nodeType === node.ELEMENT_NODE\n}\n\nfunction isTextNode(node: Node): node is Text {\n  return node.nodeType === node.TEXT_NODE\n}\n\nfunction isFormElement(node: Node | null): boolean {\n  if (!node || node.nodeType !== node.ELEMENT_NODE) {\n    return false\n  }\n  const element = node as HTMLInputElement\n  if (element.tagName === 'INPUT') {\n    switch (element.type) {\n      case 'button':\n      case 'color':\n      case 'reset':\n      case 'submit':\n        return false\n    }\n  }\n  return !!FORM_PRIVATE_TAG_NAMES[element.tagName]\n}\n\n/**\n * Text censoring non-destructively maintains whitespace characters in order to preserve text shape\n * during replay.\n */\nexport const censorText = (text: string) => text.replace(/\\S/g, TEXT_MASKING_CHAR)\n\nexport function getTextContent(\n  textNode: Node,\n  ignoreWhiteSpace: boolean,\n  parentNodePrivacyLevel: NodePrivacyLevel\n): string | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  let textContent = textNode.textContent || ''\n\n  if (ignoreWhiteSpace && !textContent.trim()) {\n    return\n  }\n\n  const nodePrivacyLevel = parentNodePrivacyLevel\n\n  const isStyle = parentTagName === 'STYLE' ? true : undefined\n  const isScript = parentTagName === 'SCRIPT'\n\n  if (isScript) {\n    // For perf reasons, we don't record script (heuristic)\n    textContent = CENSORED_STRING_MARK\n  } else if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // Should never occur, but just in case, we set to CENSORED_MARK.\n    textContent = CENSORED_STRING_MARK\n  } else if (\n    shouldMaskNode(textNode, nodePrivacyLevel) &&\n    // Style tags are `overruled` (Use `hide` to enforce privacy)\n    !isStyle\n  ) {\n    if (\n      // Scrambling the child list breaks text nodes for DATALIST/SELECT/OPTGROUP\n      parentTagName === 'DATALIST' ||\n      parentTagName === 'SELECT' ||\n      parentTagName === 'OPTGROUP'\n    ) {\n      if (!textContent.trim()) {\n        return\n      }\n    } else if (parentTagName === 'OPTION') {\n      // <Option> has low entropy in charset + text length, so use `CENSORED_STRING_MARK` when masked\n      textContent = CENSORED_STRING_MARK\n    } else {\n      textContent = censorText(textContent)\n    }\n  }\n  return textContent\n}\n\n/**\n * TODO: Preserve CSS element order, and record the presence of the tag, just don't render\n * We don't need this logic on the recorder side.\n * For security related meta's, customer can mask themmanually given they\n * are easy to identify in the HEAD tag.\n */\nexport function shouldIgnoreElement(element: Element): boolean {\n  if (element.nodeName === 'SCRIPT') {\n    return true\n  }\n\n  if (element.nodeName === 'LINK') {\n    const relAttribute = getLowerCaseAttribute('rel')\n    return (\n      // Scripts\n      (relAttribute === 'preload' && getLowerCaseAttribute('as') === 'script') ||\n      // Favicons\n      relAttribute === 'shortcut icon' ||\n      relAttribute === 'icon'\n    )\n  }\n\n  if (element.nodeName === 'META') {\n    const nameAttribute = getLowerCaseAttribute('name')\n    const relAttribute = getLowerCaseAttribute('rel')\n    const propertyAttribute = getLowerCaseAttribute('property')\n    return (\n      // Favicons\n      /^msapplication-tile(image|color)$/.test(nameAttribute) ||\n      nameAttribute === 'application-name' ||\n      relAttribute === 'icon' ||\n      relAttribute === 'apple-touch-icon' ||\n      relAttribute === 'shortcut icon' ||\n      // Description\n      nameAttribute === 'keywords' ||\n      nameAttribute === 'description' ||\n      // Social\n      /^(og|twitter|fb):/.test(propertyAttribute) ||\n      /^(og|twitter):/.test(nameAttribute) ||\n      nameAttribute === 'pinterest' ||\n      // Robots\n      nameAttribute === 'robots' ||\n      nameAttribute === 'googlebot' ||\n      nameAttribute === 'bingbot' ||\n      // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,\n      // X-Translated-By\n      element.hasAttribute('http-equiv') ||\n      // Authorship\n      nameAttribute === 'author' ||\n      nameAttribute === 'generator' ||\n      nameAttribute === 'framework' ||\n      nameAttribute === 'publisher' ||\n      nameAttribute === 'progid' ||\n      /^article:/.test(propertyAttribute) ||\n      /^product:/.test(propertyAttribute) ||\n      // Verification\n      nameAttribute === 'google-site-verification' ||\n      nameAttribute === 'yandex-verification' ||\n      nameAttribute === 'csrf-token' ||\n      nameAttribute === 'p:domain_verify' ||\n      nameAttribute === 'verify-v1' ||\n      nameAttribute === 'verification' ||\n      nameAttribute === 'shopify-checkout-api-token'\n    )\n  }\n\n  function getLowerCaseAttribute(name: string) {\n    return (element.getAttribute(name) || '').toLowerCase()\n  }\n\n  return false\n}\n","import { buildUrl } from '@datadog/browser-core'\nimport type { NodePrivacyLevel } from '../../constants'\nimport { CENSORED_STRING_MARK } from '../../constants'\nimport { shouldMaskNode } from './privacy'\n\nexport type NodeWithSerializedNode = Node & { s: 'Node with serialized node' }\n\nconst serializedNodeIds = new WeakMap<Node, number>()\n\nexport function hasSerializedNode(node: Node): node is NodeWithSerializedNode {\n  return serializedNodeIds.has(node)\n}\n\nexport function nodeAndAncestorsHaveSerializedNode(node: Node): node is NodeWithSerializedNode {\n  let current: Node | null = node\n  while (current) {\n    if (!hasSerializedNode(current)) {\n      return false\n    }\n    current = current.parentNode\n  }\n  return true\n}\n\nexport function getSerializedNodeId(node: NodeWithSerializedNode): number\nexport function getSerializedNodeId(node: Node): number | undefined\nexport function getSerializedNodeId(node: Node) {\n  return serializedNodeIds.get(node)\n}\n\nexport function setSerializedNodeId(node: Node, serializeNodeId: number) {\n  serializedNodeIds.set(node, serializeNodeId)\n}\n\n/**\n * Get the element \"value\" to be serialized as an attribute or an input update record. It respects\n * the input privacy mode of the element.\n * PERFROMANCE OPTIMIZATION: Assumes that privacy level `HIDDEN` is never encountered because of earlier checks.\n */\nexport function getElementInputValue(element: Element, nodePrivacyLevel: NodePrivacyLevel) {\n  /*\n   BROWSER SPEC NOTE: <input>, <select>\n   For some <input> elements, the `value` is an exceptional property/attribute that has the\n   value synced between el.value and el.getAttribute()\n   input[type=button,checkbox,hidden,image,radio,reset,submit]\n   */\n  const tagName = element.tagName\n  const value = (element as HTMLInputElement | HTMLTextAreaElement).value\n\n  if (shouldMaskNode(element, nodePrivacyLevel)) {\n    const type = (element as HTMLInputElement | HTMLTextAreaElement).type\n    if (tagName === 'INPUT' && (type === 'button' || type === 'submit' || type === 'reset')) {\n      // Overrule `MASK` privacy level for button-like element values, as they are used during replay\n      // to display their label. They can still be hidden via the \"hidden\" privacy attribute or class name.\n      return value\n    } else if (!value || tagName === 'OPTION') {\n      // <Option> value provides no benefit\n      return\n    }\n    return CENSORED_STRING_MARK\n  }\n\n  if (tagName === 'OPTION' || tagName === 'SELECT') {\n    return (element as HTMLOptionElement | HTMLSelectElement).value\n  }\n\n  if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {\n    return\n  }\n\n  return value\n}\n\nexport const URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")([^\"]*)\"|([^)]*))\\)/gm\nexport const ABSOLUTE_URL = /^[A-Za-z]+:|^\\/\\//\nexport const DATA_URI = /^data:.*,/i\n\nexport function switchToAbsoluteUrl(cssText: string, cssHref: string | null): string {\n  return cssText.replace(\n    URL_IN_CSS_REF,\n    (\n      matchingSubstring: string,\n      singleQuote: string | undefined,\n      urlWrappedInSingleQuotes: string | undefined,\n      doubleQuote: string | undefined,\n      urlWrappedInDoubleQuotes: string | undefined,\n      urlNotWrappedInQuotes: string | undefined\n    ) => {\n      const url = urlWrappedInSingleQuotes || urlWrappedInDoubleQuotes || urlNotWrappedInQuotes\n\n      if (!cssHref || !url || ABSOLUTE_URL.test(url) || DATA_URI.test(url)) {\n        return matchingSubstring\n      }\n\n      const quote = singleQuote || doubleQuote || ''\n      return `url(${quote}${makeUrlAbsolute(url, cssHref)}${quote})`\n    }\n  )\n}\n\nexport function makeUrlAbsolute(url: string, baseUrl: string): string {\n  try {\n    return buildUrl(url, baseUrl).href\n  } catch (_) {\n    return url\n  }\n}\n","import { assign, timeStampNow } from '@datadog/browser-core'\nimport type { BrowserIncrementalData, BrowserIncrementalSnapshotRecord } from '../../types'\nimport { RecordType } from '../../types'\n\nexport function isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches)\n}\n\nexport function forEach<List extends { [index: number]: any }>(\n  list: List,\n  callback: (value: List[number], index: number, parent: List) => void\n) {\n  Array.prototype.forEach.call(list, callback as any)\n}\n\nexport function assembleIncrementalSnapshot<Data extends BrowserIncrementalData>(\n  source: Data['source'],\n  data: Omit<Data, 'source'>\n): BrowserIncrementalSnapshotRecord {\n  return {\n    data: assign(\n      {\n        source,\n      },\n      data\n    ) as Data,\n    type: RecordType.IncrementalSnapshot,\n    timestamp: timeStampNow(),\n  }\n}\n\nexport function getPathToNestedCSSRule(rule: CSSRule): number[] | undefined {\n  const path: number[] = []\n  let currentRule = rule\n  while (currentRule.parentRule) {\n    const rules = Array.from((currentRule.parentRule as CSSGroupingRule).cssRules)\n    const index = rules.indexOf(currentRule)\n    path.unshift(index)\n    currentRule = currentRule.parentRule\n  }\n  // A rule may not be attached to a stylesheet\n  if (!currentRule.parentStyleSheet) {\n    return\n  }\n\n  const rules = Array.from(currentRule.parentStyleSheet.cssRules)\n  const index = rules.indexOf(currentRule)\n  path.unshift(index)\n\n  return path\n}\n","import { assign, startsWith } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { STABLE_ATTRIBUTES } from '@datadog/browser-rum-core'\nimport {\n  NodePrivacyLevel,\n  PRIVACY_ATTR_NAME,\n  PRIVACY_ATTR_VALUE_HIDDEN,\n  CENSORED_STRING_MARK,\n  CENSORED_IMG_MARK,\n} from '../../constants'\nimport type {\n  SerializedNode,\n  SerializedNodeWithId,\n  DocumentNode,\n  DocumentTypeNode,\n  ElementNode,\n  TextNode,\n  CDataNode,\n} from '../../types'\nimport { NodeType } from '../../types'\nimport {\n  getTextContent,\n  shouldMaskNode,\n  reducePrivacyLevel,\n  getNodeSelfPrivacyLevel,\n  MAX_ATTRIBUTE_VALUE_CHAR_LENGTH,\n} from './privacy'\nimport {\n  getSerializedNodeId,\n  setSerializedNodeId,\n  getElementInputValue,\n  switchToAbsoluteUrl,\n} from './serializationUtils'\nimport { forEach } from './utils'\nimport type { ElementsScrollPositions } from './elementsScrollPositions'\n\n// Those values are the only one that can be used when inheriting privacy levels from parent to\n// children during serialization, since HIDDEN and IGNORE shouldn't serialize their children. This\n// ensures that no children are serialized when they shouldn't.\ntype ParentNodePrivacyLevel =\n  | typeof NodePrivacyLevel.ALLOW\n  | typeof NodePrivacyLevel.MASK\n  | typeof NodePrivacyLevel.MASK_USER_INPUT\n\nexport const enum SerializationContextStatus {\n  INITIAL_FULL_SNAPSHOT,\n  SUBSEQUENT_FULL_SNAPSHOT,\n  MUTATION,\n}\n\nexport type SerializationContext =\n  | {\n      status: SerializationContextStatus.MUTATION\n    }\n  | {\n      status: SerializationContextStatus.INITIAL_FULL_SNAPSHOT\n      elementsScrollPositions: ElementsScrollPositions\n    }\n  | {\n      status: SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT\n      elementsScrollPositions: ElementsScrollPositions\n    }\n\nexport interface SerializeOptions {\n  serializedNodeIds?: Set<number>\n  ignoreWhiteSpace?: boolean\n  parentNodePrivacyLevel: ParentNodePrivacyLevel\n  serializationContext: SerializationContext\n  configuration: RumConfiguration\n}\n\nexport function serializeDocument(\n  document: Document,\n  configuration: RumConfiguration,\n  serializationContext: SerializationContext\n): SerializedNodeWithId {\n  // We are sure that Documents are never ignored, so this function never returns null\n  return serializeNodeWithId(document, {\n    serializationContext,\n    parentNodePrivacyLevel: configuration.defaultPrivacyLevel,\n    configuration,\n  })!\n}\n\nexport function serializeNodeWithId(node: Node, options: SerializeOptions): SerializedNodeWithId | null {\n  const serializedNode = serializeNode(node, options)\n  if (!serializedNode) {\n    return null\n  }\n\n  // Try to reuse the previous id\n  const id = getSerializedNodeId(node) || generateNextId()\n  const serializedNodeWithId = serializedNode as SerializedNodeWithId\n  serializedNodeWithId.id = id\n  setSerializedNodeId(node, id)\n  if (options.serializedNodeIds) {\n    options.serializedNodeIds.add(id)\n  }\n  return serializedNodeWithId\n}\n\nfunction serializeNode(node: Node, options: SerializeOptions): SerializedNode | undefined {\n  switch (node.nodeType) {\n    case node.DOCUMENT_NODE:\n      return serializeDocumentNode(node as Document, options)\n    case node.DOCUMENT_TYPE_NODE:\n      return serializeDocumentTypeNode(node as DocumentType)\n    case node.ELEMENT_NODE:\n      return serializeElementNode(node as Element, options)\n    case node.TEXT_NODE:\n      return serializeTextNode(node as Text, options)\n    case node.CDATA_SECTION_NODE:\n      return serializeCDataNode()\n  }\n}\n\nexport function serializeDocumentNode(document: Document, options: SerializeOptions): DocumentNode {\n  return {\n    type: NodeType.Document,\n    childNodes: serializeChildNodes(document, options),\n  }\n}\n\nfunction serializeDocumentTypeNode(documentType: DocumentType): DocumentTypeNode {\n  return {\n    type: NodeType.DocumentType,\n    name: documentType.name,\n    publicId: documentType.publicId,\n    systemId: documentType.systemId,\n  }\n}\n\n/**\n * Serializing Element nodes involves capturing:\n * 1. HTML ATTRIBUTES:\n * 2. JS STATE:\n * - scroll offsets\n * - Form fields (input value, checkbox checked, option selection, range)\n * - Canvas state,\n * - Media (video/audio) play mode + currentTime\n * - iframe contents\n * - webcomponents\n * 3. CUSTOM PROPERTIES:\n * - height+width for when `hidden` to cover the element\n * 4. EXCLUDED INTERACTION STATE:\n * - focus (possible, but not worth perf impact)\n * - hover (tracked only via mouse activity)\n * - fullscreen mode\n */\nexport function serializeElementNode(element: Element, options: SerializeOptions): ElementNode | undefined {\n  const tagName = getValidTagName(element.tagName)\n  const isSVG = isSVGElement(element) || undefined\n\n  // For performance reason, we don't use getNodePrivacyLevel directly: we leverage the\n  // parentNodePrivacyLevel option to avoid iterating over all parents\n  const nodePrivacyLevel = reducePrivacyLevel(getNodeSelfPrivacyLevel(element), options.parentNodePrivacyLevel)\n\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    const { width, height } = element.getBoundingClientRect()\n    return {\n      type: NodeType.Element,\n      tagName,\n      attributes: {\n        rr_width: `${width}px`,\n        rr_height: `${height}px`,\n        [PRIVACY_ATTR_NAME]: PRIVACY_ATTR_VALUE_HIDDEN,\n      },\n      childNodes: [],\n      isSVG,\n    }\n  }\n\n  // Ignore Elements like Script and some Link, Metas\n  if (nodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n    return\n  }\n\n  const attributes = getAttributesForPrivacyLevel(element, nodePrivacyLevel, options)\n\n  let childNodes: SerializedNodeWithId[] = []\n  if (element.childNodes.length) {\n    // OBJECT POOLING OPTIMIZATION:\n    // We should not create a new object systematically as it could impact performances. Try to reuse\n    // the same object as much as possible, and clone it only if we need to.\n    let childNodesSerializationOptions\n    if (options.parentNodePrivacyLevel === nodePrivacyLevel && options.ignoreWhiteSpace === (tagName === 'head')) {\n      childNodesSerializationOptions = options\n    } else {\n      childNodesSerializationOptions = assign({}, options, {\n        parentNodePrivacyLevel: nodePrivacyLevel,\n        ignoreWhiteSpace: tagName === 'head',\n      })\n    }\n    childNodes = serializeChildNodes(element, childNodesSerializationOptions)\n  }\n\n  return {\n    type: NodeType.Element,\n    tagName,\n    attributes,\n    childNodes,\n    isSVG,\n  }\n}\n\n/**\n * Text Nodes are dependant on Element nodes\n * Privacy levels are set on elements so we check the parentElement of a text node\n * for privacy level.\n */\nfunction serializeTextNode(textNode: Text, options: SerializeOptions): TextNode | undefined {\n  // The parent node may not be a html element which has a tagName attribute.\n  // So just let it be undefined which is ok in this use case.\n  const parentTagName = textNode.parentElement?.tagName\n  const textContent = getTextContent(textNode, options.ignoreWhiteSpace || false, options.parentNodePrivacyLevel)\n  if (!textContent) {\n    return\n  }\n  return {\n    type: NodeType.Text,\n    textContent,\n    isStyle: parentTagName === 'STYLE' ? true : undefined,\n  }\n}\n\nfunction serializeCDataNode(): CDataNode {\n  return {\n    type: NodeType.CDATA,\n    textContent: '',\n  }\n}\n\nexport function serializeChildNodes(node: Node, options: SerializeOptions): SerializedNodeWithId[] {\n  const result: SerializedNodeWithId[] = []\n\n  forEach(node.childNodes, (childNode) => {\n    const serializedChildNode = serializeNodeWithId(childNode, options)\n    if (serializedChildNode) {\n      result.push(serializedChildNode)\n    }\n  })\n\n  return result\n}\n\nexport function serializeAttribute(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  attributeName: string,\n  configuration: RumConfiguration\n): string | number | boolean | null {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    // dup condition for direct access case\n    return null\n  }\n  const attributeValue = element.getAttribute(attributeName)\n  if (\n    nodePrivacyLevel === NodePrivacyLevel.MASK &&\n    attributeName !== PRIVACY_ATTR_NAME &&\n    !STABLE_ATTRIBUTES.includes(attributeName) &&\n    attributeName !== configuration.actionNameAttribute\n  ) {\n    const tagName = element.tagName\n\n    switch (attributeName) {\n      // Mask Attribute text content\n      case 'title':\n      case 'alt':\n      case 'placeholder':\n        return CENSORED_STRING_MARK\n    }\n    // mask image URLs\n    if (tagName === 'IMG' || tagName === 'SOURCE') {\n      if (attributeName === 'src' || attributeName === 'srcset') {\n        return CENSORED_IMG_MARK\n      }\n    }\n    // mask <a> URLs\n    if (tagName === 'A' && attributeName === 'href') {\n      return CENSORED_STRING_MARK\n    }\n\n    // mask data-* attributes\n    if (attributeValue && startsWith(attributeName, 'data-')) {\n      // Exception: it's safe to reveal the `${PRIVACY_ATTR_NAME}` attr\n      return CENSORED_STRING_MARK\n    }\n  }\n\n  if (!attributeValue || typeof attributeValue !== 'string') {\n    return attributeValue\n  }\n\n  // Minimum Fix for customer.\n  if (attributeValue.length > MAX_ATTRIBUTE_VALUE_CHAR_LENGTH && attributeValue.slice(0, 5) === 'data:') {\n    return 'data:truncated'\n  }\n\n  return attributeValue\n}\n\nlet _nextId = 1\nfunction generateNextId(): number {\n  return _nextId++\n}\n\nconst TAG_NAME_REGEX = /[^a-z1-6-_]/\nfunction getValidTagName(tagName: string): string {\n  const processedTagName = tagName.toLowerCase().trim()\n\n  if (TAG_NAME_REGEX.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div'\n  }\n\n  return processedTagName\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules\n    if (rules) {\n      const styleSheetCssText = Array.from(rules, getCssRuleString).join('')\n      return switchToAbsoluteUrl(styleSheetCssText, s.href)\n    }\n\n    return null\n  } catch (error) {\n    return null\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return el.tagName === 'svg' || el instanceof SVGElement\n}\n\nfunction getAttributesForPrivacyLevel(\n  element: Element,\n  nodePrivacyLevel: NodePrivacyLevel,\n  options: SerializeOptions\n): Record<string, string | number | boolean> {\n  if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n    return {}\n  }\n  const safeAttrs: Record<string, string | number | boolean> = {}\n  const tagName = getValidTagName(element.tagName)\n  const doc = element.ownerDocument\n\n  type HtmlAttribute = { name: string; value: string }\n  for (let i = 0; i < element.attributes.length; i += 1) {\n    const attribute = element.attributes.item(i) as HtmlAttribute\n    const attributeName = attribute.name\n    const attributeValue = serializeAttribute(element, nodePrivacyLevel, attributeName, options.configuration)\n    if (attributeValue !== null) {\n      safeAttrs[attributeName] = attributeValue\n    }\n  }\n\n  if (\n    (element as HTMLInputElement).value &&\n    (tagName === 'textarea' || tagName === 'select' || tagName === 'option' || tagName === 'input')\n  ) {\n    const formValue = getElementInputValue(element, nodePrivacyLevel)\n    if (formValue !== undefined) {\n      safeAttrs.value = formValue\n    }\n  }\n\n  /**\n   * <Option> can be selected, which occurs if its `value` matches ancestor `<Select>.value`\n   */\n  if (tagName === 'option' && nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n    // For privacy=`MASK`, all the values would be the same, so skip.\n    const optionElement = element as HTMLOptionElement\n    if (optionElement.selected) {\n      safeAttrs.selected = optionElement.selected\n    }\n  }\n\n  // remote css\n  if (tagName === 'link') {\n    const stylesheet = Array.from(doc.styleSheets).find((s) => s.href === (element as HTMLLinkElement).href)\n    const cssText = getCssRulesString(stylesheet as CSSStyleSheet)\n    if (cssText && stylesheet) {\n      delete safeAttrs.rel\n      delete safeAttrs.href\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  // dynamic stylesheet\n  if (\n    tagName === 'style' &&\n    (element as HTMLStyleElement).sheet &&\n    // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n    !((element as HTMLStyleElement).innerText || element.textContent || '').trim().length\n  ) {\n    const cssText = getCssRulesString((element as HTMLStyleElement).sheet as CSSStyleSheet)\n    if (cssText) {\n      safeAttrs._cssText = cssText\n    }\n  }\n\n  /**\n   * Forms: input[type=checkbox,radio]\n   * The `checked` property for <input> is a little bit special:\n   * 1. el.checked is a setter that returns if truthy.\n   * 2. getAttribute returns the string value\n   * getAttribute('checked') does not sync with `Element.checked`, so use JS property\n   * NOTE: `checked` property exists on `HTMLInputElement`. For serializer assumptions, we check for type=radio|check.\n   */\n  const inputElement = element as HTMLInputElement\n  if (tagName === 'input' && (inputElement.type === 'radio' || inputElement.type === 'checkbox')) {\n    if (nodePrivacyLevel === NodePrivacyLevel.ALLOW) {\n      safeAttrs.checked = !!inputElement.checked\n    } else if (shouldMaskNode(inputElement, nodePrivacyLevel)) {\n      safeAttrs.checked = CENSORED_STRING_MARK\n    }\n  }\n\n  /**\n   * Serialize the media playback state\n   */\n  if (tagName === 'audio' || tagName === 'video') {\n    const mediaElement = element as HTMLMediaElement\n    safeAttrs.rr_mediaState = mediaElement.paused ? 'paused' : 'played'\n  }\n\n  /**\n   * Serialize the scroll state for each element only for full snapshot\n   */\n  let scrollTop: number | undefined\n  let scrollLeft: number | undefined\n  const serializationContext = options.serializationContext\n  switch (serializationContext.status) {\n    case SerializationContextStatus.INITIAL_FULL_SNAPSHOT:\n      scrollTop = Math.round(element.scrollTop)\n      scrollLeft = Math.round(element.scrollLeft)\n      if (scrollTop || scrollLeft) {\n        serializationContext.elementsScrollPositions.set(element, { scrollTop, scrollLeft })\n      }\n      break\n    case SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT:\n      if (serializationContext.elementsScrollPositions.has(element)) {\n        ;({ scrollTop, scrollLeft } = serializationContext.elementsScrollPositions.get(element)!)\n      }\n      break\n  }\n  if (scrollLeft) {\n    safeAttrs.rr_scrollLeft = scrollLeft\n  }\n  if (scrollTop) {\n    safeAttrs.rr_scrollTop = scrollTop\n  }\n\n  return safeAttrs\n}\n","import { noop, requestIdleCallback } from '@datadog/browser-core'\nimport type { RumMutationRecord } from './mutationObserver'\n\n/**\n * Maximum duration to wait before processing mutations. If the browser is idle, mutations will be\n * processed more quickly. If the browser is busy executing small tasks (ex: rendering frames), the\n * mutations will wait MUTATION_PROCESS_MAX_DELAY milliseconds before being processed. If the\n * browser is busy executing a longer task, mutations will be processed after this task.\n */\nconst MUTATION_PROCESS_MAX_DELAY = 100\n\nexport function createMutationBatch(processMutationBatch: (mutations: RumMutationRecord[]) => void) {\n  let cancelScheduledFlush = noop\n  let pendingMutations: RumMutationRecord[] = []\n\n  function flush() {\n    cancelScheduledFlush()\n    processMutationBatch(pendingMutations)\n    pendingMutations = []\n  }\n\n  return {\n    addMutations: (mutations: RumMutationRecord[]) => {\n      if (pendingMutations.length === 0) {\n        cancelScheduledFlush = requestIdleCallback(flush, { timeout: MUTATION_PROCESS_MAX_DELAY })\n      }\n      pendingMutations.push(...mutations)\n    },\n\n    flush,\n\n    stop: () => {\n      cancelScheduledFlush()\n    },\n  }\n}\n","import { monitor, noop } from '@datadog/browser-core'\nimport type { RumConfiguration } from '@datadog/browser-rum-core'\nimport { getMutationObserverConstructor } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../constants'\nimport type { AddedNodeMutation, AttributeMutation, RemovedNodeMutation, TextMutation } from '../../types'\nimport { getNodePrivacyLevel, getTextContent } from './privacy'\nimport type { NodeWithSerializedNode } from './serializationUtils'\nimport {\n  getElementInputValue,\n  getSerializedNodeId,\n  hasSerializedNode,\n  nodeAndAncestorsHaveSerializedNode,\n} from './serializationUtils'\nimport { serializeNodeWithId, serializeAttribute, SerializationContextStatus } from './serialize'\nimport { forEach } from './utils'\nimport { createMutationBatch } from './mutationBatch'\nimport type { MutationCallBack } from './observers'\n\ntype WithSerializedTarget<T> = T & { target: NodeWithSerializedNode }\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\ninterface RumCharacterDataMutationRecord {\n  type: 'characterData'\n  target: Node\n  oldValue: string | null\n}\n\ninterface RumAttributesMutationRecord {\n  type: 'attributes'\n  target: Element\n  oldValue: string | null\n  attributeName: string | null\n}\n\ninterface RumChildListMutationRecord {\n  type: 'childList'\n  target: Node\n  addedNodes: NodeList\n  removedNodes: NodeList\n}\n\nexport type RumMutationRecord =\n  | RumCharacterDataMutationRecord\n  | RumAttributesMutationRecord\n  | RumChildListMutationRecord\n\n/**\n * Buffers and aggregate mutations generated by a MutationObserver into MutationPayload\n */\nexport function startMutationObserver(\n  controller: MutationController,\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration\n) {\n  const MutationObserver = getMutationObserverConstructor()\n  if (!MutationObserver) {\n    return { stop: noop }\n  }\n  const mutationBatch = createMutationBatch((mutations) => {\n    processMutations(mutations.concat(observer.takeRecords() as RumMutationRecord[]), mutationCallback, configuration)\n  })\n\n  const observer = new MutationObserver(monitor(mutationBatch.addMutations) as (callback: MutationRecord[]) => void)\n\n  observer.observe(document, {\n    attributeOldValue: true,\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  })\n  controller.onFlush(mutationBatch.flush)\n\n  return {\n    stop: () => {\n      observer.disconnect()\n      mutationBatch.stop()\n    },\n  }\n}\n\n/**\n * Controls how mutations are processed, allowing to flush pending mutations.\n */\nexport class MutationController {\n  private flushListener?: () => void\n\n  public flush() {\n    this.flushListener?.()\n  }\n\n  public onFlush(listener: () => void) {\n    this.flushListener = listener\n  }\n}\n\nfunction processMutations(\n  mutations: RumMutationRecord[],\n  mutationCallback: MutationCallBack,\n  configuration: RumConfiguration\n) {\n  // Discard any mutation with a 'target' node that:\n  // * isn't injected in the current document or isn't known/serialized yet: those nodes are likely\n  // part of a mutation occurring in a parent Node\n  // * should be hidden or ignored\n  const filteredMutations = mutations.filter(\n    (mutation): mutation is WithSerializedTarget<RumMutationRecord> =>\n      document.contains(mutation.target) &&\n      nodeAndAncestorsHaveSerializedNode(mutation.target) &&\n      getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel) !== NodePrivacyLevel.HIDDEN\n  )\n\n  const { adds, removes, hasBeenSerialized } = processChildListMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumChildListMutationRecord> => mutation.type === 'childList'\n    ),\n    configuration\n  )\n\n  const texts = processCharacterDataMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumCharacterDataMutationRecord> =>\n        mutation.type === 'characterData' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration\n  )\n\n  const attributes = processAttributesMutations(\n    filteredMutations.filter(\n      (mutation): mutation is WithSerializedTarget<RumAttributesMutationRecord> =>\n        mutation.type === 'attributes' && !hasBeenSerialized(mutation.target)\n    ),\n    configuration\n  )\n\n  if (!texts.length && !attributes.length && !removes.length && !adds.length) {\n    return\n  }\n\n  mutationCallback({\n    adds,\n    removes,\n    texts,\n    attributes,\n  })\n}\n\nfunction processChildListMutations(\n  mutations: Array<WithSerializedTarget<RumChildListMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  // First, we iterate over mutations to collect:\n  //\n  // * nodes that have been added in the document and not removed by a subsequent mutation\n  // * nodes that have been removed from the document but were not added in a previous mutation\n  //\n  // For this second category, we also collect their previous parent (mutation.target) because we'll\n  // need it to emit a 'remove' mutation.\n  //\n  // Those two categories may overlap: if a node moved from a position to another, it is reported as\n  // two mutation records, one with a \"removedNodes\" and the other with \"addedNodes\". In this case,\n  // the node will be in both sets.\n  const addedAndMovedNodes = new Set<Node>()\n  const removedNodes = new Map<Node, NodeWithSerializedNode>()\n  for (const mutation of mutations) {\n    forEach(mutation.addedNodes, (node) => {\n      addedAndMovedNodes.add(node)\n    })\n    forEach(mutation.removedNodes, (node) => {\n      if (!addedAndMovedNodes.has(node)) {\n        removedNodes.set(node, mutation.target)\n      }\n      addedAndMovedNodes.delete(node)\n    })\n  }\n\n  // Then, we sort nodes that are still in the document by topological order, for two reasons:\n  //\n  // * We will serialize each added nodes with their descendants. We don't want to serialize a node\n  // twice, so we need to iterate over the parent nodes first and skip any node that is contained in\n  // a precedent node.\n  //\n  // * To emit \"add\" mutations, we need references to the parent and potential next sibling of each\n  // added node. So we need to iterate over the parent nodes first, and when multiple nodes are\n  // siblings, we want to iterate from last to first. This will ensure that any \"next\" node is\n  // already serialized and have an id.\n  const sortedAddedAndMovedNodes = Array.from(addedAndMovedNodes)\n  sortAddedAndMovedNodes(sortedAddedAndMovedNodes)\n\n  // Then, we iterate over our sorted node sets to emit mutations. We collect the newly serialized\n  // node ids in a set to be able to skip subsequent related mutations.\n  const serializedNodeIds = new Set<number>()\n\n  const addedNodeMutations: AddedNodeMutation[] = []\n  for (const node of sortedAddedAndMovedNodes) {\n    if (hasBeenSerialized(node)) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(node.parentNode!, configuration.defaultPrivacyLevel)\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    const serializedNode = serializeNodeWithId(node, {\n      serializedNodeIds,\n      parentNodePrivacyLevel,\n      serializationContext: { status: SerializationContextStatus.MUTATION },\n      configuration,\n    })\n    if (!serializedNode) {\n      continue\n    }\n\n    addedNodeMutations.push({\n      nextId: getNextSibling(node),\n      parentId: getSerializedNodeId(node.parentNode!)!,\n      node: serializedNode,\n    })\n  }\n  // Finally, we emit remove mutations.\n  const removedNodeMutations: RemovedNodeMutation[] = []\n  removedNodes.forEach((parent, node) => {\n    if (hasSerializedNode(node)) {\n      removedNodeMutations.push({\n        parentId: getSerializedNodeId(parent),\n        id: getSerializedNodeId(node),\n      })\n    }\n  })\n\n  return { adds: addedNodeMutations, removes: removedNodeMutations, hasBeenSerialized }\n\n  function hasBeenSerialized(node: Node) {\n    return hasSerializedNode(node) && serializedNodeIds.has(getSerializedNodeId(node))\n  }\n\n  function getNextSibling(node: Node): null | number {\n    let nextSibling = node.nextSibling\n    while (nextSibling) {\n      if (hasSerializedNode(nextSibling)) {\n        return getSerializedNodeId(nextSibling)\n      }\n      nextSibling = nextSibling.nextSibling\n    }\n\n    return null\n  }\n}\n\nfunction processCharacterDataMutations(\n  mutations: Array<WithSerializedTarget<RumCharacterDataMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  const textMutations: TextMutation[] = []\n\n  // Deduplicate mutations based on their target node\n  const handledNodes = new Set<Node>()\n  const filteredMutations = mutations.filter((mutation) => {\n    if (handledNodes.has(mutation.target)) {\n      return false\n    }\n    handledNodes.add(mutation.target)\n    return true\n  })\n\n  // Emit mutations\n  for (const mutation of filteredMutations) {\n    const value = mutation.target.textContent\n    if (value === mutation.oldValue) {\n      continue\n    }\n\n    const parentNodePrivacyLevel = getNodePrivacyLevel(mutation.target.parentNode!, configuration.defaultPrivacyLevel)\n    if (parentNodePrivacyLevel === NodePrivacyLevel.HIDDEN || parentNodePrivacyLevel === NodePrivacyLevel.IGNORE) {\n      continue\n    }\n\n    textMutations.push({\n      id: getSerializedNodeId(mutation.target),\n      // TODO: pass a valid \"ignoreWhiteSpace\" argument\n      value: getTextContent(mutation.target, false, parentNodePrivacyLevel) ?? null,\n    })\n  }\n\n  return textMutations\n}\n\nfunction processAttributesMutations(\n  mutations: Array<WithSerializedTarget<RumAttributesMutationRecord>>,\n  configuration: RumConfiguration\n) {\n  const attributeMutations: AttributeMutation[] = []\n\n  // Deduplicate mutations based on their target node and changed attribute\n  const handledElements = new Map<Element, Set<string>>()\n  const filteredMutations = mutations.filter((mutation) => {\n    const handledAttributes = handledElements.get(mutation.target)\n    if (handledAttributes?.has(mutation.attributeName!)) {\n      return false\n    }\n    if (!handledAttributes) {\n      handledElements.set(mutation.target, new Set([mutation.attributeName!]))\n    } else {\n      handledAttributes.add(mutation.attributeName!)\n    }\n    return true\n  })\n\n  // Emit mutations\n  const emittedMutations = new Map<Element, AttributeMutation>()\n  for (const mutation of filteredMutations) {\n    const uncensoredValue = mutation.target.getAttribute(mutation.attributeName!)\n    if (uncensoredValue === mutation.oldValue) {\n      continue\n    }\n    const privacyLevel = getNodePrivacyLevel(mutation.target, configuration.defaultPrivacyLevel)\n    const attributeValue = serializeAttribute(mutation.target, privacyLevel, mutation.attributeName!, configuration)\n\n    let transformedValue: string | null\n    if (mutation.attributeName === 'value') {\n      const inputValue = getElementInputValue(mutation.target, privacyLevel)\n      if (inputValue === undefined) {\n        continue\n      }\n      transformedValue = inputValue\n    } else if (typeof attributeValue === 'string') {\n      transformedValue = attributeValue\n    } else {\n      transformedValue = null\n    }\n\n    let emittedMutation = emittedMutations.get(mutation.target)\n    if (!emittedMutation) {\n      emittedMutation = {\n        id: getSerializedNodeId(mutation.target),\n        attributes: {},\n      }\n      attributeMutations.push(emittedMutation)\n      emittedMutations.set(mutation.target, emittedMutation)\n    }\n\n    emittedMutation.attributes[mutation.attributeName!] = transformedValue\n  }\n\n  return attributeMutations\n}\n\nexport function sortAddedAndMovedNodes(nodes: Node[]) {\n  nodes.sort((a, b) => {\n    const position = a.compareDocumentPosition(b)\n    /* eslint-disable no-bitwise */\n    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      return -1\n    } else if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return 1\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return -1\n    }\n    /* eslint-enable no-bitwise */\n    return 0\n  })\n}\n","/**\n * Browsers have not standardized various dimension properties. Mobile devices typically report\n * dimensions in reference to the visual viewport, while desktop uses the layout viewport. For example,\n * Mobile Chrome will change innerWidth when a pinch zoom takes place, while Chrome Desktop (mac) will not.\n *\n * With the new Viewport API, we now calculate and normalize dimension properties to the layout viewport.\n * If the VisualViewport API is not supported by a browser, it isn't reasonably possible to detect or normalize\n * which viewport is being measured. Therefore these exported functions will fallback to assuming that the layout\n * viewport is being measured by the browser\n */\n\nimport type { VisualViewportRecord } from '../../types'\n\n// Scrollbar widths vary across properties on different devices and browsers\nconst TOLERANCE = 25\n\n/**\n * Use the Visual Viewport API's properties to measure scrollX/Y in reference to the layout viewport\n * in order to determine if window.scrollX/Y is measuring the layout or visual viewport.\n * This finding corresponds to which viewport mouseEvent.clientX/Y and window.innerWidth/Height measures.\n */\nfunction isVisualViewportFactoredIn() {\n  const visual = window.visualViewport\n  return (\n    Math.abs(visual.pageTop - visual.offsetTop - window.scrollY) > TOLERANCE ||\n    Math.abs(visual.pageLeft - visual.offsetLeft - window.scrollX) > TOLERANCE\n  )\n}\n\ninterface LayoutCoordinates {\n  layoutViewportX: number\n  layoutViewportY: number\n  visualViewportX: number\n  visualViewportY: number\n}\n\nexport const convertMouseEventToLayoutCoordinates = (clientX: number, clientY: number): LayoutCoordinates => {\n  const visual = window.visualViewport\n  const normalised: LayoutCoordinates = {\n    layoutViewportX: clientX,\n    layoutViewportY: clientY,\n    visualViewportX: clientX,\n    visualViewportY: clientY,\n  }\n\n  if (!visual) {\n    // On old browsers, we cannot normalise, so fallback to clientX/Y\n    return normalised\n  } else if (isVisualViewportFactoredIn()) {\n    // Typically Mobile Devices\n    normalised.layoutViewportX = Math.round(clientX + visual.offsetLeft)\n    normalised.layoutViewportY = Math.round(clientY + visual.offsetTop)\n  } else {\n    // Typically Desktop Devices\n    normalised.visualViewportX = Math.round(clientX - visual.offsetLeft)\n    normalised.visualViewportY = Math.round(clientY - visual.offsetTop)\n  }\n  return normalised\n}\n\nexport const getVisualViewport = (): VisualViewportRecord['data'] => {\n  const visual = window.visualViewport\n  return {\n    scale: visual.scale,\n    offsetLeft: visual.offsetLeft,\n    offsetTop: visual.offsetTop,\n    pageLeft: visual.pageLeft,\n    pageTop: visual.pageTop,\n    height: visual.height,\n    width: visual.width,\n  }\n}\n\nexport function getScrollX() {\n  let scrollX\n  const visual = window.visualViewport\n  if (visual) {\n    scrollX = visual.pageLeft - visual.offsetLeft\n  } else if (window.scrollX !== undefined) {\n    scrollX = window.scrollX\n  } else {\n    scrollX = window.pageXOffset || 0\n  }\n  return Math.round(scrollX)\n}\n\nexport function getScrollY() {\n  let scrollY\n  const visual = window.visualViewport\n  if (visual) {\n    scrollY = visual.pageTop - visual.offsetTop\n  } else if (window.scrollY !== undefined) {\n    scrollY = window.scrollY\n  } else {\n    scrollY = window.pageYOffset || 0\n  }\n  return Math.round(scrollY)\n}\n","import type { DefaultPrivacyLevel } from '@datadog/browser-core'\nimport {\n  instrumentSetter,\n  instrumentMethodAndCallOriginal,\n  assign,\n  monitor,\n  throttle,\n  DOM_EVENT,\n  addEventListeners,\n  addEventListener,\n  noop,\n} from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration } from '@datadog/browser-rum-core'\nimport { initViewportObservable, ActionType, RumEventType, LifeCycleEventType } from '@datadog/browser-rum-core'\nimport { NodePrivacyLevel } from '../../constants'\nimport type {\n  InputState,\n  MousePosition,\n  MouseInteraction,\n  BrowserMutationPayload,\n  ScrollPosition,\n  StyleSheetRule,\n  ViewportResizeDimension,\n  MediaInteraction,\n  FocusRecord,\n  VisualViewportRecord,\n  FrustrationRecord,\n  BrowserIncrementalSnapshotRecord,\n  MouseInteractionData,\n} from '../../types'\nimport { RecordType, IncrementalSource, MediaInteractionType, MouseInteractionType } from '../../types'\nimport { getNodePrivacyLevel, shouldMaskNode } from './privacy'\nimport { getElementInputValue, getSerializedNodeId, hasSerializedNode } from './serializationUtils'\nimport { assembleIncrementalSnapshot, forEach, getPathToNestedCSSRule, isTouchEvent } from './utils'\nimport type { MutationController } from './mutationObserver'\nimport { startMutationObserver } from './mutationObserver'\nimport { getVisualViewport, getScrollX, getScrollY, convertMouseEventToLayoutCoordinates } from './viewports'\nimport type { ElementsScrollPositions } from './elementsScrollPositions'\n\nconst MOUSE_MOVE_OBSERVER_THRESHOLD = 50\nconst SCROLL_OBSERVER_THRESHOLD = 100\nconst VISUAL_VIEWPORT_OBSERVER_THRESHOLD = 200\n\nconst recordIds = new WeakMap<Event, number>()\nlet nextId = 1\n\nfunction getRecordIdForEvent(event: Event): number {\n  if (!recordIds.has(event)) {\n    recordIds.set(event, nextId++)\n  }\n  return recordIds.get(event)!\n}\n\ntype GroupingCSSRuleTypes = typeof CSSGroupingRule | typeof CSSMediaRule | typeof CSSSupportsRule\n\ntype ListenerHandler = () => void\n\ntype MousemoveCallBack = (\n  p: MousePosition[],\n  source: typeof IncrementalSource.MouseMove | typeof IncrementalSource.TouchMove\n) => void\n\nexport type MutationCallBack = (m: BrowserMutationPayload) => void\n\ntype MouseInteractionCallBack = (record: BrowserIncrementalSnapshotRecord) => void\n\ntype ScrollCallback = (p: ScrollPosition) => void\n\nexport type StyleSheetCallback = (s: StyleSheetRule) => void\n\ntype ViewportResizeCallback = (d: ViewportResizeDimension) => void\n\nexport type InputCallback = (v: InputState & { id: number }) => void\n\ntype MediaInteractionCallback = (p: MediaInteraction) => void\n\ntype FocusCallback = (data: FocusRecord['data']) => void\n\ntype VisualViewportResizeCallback = (data: VisualViewportRecord['data']) => void\n\nexport type FrustrationCallback = (record: FrustrationRecord) => void\n\ninterface ObserverParam {\n  lifeCycle: LifeCycle\n  configuration: RumConfiguration\n  mutationController: MutationController\n  elementsScrollPositions: ElementsScrollPositions\n  mutationCb: MutationCallBack\n  mousemoveCb: MousemoveCallBack\n  mouseInteractionCb: MouseInteractionCallBack\n  scrollCb: ScrollCallback\n  viewportResizeCb: ViewportResizeCallback\n  visualViewportResizeCb: VisualViewportResizeCallback\n  inputCb: InputCallback\n  mediaInteractionCb: MediaInteractionCallback\n  styleSheetCb: StyleSheetCallback\n  focusCb: FocusCallback\n  frustrationCb: FrustrationCallback\n}\n\nexport function initObservers(o: ObserverParam): ListenerHandler {\n  const mutationHandler = initMutationObserver(o.mutationController, o.mutationCb, o.configuration)\n  const mousemoveHandler = initMoveObserver(o.mousemoveCb)\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.configuration.defaultPrivacyLevel\n  )\n  const scrollHandler = initScrollObserver(o.scrollCb, o.configuration.defaultPrivacyLevel, o.elementsScrollPositions)\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb)\n  const inputHandler = initInputObserver(o.inputCb, o.configuration.defaultPrivacyLevel)\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    o.mediaInteractionCb,\n    o.configuration.defaultPrivacyLevel\n  )\n  const styleSheetObserver = initStyleSheetObserver(o.styleSheetCb)\n  const focusHandler = initFocusObserver(o.focusCb)\n  const visualViewportResizeHandler = initVisualViewportResizeObserver(o.visualViewportResizeCb)\n  const frustrationHandler = initFrustrationObserver(o.lifeCycle, o.frustrationCb)\n\n  return () => {\n    mutationHandler()\n    mousemoveHandler()\n    mouseInteractionHandler()\n    scrollHandler()\n    viewportResizeHandler()\n    inputHandler()\n    mediaInteractionHandler()\n    styleSheetObserver()\n    focusHandler()\n    visualViewportResizeHandler()\n    frustrationHandler()\n  }\n}\n\nfunction initMutationObserver(\n  mutationController: MutationController,\n  cb: MutationCallBack,\n  configuration: RumConfiguration\n) {\n  return startMutationObserver(mutationController, cb, configuration).stop\n}\n\nfunction initMoveObserver(cb: MousemoveCallBack): ListenerHandler {\n  const { throttled: updatePosition } = throttle(\n    monitor((event: MouseEvent | TouchEvent) => {\n      const target = event.target as Node\n      if (hasSerializedNode(target)) {\n        const { clientX, clientY } = isTouchEvent(event) ? event.changedTouches[0] : event\n        const position: MousePosition = {\n          id: getSerializedNodeId(target),\n          timeOffset: 0,\n          x: clientX,\n          y: clientY,\n        }\n        if (window.visualViewport) {\n          const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(clientX, clientY)\n          position.x = visualViewportX\n          position.y = visualViewportY\n        }\n        cb([position], isTouchEvent(event) ? IncrementalSource.TouchMove : IncrementalSource.MouseMove)\n      }\n    }),\n    MOUSE_MOVE_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n\n  return addEventListeners(document, [DOM_EVENT.MOUSE_MOVE, DOM_EVENT.TOUCH_MOVE], updatePosition, {\n    capture: true,\n    passive: true,\n  }).stop\n}\n\nconst eventTypeToMouseInteraction = {\n  [DOM_EVENT.MOUSE_UP]: MouseInteractionType.MouseUp,\n  [DOM_EVENT.MOUSE_DOWN]: MouseInteractionType.MouseDown,\n  [DOM_EVENT.CLICK]: MouseInteractionType.Click,\n  [DOM_EVENT.CONTEXT_MENU]: MouseInteractionType.ContextMenu,\n  [DOM_EVENT.DBL_CLICK]: MouseInteractionType.DblClick,\n  [DOM_EVENT.FOCUS]: MouseInteractionType.Focus,\n  [DOM_EVENT.BLUR]: MouseInteractionType.Blur,\n  [DOM_EVENT.TOUCH_START]: MouseInteractionType.TouchStart,\n  [DOM_EVENT.TOUCH_END]: MouseInteractionType.TouchEnd,\n}\nfunction initMouseInteractionObserver(\n  cb: MouseInteractionCallBack,\n  defaultPrivacyLevel: DefaultPrivacyLevel\n): ListenerHandler {\n  const handler = (event: MouseEvent | TouchEvent) => {\n    const target = event.target as Node\n    if (getNodePrivacyLevel(target, defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN || !hasSerializedNode(target)) {\n      return\n    }\n    const { clientX, clientY } = isTouchEvent(event) ? event.changedTouches[0] : event\n    const position: MouseInteraction = {\n      id: getSerializedNodeId(target),\n      type: eventTypeToMouseInteraction[event.type as keyof typeof eventTypeToMouseInteraction],\n      x: clientX,\n      y: clientY,\n    }\n    if (window.visualViewport) {\n      const { visualViewportX, visualViewportY } = convertMouseEventToLayoutCoordinates(clientX, clientY)\n      position.x = visualViewportX\n      position.y = visualViewportY\n    }\n\n    const record = assign(\n      { id: getRecordIdForEvent(event) },\n      assembleIncrementalSnapshot<MouseInteractionData>(IncrementalSource.MouseInteraction, position)\n    )\n    cb(record)\n  }\n  return addEventListeners(document, Object.keys(eventTypeToMouseInteraction) as DOM_EVENT[], handler, {\n    capture: true,\n    passive: true,\n  }).stop\n}\n\nfunction initScrollObserver(\n  cb: ScrollCallback,\n  defaultPrivacyLevel: DefaultPrivacyLevel,\n  elementsScrollPositions: ElementsScrollPositions\n): ListenerHandler {\n  const { throttled: updatePosition } = throttle(\n    monitor((event: UIEvent) => {\n      const target = event.target as HTMLElement | Document\n      if (\n        !target ||\n        getNodePrivacyLevel(target, defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n        !hasSerializedNode(target)\n      ) {\n        return\n      }\n      const id = getSerializedNodeId(target)\n      const scrollPositions =\n        target === document\n          ? {\n              scrollTop: getScrollY(),\n              scrollLeft: getScrollX(),\n            }\n          : {\n              scrollTop: Math.round((target as HTMLElement).scrollTop),\n              scrollLeft: Math.round((target as HTMLElement).scrollLeft),\n            }\n      elementsScrollPositions.set(target, scrollPositions)\n      cb({\n        id,\n        x: scrollPositions.scrollLeft,\n        y: scrollPositions.scrollTop,\n      })\n    }),\n    SCROLL_OBSERVER_THRESHOLD\n  )\n  return addEventListener(document, DOM_EVENT.SCROLL, updatePosition, { capture: true, passive: true }).stop\n}\n\nfunction initViewportResizeObserver(cb: ViewportResizeCallback): ListenerHandler {\n  return initViewportObservable().subscribe(cb).unsubscribe\n}\n\nexport function initInputObserver(cb: InputCallback, defaultPrivacyLevel: DefaultPrivacyLevel): ListenerHandler {\n  const lastInputStateMap: WeakMap<Node, InputState> = new WeakMap()\n\n  function onElementChange(target: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement) {\n    const nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel)\n    if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {\n      return\n    }\n\n    const type = target.type\n\n    let inputState: InputState\n    if (type === 'radio' || type === 'checkbox') {\n      if (shouldMaskNode(target, nodePrivacyLevel)) {\n        return\n      }\n      inputState = { isChecked: (target as HTMLInputElement).checked }\n    } else {\n      const value = getElementInputValue(target, nodePrivacyLevel)\n      if (value === undefined) {\n        return\n      }\n      inputState = { text: value }\n    }\n\n    // Can be multiple changes on the same node within the same batched mutation observation.\n    cbWithDedup(target, inputState)\n\n    // If a radio was checked, other radios with the same name attribute will be unchecked.\n    const name = target.name\n    if (type === 'radio' && name && (target as HTMLInputElement).checked) {\n      forEach(document.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`), (el: Element) => {\n        if (el !== target) {\n          // TODO: Consider the privacy implications for various differing input privacy levels\n          cbWithDedup(el, { isChecked: false })\n        }\n      })\n    }\n  }\n\n  /**\n   * There can be multiple changes on the same node within the same batched mutation observation.\n   */\n  function cbWithDedup(target: Node, inputState: InputState) {\n    if (!hasSerializedNode(target)) {\n      return\n    }\n    const lastInputState = lastInputStateMap.get(target)\n    if (\n      !lastInputState ||\n      (lastInputState as { text?: string }).text !== (inputState as { text?: string }).text ||\n      (lastInputState as { isChecked?: boolean }).isChecked !== (inputState as { isChecked?: boolean }).isChecked\n    ) {\n      lastInputStateMap.set(target, inputState)\n      cb(\n        assign(\n          {\n            id: getSerializedNodeId(target),\n          },\n          inputState\n        )\n      )\n    }\n  }\n\n  const { stop: stopEventListeners } = addEventListeners(\n    document,\n    [DOM_EVENT.INPUT, DOM_EVENT.CHANGE],\n    (event) => {\n      if (\n        event.target instanceof HTMLInputElement ||\n        event.target instanceof HTMLTextAreaElement ||\n        event.target instanceof HTMLSelectElement\n      ) {\n        onElementChange(event.target)\n      }\n    },\n    {\n      capture: true,\n      passive: true,\n    }\n  )\n\n  const instrumentationStoppers = [\n    instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),\n    instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),\n    instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),\n    instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),\n    instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),\n  ]\n\n  return () => {\n    instrumentationStoppers.forEach((stopper) => stopper.stop())\n    stopEventListeners()\n  }\n}\n\nexport function initStyleSheetObserver(cb: StyleSheetCallback): ListenerHandler {\n  function checkStyleSheetAndCallback(styleSheet: CSSStyleSheet | null, callback: (id: number) => void): void {\n    if (styleSheet && hasSerializedNode(styleSheet.ownerNode!)) {\n      callback(getSerializedNodeId(styleSheet.ownerNode))\n    }\n  }\n\n  const instrumentationStoppers = [\n    instrumentMethodAndCallOriginal(CSSStyleSheet.prototype, 'insertRule', {\n      before(rule, index) {\n        checkStyleSheetAndCallback(this, (id) => cb({ id, adds: [{ rule, index }] }))\n      },\n    }),\n    instrumentMethodAndCallOriginal(CSSStyleSheet.prototype, 'deleteRule', {\n      before(index) {\n        checkStyleSheetAndCallback(this, (id) => cb({ id, removes: [{ index }] }))\n      },\n    }),\n  ]\n\n  if (typeof CSSGroupingRule !== 'undefined') {\n    instrumentGroupingCSSRuleClass(CSSGroupingRule)\n  } else {\n    instrumentGroupingCSSRuleClass(CSSMediaRule)\n    instrumentGroupingCSSRuleClass(CSSSupportsRule)\n  }\n\n  function instrumentGroupingCSSRuleClass(cls: GroupingCSSRuleTypes) {\n    instrumentationStoppers.push(\n      instrumentMethodAndCallOriginal(cls.prototype, 'insertRule', {\n        before(rule, index) {\n          checkStyleSheetAndCallback(this.parentStyleSheet, (id) => {\n            const path = getPathToNestedCSSRule(this)\n            if (path) {\n              path.push(index || 0)\n              cb({ id, adds: [{ rule, index: path }] })\n            }\n          })\n        },\n      }),\n      instrumentMethodAndCallOriginal(cls.prototype, 'deleteRule', {\n        before(index) {\n          checkStyleSheetAndCallback(this.parentStyleSheet, (id) => {\n            const path = getPathToNestedCSSRule(this)\n            if (path) {\n              path.push(index)\n              cb({ id, removes: [{ index: path }] })\n            }\n          })\n        },\n      })\n    )\n  }\n\n  return () => instrumentationStoppers.forEach((stopper) => stopper.stop())\n}\n\nfunction initMediaInteractionObserver(\n  mediaInteractionCb: MediaInteractionCallback,\n  defaultPrivacyLevel: DefaultPrivacyLevel\n): ListenerHandler {\n  const handler = (event: Event) => {\n    const target = event.target as Node\n    if (\n      !target ||\n      getNodePrivacyLevel(target, defaultPrivacyLevel) === NodePrivacyLevel.HIDDEN ||\n      !hasSerializedNode(target)\n    ) {\n      return\n    }\n    mediaInteractionCb({\n      id: getSerializedNodeId(target),\n      type: event.type === DOM_EVENT.PLAY ? MediaInteractionType.Play : MediaInteractionType.Pause,\n    })\n  }\n  return addEventListeners(document, [DOM_EVENT.PLAY, DOM_EVENT.PAUSE], handler, { capture: true, passive: true }).stop\n}\n\nfunction initFocusObserver(focusCb: FocusCallback): ListenerHandler {\n  return addEventListeners(window, [DOM_EVENT.FOCUS, DOM_EVENT.BLUR], () => {\n    focusCb({ has_focus: document.hasFocus() })\n  }).stop\n}\n\nfunction initVisualViewportResizeObserver(cb: VisualViewportResizeCallback): ListenerHandler {\n  if (!window.visualViewport) {\n    return noop\n  }\n  const { throttled: updateDimension, cancel: cancelThrottle } = throttle(\n    monitor(() => {\n      cb(getVisualViewport())\n    }),\n    VISUAL_VIEWPORT_OBSERVER_THRESHOLD,\n    {\n      trailing: false,\n    }\n  )\n  const removeListener = addEventListeners(\n    window.visualViewport,\n    [DOM_EVENT.RESIZE, DOM_EVENT.SCROLL],\n    updateDimension,\n    {\n      capture: true,\n      passive: true,\n    }\n  ).stop\n\n  return function stop() {\n    removeListener()\n    cancelThrottle()\n  }\n}\n\nexport function initFrustrationObserver(lifeCycle: LifeCycle, frustrationCb: FrustrationCallback): ListenerHandler {\n  return lifeCycle.subscribe(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, (data) => {\n    if (\n      data.rawRumEvent.type === RumEventType.ACTION &&\n      data.rawRumEvent.action.type === ActionType.CLICK &&\n      data.rawRumEvent.action.frustration?.type?.length &&\n      'events' in data.domainContext &&\n      data.domainContext.events?.length\n    ) {\n      frustrationCb({\n        timestamp: data.rawRumEvent.date,\n        type: RecordType.FrustrationRecord,\n        data: {\n          frustrationTypes: data.rawRumEvent.action.frustration.type,\n          recordIds: data.domainContext.events.map((e) => getRecordIdForEvent(e)),\n        },\n      })\n    }\n  }).unsubscribe\n}\n","import type { TimeStamp } from '@datadog/browser-core'\nimport { timeStampNow } from '@datadog/browser-core'\nimport type { LifeCycle, RumConfiguration } from '@datadog/browser-rum-core'\nimport { getViewportDimension } from '@datadog/browser-rum-core'\nimport type {\n  BrowserMutationData,\n  BrowserRecord,\n  InputData,\n  MediaInteractionData,\n  MousemoveData,\n  ScrollData,\n  StyleSheetRuleData,\n  ViewportResizeData,\n} from '../../types'\nimport { RecordType, IncrementalSource } from '../../types'\nimport { serializeDocument, SerializationContextStatus } from './serialize'\nimport { initObservers } from './observers'\n\nimport { MutationController } from './mutationObserver'\nimport { getVisualViewport, getScrollX, getScrollY } from './viewports'\nimport { assembleIncrementalSnapshot } from './utils'\nimport { createElementsScrollPositions } from './elementsScrollPositions'\n\nexport interface RecordOptions {\n  emit?: (record: BrowserRecord) => void\n  configuration: RumConfiguration\n  lifeCycle: LifeCycle\n}\n\nexport interface RecordAPI {\n  stop: () => void\n  takeSubsequentFullSnapshot: (timestamp?: TimeStamp) => void\n  flushMutations: () => void\n}\n\nexport function record(options: RecordOptions): RecordAPI {\n  const { emit } = options\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required')\n  }\n\n  const mutationController = new MutationController()\n  const elementsScrollPositions = createElementsScrollPositions()\n\n  const takeFullSnapshot = (\n    timestamp = timeStampNow(),\n    serializationContext = { status: SerializationContextStatus.INITIAL_FULL_SNAPSHOT, elementsScrollPositions }\n  ) => {\n    mutationController.flush() // process any pending mutation before taking a full snapshot\n    const { width, height } = getViewportDimension()\n    emit({\n      data: {\n        height,\n        href: window.location.href,\n        width,\n      },\n      type: RecordType.Meta,\n      timestamp,\n    })\n\n    emit({\n      data: {\n        has_focus: document.hasFocus(),\n      },\n      type: RecordType.Focus,\n      timestamp,\n    })\n\n    emit({\n      data: {\n        node: serializeDocument(document, options.configuration, serializationContext),\n        initialOffset: {\n          left: getScrollX(),\n          top: getScrollY(),\n        },\n      },\n      type: RecordType.FullSnapshot,\n      timestamp,\n    })\n\n    if (window.visualViewport) {\n      emit({\n        data: getVisualViewport(),\n        type: RecordType.VisualViewport,\n        timestamp,\n      })\n    }\n  }\n\n  takeFullSnapshot()\n\n  const stopObservers = initObservers({\n    lifeCycle: options.lifeCycle,\n    configuration: options.configuration,\n    mutationController,\n    elementsScrollPositions,\n    inputCb: (v) => emit(assembleIncrementalSnapshot<InputData>(IncrementalSource.Input, v)),\n    mediaInteractionCb: (p) =>\n      emit(assembleIncrementalSnapshot<MediaInteractionData>(IncrementalSource.MediaInteraction, p)),\n    mouseInteractionCb: (mouseInteractionRecord) => emit(mouseInteractionRecord),\n    mousemoveCb: (positions, source) => emit(assembleIncrementalSnapshot<MousemoveData>(source, { positions })),\n    mutationCb: (m) => emit(assembleIncrementalSnapshot<BrowserMutationData>(IncrementalSource.Mutation, m)),\n    scrollCb: (p) => emit(assembleIncrementalSnapshot<ScrollData>(IncrementalSource.Scroll, p)),\n    styleSheetCb: (r) => emit(assembleIncrementalSnapshot<StyleSheetRuleData>(IncrementalSource.StyleSheetRule, r)),\n    viewportResizeCb: (d) => emit(assembleIncrementalSnapshot<ViewportResizeData>(IncrementalSource.ViewportResize, d)),\n\n    frustrationCb: (frustrationRecord) => emit(frustrationRecord),\n    focusCb: (data) =>\n      emit({\n        data,\n        type: RecordType.Focus,\n        timestamp: timeStampNow(),\n      }),\n    visualViewportResizeCb: (data) => {\n      emit({\n        data,\n        type: RecordType.VisualViewport,\n        timestamp: timeStampNow(),\n      })\n    },\n  })\n\n  return {\n    stop: stopObservers,\n    takeSubsequentFullSnapshot: (timestamp) =>\n      takeFullSnapshot(timestamp, {\n        status: SerializationContextStatus.SUBSEQUENT_FULL_SNAPSHOT,\n        elementsScrollPositions,\n      }),\n    flushMutations: () => mutationController.flush(),\n  }\n}\n","export type ElementsScrollPositions = ReturnType<typeof createElementsScrollPositions>\nexport type ScrollPositions = { scrollLeft: number; scrollTop: number }\n\nexport function createElementsScrollPositions() {\n  const scrollPositionsByElement = new WeakMap<Element, ScrollPositions>()\n  return {\n    set(element: Element | Document, scrollPositions: ScrollPositions) {\n      if (element === document && !document.scrollingElement) {\n        // cf https://drafts.csswg.org/cssom-view/#dom-document-scrollingelement,\n        // in some cases scrolling elements can not be defined, we don't support those for now\n        return\n      }\n      scrollPositionsByElement.set(\n        element === document ? document.scrollingElement! : (element as Element),\n        scrollPositions\n      )\n    },\n    get(element: Element) {\n      return scrollPositionsByElement.get(element)\n    },\n    has(element: Element) {\n      return scrollPositionsByElement.has(element)\n    },\n  }\n}\n","import type { ReplayStats } from '@datadog/browser-rum-core'\n\nexport const MAX_STATS_HISTORY = 10\nlet statsPerView: Map<string, ReplayStats> | undefined\n\nexport function getSegmentsCount(viewId: string) {\n  return getOrCreateReplayStats(viewId).segments_count\n}\n\nexport function addSegment(viewId: string) {\n  getOrCreateReplayStats(viewId).segments_count += 1\n}\n\nexport function addRecord(viewId: string) {\n  getOrCreateReplayStats(viewId).records_count += 1\n}\n\nexport function addWroteData(viewId: string, additionalBytesCount: number) {\n  getOrCreateReplayStats(viewId).segments_total_raw_size += additionalBytesCount\n}\n\nexport function getReplayStats(viewId: string) {\n  return statsPerView?.get(viewId)\n}\n\nexport function resetReplayStats() {\n  statsPerView = undefined\n}\n\nfunction getOrCreateReplayStats(viewId: string) {\n  if (!statsPerView) {\n    statsPerView = new Map()\n  }\n\n  let replayStats: ReplayStats\n  if (statsPerView.has(viewId)) {\n    replayStats = statsPerView.get(viewId)!\n  } else {\n    replayStats = {\n      records_count: 0,\n      segments_count: 0,\n      segments_total_raw_size: 0,\n    }\n    statsPerView.set(viewId, replayStats)\n    if (statsPerView.size > MAX_STATS_HISTORY) {\n      deleteOldestStats()\n    }\n  }\n\n  return replayStats\n}\n\nfunction deleteOldestStats() {\n  if (!statsPerView) {\n    return\n  }\n  if (statsPerView.keys) {\n    statsPerView.delete(statsPerView.keys().next().value)\n  } else {\n    // IE11 doesn't support map.keys\n    let isFirst = true\n    statsPerView.forEach((_value, key) => {\n      if (isFirst) {\n        statsPerView!.delete(key)\n        isFirst = false\n      }\n    })\n  }\n}\n","import { addTelemetryDebug, assign, monitor } from '@datadog/browser-core'\nimport type { BrowserRecord, BrowserSegmentMetadata, CreationReason, SegmentContext } from '../../types'\nimport { RecordType } from '../../types'\nimport * as replayStats from '../replayStats'\nimport type { DeflateWorker, DeflateWorkerListener } from './deflateWorker'\n\nlet nextId = 0\n\nexport class Segment {\n  public isFlushed = false\n\n  public readonly metadata: BrowserSegmentMetadata\n\n  private id = nextId++\n\n  constructor(\n    private worker: DeflateWorker,\n    context: SegmentContext,\n    creationReason: CreationReason,\n    initialRecord: BrowserRecord,\n    onWrote: (compressedBytesCount: number) => void,\n    onFlushed: (data: Uint8Array, rawBytesCount: number) => void\n  ) {\n    const viewId = context.view.id\n\n    this.metadata = assign(\n      {\n        start: initialRecord.timestamp,\n        end: initialRecord.timestamp,\n        creation_reason: creationReason,\n        records_count: 1,\n        has_full_snapshot: initialRecord.type === RecordType.FullSnapshot,\n        index_in_view: replayStats.getSegmentsCount(viewId),\n        source: 'browser' as const,\n      },\n      context\n    )\n\n    replayStats.addSegment(viewId)\n    replayStats.addRecord(viewId)\n\n    const listener: DeflateWorkerListener = monitor(({ data }) => {\n      if (data.type === 'errored' || data.type === 'initialized') {\n        return\n      }\n\n      if (data.id === this.id) {\n        replayStats.addWroteData(viewId, data.additionalBytesCount)\n        if (data.type === 'flushed') {\n          onFlushed(data.result, data.rawBytesCount)\n          worker.removeEventListener('message', listener)\n        } else {\n          onWrote(data.compressedBytesCount)\n        }\n      } else if (data.id > this.id) {\n        // Messages should be received in the same order as they are sent, so if we receive a\n        // message with an id superior to this Segment instance id, we know that another, more\n        // recent Segment instance is being used.\n        //\n        // In theory, a \"flush\" response should have been received at this point, so the listener\n        // should already have been removed. But if something goes wrong and we didn't receive a\n        // \"flush\" response, remove the listener to avoid any leak, and send a monitor message to\n        // help investigate the issue.\n        worker.removeEventListener('message', listener)\n        addTelemetryDebug(\"Segment did not receive a 'flush' response before being replaced.\")\n      }\n    })\n    worker.addEventListener('message', listener)\n    this.worker.postMessage({ data: `{\"records\":[${JSON.stringify(initialRecord)}`, id: this.id, action: 'write' })\n  }\n\n  addRecord(record: BrowserRecord): void {\n    this.metadata.start = Math.min(this.metadata.start, record.timestamp)\n    this.metadata.end = Math.max(this.metadata.end, record.timestamp)\n    this.metadata.records_count += 1\n    replayStats.addRecord(this.metadata.view.id)\n    this.metadata.has_full_snapshot ||= record.type === RecordType.FullSnapshot\n    this.worker.postMessage({ data: `,${JSON.stringify(record)}`, id: this.id, action: 'write' })\n  }\n\n  flush() {\n    this.worker.postMessage({\n      data: `],${JSON.stringify(this.metadata).slice(1)}\\n`,\n      id: this.id,\n      action: 'flush',\n    })\n    this.isFlushed = true\n  }\n}\n","let workerURL\n\nexport function createDeflateWorker() {\n  // Lazily compute the worker URL to allow importing the SDK in NodeJS\n  if (!workerURL) {\n    workerURL = URL.createObjectURL(new Blob([`(${workerCodeFn})(self)`]))\n  }\n  return new Worker(workerURL)\n}\n\nfunction workerCodeFn() {\n  monitor(function () {\n    const { Deflate, constants, string2buf } = makePakoDeflate()\n\n    let deflate = new Deflate()\n    let rawBytesCount = 0\n    self.addEventListener(\n      'message',\n      monitor((event) => {\n        const data = event.data\n        switch (data.action) {\n          case 'init':\n            self.postMessage({\n              type: 'initialized',\n            })\n            break\n          case 'write': {\n            const additionalBytesCount = pushData(data.data)\n            self.postMessage({\n              type: 'wrote',\n              id: data.id,\n              compressedBytesCount: deflate.chunks.reduce((total, chunk) => total + chunk.length, 0),\n              additionalBytesCount,\n            })\n            break\n          }\n          case 'flush': {\n            const additionalBytesCount = data.data ? pushData(data.data) : 0\n            deflate.push('', constants.Z_FINISH)\n            self.postMessage({\n              type: 'flushed',\n              id: data.id,\n              result: deflate.result,\n              additionalBytesCount,\n              rawBytesCount,\n            })\n            deflate = new Deflate()\n            rawBytesCount = 0\n            break\n          }\n        }\n      })\n    )\n\n    function pushData(data) {\n      // TextEncoder is not supported on old browser version like Edge 18, therefore we use string2buf\n      const binaryData = string2buf(data)\n      deflate.push(binaryData, constants.Z_SYNC_FLUSH)\n      rawBytesCount += binaryData.length\n      return binaryData.length\n    }\n  })()\n\n  function monitor(fn) {\n    return function () {\n      try {\n        return fn.apply(this, arguments)\n      } catch (e) {\n        try {\n          self.postMessage({\n            type: 'errored',\n            error: e,\n          })\n        } catch (_) {\n          // DATA_CLONE_ERR, cf https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n          self.postMessage({\n            type: 'errored',\n            error: `${e}`,\n          })\n        }\n      }\n    }\n  }\n\n  // https://github.com/nodeca/pako/blob/034669ba0f1a4c0590e45f7c2820128200f972b3/dist/pako_deflate.es5.js\n  function makePakoDeflate() {\n    /* eslint-disable camelcase, no-bitwise */\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n    // const Z_FILTERED          = 1;\n    // const Z_HUFFMAN_ONLY      = 2;\n    // const Z_RLE               = 3;\n\n    var Z_FIXED = 4 // const Z_DEFAULT_STRATEGY  = 0;\n\n    /* Possible values of the data_type field (though see inflate()) */\n\n    var Z_BINARY = 0\n    var Z_TEXT = 1 // const Z_ASCII             = 1; // = Z_TEXT\n\n    var Z_UNKNOWN = 2\n    /* ============================================================================ */\n\n    function zero(buf) {\n      var len = buf.length\n\n      while (--len >= 0) {\n        buf[len] = 0\n      }\n    } // From zutil.h\n\n    var STORED_BLOCK = 0\n    var STATIC_TREES = 1\n    var DYN_TREES = 2\n    /* The three kinds of block type */\n\n    var MIN_MATCH = 3\n    var MAX_MATCH = 258\n    /* The minimum and maximum match lengths */\n    // From deflate.h\n\n    /* ===========================================================================\n     * Internal compression state.\n     */\n\n    var LENGTH_CODES = 29\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    var LITERALS = 256\n    /* number of literal bytes 0..255 */\n\n    var L_CODES = LITERALS + 1 + LENGTH_CODES\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    var D_CODES = 30\n    /* number of distance codes */\n\n    var BL_CODES = 19\n    /* number of codes used to transfer the bit lengths */\n\n    var HEAP_SIZE = 2 * L_CODES + 1\n    /* maximum heap size */\n\n    var MAX_BITS = 15\n    /* All codes must not exceed MAX_BITS bits */\n\n    var Buf_size = 16\n    /* size of bit buffer in bi_buf */\n\n    /* ===========================================================================\n     * Constants\n     */\n\n    var MAX_BL_BITS = 7\n    /* Bit length codes must not exceed MAX_BL_BITS bits */\n\n    var END_BLOCK = 256\n    /* end of block literal code */\n\n    var REP_3_6 = 16\n    /* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\n    var REPZ_3_10 = 17\n    /* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\n    var REPZ_11_138 = 18\n    /* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n    var extra_lbits =\n      /* extra bits for each length code */\n      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])\n    var extra_dbits =\n      /* extra bits for each distance code */\n      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])\n    var extra_blbits =\n      /* extra bits for each bit length code */\n      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])\n    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])\n    /* eslint-enable comma-spacing,array-bracket-spacing */\n\n    /* The lengths of the bit length codes are sent in order of decreasing\n     * probability, to avoid transmitting the lengths for unused bit length codes.\n     */\n\n    /* ===========================================================================\n     * Local data. These are initialized only once.\n     */\n    // We pre-fill arrays with 0 to avoid uninitialized gaps\n\n    var DIST_CODE_LEN = 512\n    /* see definition of array dist_code below */\n    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\n    var static_ltree = new Array((L_CODES + 2) * 2)\n    zero(static_ltree)\n    /* The static literal tree. Since the bit lengths are imposed, there is no\n     * need for the L_CODES extra codes used during heap construction. However\n     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n     * below).\n     */\n\n    var static_dtree = new Array(D_CODES * 2)\n    zero(static_dtree)\n    /* The static distance tree. (Actually a trivial tree since all codes use\n     * 5 bits.)\n     */\n\n    var _dist_code = new Array(DIST_CODE_LEN)\n\n    zero(_dist_code)\n    /* Distance codes. The first 256 values correspond to the distances\n     * 3 .. 258, the last 256 values correspond to the top 8 bits of\n     * the 15 bit distances.\n     */\n\n    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1)\n\n    zero(_length_code)\n    /* length code for each normalized match length (0 == MIN_MATCH) */\n\n    var base_length = new Array(LENGTH_CODES)\n    zero(base_length)\n    /* First normalized length for each code (0 = MIN_MATCH) */\n\n    var base_dist = new Array(D_CODES)\n    zero(base_dist)\n    /* First normalized distance for each code (0 = distance of 1) */\n\n    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n      this.static_tree = static_tree\n      /* static tree or NULL */\n\n      this.extra_bits = extra_bits\n      /* extra bits for each code or NULL */\n\n      this.extra_base = extra_base\n      /* base index for extra_bits */\n\n      this.elems = elems\n      /* max number of elements in the tree */\n\n      this.max_length = max_length\n      /* max bit length for the codes */\n      // show if `static_tree` has data or dummy - needed for monomorphic objects\n\n      this.has_stree = static_tree && static_tree.length\n    }\n\n    var static_l_desc\n    var static_d_desc\n    var static_bl_desc\n\n    function TreeDesc(dyn_tree, stat_desc) {\n      this.dyn_tree = dyn_tree\n      /* the dynamic tree */\n\n      this.max_code = 0\n      /* largest code with non zero frequency */\n\n      this.stat_desc = stat_desc\n      /* the corresponding static tree */\n    }\n\n    var d_code = function d_code(dist) {\n      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]\n    }\n    /* ===========================================================================\n     * Output a short LSB first on the stream.\n     * IN assertion: there is enough room in pendingBuf.\n     */\n\n    var put_short = function put_short(s, w) {\n      //    put_byte(s, (uch)((w) & 0xff));\n      //    put_byte(s, (uch)((ush)(w) >> 8));\n      s.pending_buf[s.pending++] = w & 0xff\n      s.pending_buf[s.pending++] = (w >>> 8) & 0xff\n    }\n    /* ===========================================================================\n     * Send a value on a given number of bits.\n     * IN assertion: length <= 16 and value fits in length bits.\n     */\n\n    var send_bits = function send_bits(s, value, length) {\n      if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= (value << s.bi_valid) & 0xffff\n        put_short(s, s.bi_buf)\n        s.bi_buf = value >> (Buf_size - s.bi_valid)\n        s.bi_valid += length - Buf_size\n      } else {\n        s.bi_buf |= (value << s.bi_valid) & 0xffff\n        s.bi_valid += length\n      }\n    }\n\n    var send_code = function send_code(s, c, tree) {\n      send_bits(\n        s,\n        tree[c * 2],\n        /* .Code */\n        tree[c * 2 + 1]\n        /* .Len */\n      )\n    }\n    /* ===========================================================================\n     * Reverse the first len bits of a code, using straightforward code (a faster\n     * method would use a table)\n     * IN assertion: 1 <= len <= 15\n     */\n\n    var bi_reverse = function bi_reverse(code, len) {\n      var res = 0\n\n      do {\n        res |= code & 1\n        code >>>= 1\n        res <<= 1\n      } while (--len > 0)\n\n      return res >>> 1\n    }\n    /* ===========================================================================\n     * Flush the bit buffer, keeping at most 7 bits in it.\n     */\n\n    var bi_flush = function bi_flush(s) {\n      if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf)\n        s.bi_buf = 0\n        s.bi_valid = 0\n      } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff\n        s.bi_buf >>= 8\n        s.bi_valid -= 8\n      }\n    }\n    /* ===========================================================================\n     * Compute the optimal bit lengths for a tree and update the total bit length\n     * for the current block.\n     * IN assertion: the fields freq and dad are set, heap[heap_max] and\n     *    above are the tree nodes sorted by increasing frequency.\n     * OUT assertions: the field len is set to the optimal bit length, the\n     *     array bl_count contains the frequencies for each bit length.\n     *     The length opt_len is updated; static_len is also updated if stree is\n     *     not null.\n     */\n\n    var gen_bitlen = function gen_bitlen(\n      s,\n      desc //    deflate_state *s; //    tree_desc *desc;    /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree\n      var max_code = desc.max_code\n      var stree = desc.stat_desc.static_tree\n      var has_stree = desc.stat_desc.has_stree\n      var extra = desc.stat_desc.extra_bits\n      var base = desc.stat_desc.extra_base\n      var max_length = desc.stat_desc.max_length\n      var h\n      /* heap index */\n\n      var n\n      var m\n      /* iterate over the tree elements */\n\n      var bits\n      /* bit length */\n\n      var xbits\n      /* extra bits */\n\n      var f\n      /* frequency */\n\n      var overflow = 0\n      /* number of elements with bit length too large */\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        s.bl_count[bits] = 0\n      }\n      /* In a first pass, compute the optimal bit lengths (which may\n       * overflow in the case of the bit length tree).\n       */\n\n      tree[s.heap[s.heap_max] * 2 + 1] =\n        /* .Len */\n        0\n      /* root of the heap */\n\n      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n        n = s.heap[h]\n        bits =\n          tree[\n            tree[n * 2 + 1] *\n              /* .Dad */\n              2 +\n              1\n          ] +\n          /* .Len */\n          1\n\n        if (bits > max_length) {\n          bits = max_length\n          overflow++\n        }\n\n        tree[n * 2 + 1] =\n          /* .Len */\n          bits\n        /* We overwrite tree[n].Dad which is no longer needed */\n\n        if (n > max_code) {\n          continue\n        }\n        /* not a leaf node */\n\n        s.bl_count[bits]++\n        xbits = 0\n\n        if (n >= base) {\n          xbits = extra[n - base]\n        }\n\n        f = tree[n * 2]\n        /* .Freq */\n        s.opt_len += f * (bits + xbits)\n\n        if (has_stree) {\n          s.static_len +=\n            f *\n            (stree[n * 2 + 1] +\n              /* .Len */\n              xbits)\n        }\n      }\n\n      if (overflow === 0) {\n        return\n      } // Trace((stderr,\"\\nbit length overflow\\n\"));\n\n      /* This happens for example on obj2 and pic of the Calgary corpus */\n\n      /* Find the first bit length which could increase: */\n\n      do {\n        bits = max_length - 1\n\n        while (s.bl_count[bits] === 0) {\n          bits--\n        }\n\n        s.bl_count[bits]--\n        /* move one leaf down the tree */\n\n        s.bl_count[bits + 1] += 2\n        /* move one overflow item as its brother */\n\n        s.bl_count[max_length]--\n        /* The brother of the overflow item also moves one step up,\n         * but this does not affect bl_count[max_length]\n         */\n\n        overflow -= 2\n      } while (overflow > 0)\n      /* Now recompute all bit lengths, scanning in increasing frequency.\n       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n       * lengths instead of fixing only the wrong ones. This idea is taken\n       * from 'ar' written by Haruhiko Okumura.)\n       */\n\n      for (bits = max_length; bits !== 0; bits--) {\n        n = s.bl_count[bits]\n\n        while (n !== 0) {\n          m = s.heap[--h]\n\n          if (m > max_code) {\n            continue\n          }\n\n          if (\n            tree[m * 2 + 1] !==\n            /* .Len */\n            bits\n          ) {\n            // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n            s.opt_len +=\n              (bits - tree[m * 2 + 1]) *\n              /* .Len */\n              tree[m * 2]\n            /* .Freq */\n            tree[m * 2 + 1] =\n              /* .Len */\n              bits\n          }\n\n          n--\n        }\n      }\n    }\n    /* ===========================================================================\n     * Generate the codes for a given tree and bit counts (which need not be\n     * optimal).\n     * IN assertion: the array bl_count contains the bit length statistics for\n     * the given tree and the field len is set for all tree elements.\n     * OUT assertion: the field code is set for all tree elements of non\n     *     zero code length.\n     */\n\n    var gen_codes = function gen_codes(\n      tree,\n      max_code,\n      bl_count\n      //    ct_data *tree;             /* the tree to decorate */\n      //    int max_code;              /* largest code with non zero frequency */\n      //    ushf *bl_count;            /* number of codes at each bit length */\n    ) {\n      var next_code = new Array(MAX_BITS + 1)\n      /* next code value for each bit length */\n\n      var code = 0\n      /* running code value */\n\n      var bits\n      /* bit index */\n\n      var n\n      /* code index */\n\n      /* The distribution counts are first used to generate the code values\n       * without bit reversal.\n       */\n\n      for (bits = 1; bits <= MAX_BITS; bits++) {\n        next_code[bits] = code = (code + bl_count[bits - 1]) << 1\n      }\n      /* Check that the bit counts in bl_count are consistent. The last code\n       * must be all ones.\n       */\n      // Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n      //        \"inconsistent bit counts\");\n      // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n      for (n = 0; n <= max_code; n++) {\n        var len = tree[n * 2 + 1]\n        /* .Len */\n        if (len === 0) {\n          continue\n        }\n        /* Now reverse the bits */\n\n        tree[n * 2] =\n          /* .Code */\n          bi_reverse(next_code[len]++, len) // Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n      }\n    }\n    /* ===========================================================================\n     * Initialize the various 'constant' tables.\n     */\n\n    var tr_static_init = function tr_static_init() {\n      var n\n      /* iterates over tree elements */\n\n      var bits\n      /* bit counter */\n\n      var length\n      /* length value */\n\n      var code\n      /* code value */\n\n      var dist\n      /* distance index */\n\n      var bl_count = new Array(MAX_BITS + 1)\n      /* number of codes at each bit length for an optimal tree */\n      // do check in _tr_init()\n      // if (static_init_done) return;\n\n      /* For some embedded targets, global variables are not initialized: */\n\n      /* #ifdef NO_INIT_GLOBAL_POINTERS\n      static_l_desc.static_tree = static_ltree;\n      static_l_desc.extra_bits = extra_lbits;\n      static_d_desc.static_tree = static_dtree;\n      static_d_desc.extra_bits = extra_dbits;\n      static_bl_desc.extra_bits = extra_blbits;\n    #endif */\n\n      /* Initialize the mapping length (0..255) -> length code (0..28) */\n\n      length = 0\n\n      for (code = 0; code < LENGTH_CODES - 1; code++) {\n        base_length[code] = length\n\n        for (n = 0; n < 1 << extra_lbits[code]; n++) {\n          _length_code[length++] = code\n        }\n      } // Assert (length == 256, \"tr_static_init: length != 256\");\n\n      /* Note that the length 255 (match length 258) can be represented\n       * in two different ways: code 284 + 5 bits or code 285, so we\n       * overwrite length_code[255] to use the best encoding:\n       */\n\n      _length_code[length - 1] = code\n      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\n      dist = 0\n\n      for (code = 0; code < 16; code++) {\n        base_dist[code] = dist\n\n        for (n = 0; n < 1 << extra_dbits[code]; n++) {\n          _dist_code[dist++] = code\n        }\n      } // Assert (dist == 256, \"tr_static_init: dist != 256\");\n\n      dist >>= 7\n      /* from now on, all distances are divided by 128 */\n\n      for (; code < D_CODES; code++) {\n        base_dist[code] = dist << 7\n\n        for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {\n          _dist_code[256 + dist++] = code\n        }\n      } // Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n      /* Construct the codes of the static literal tree */\n\n      for (bits = 0; bits <= MAX_BITS; bits++) {\n        bl_count[bits] = 0\n      }\n\n      n = 0\n\n      while (n <= 143) {\n        static_ltree[n * 2 + 1] =\n          /* .Len */\n          8\n        n++\n        bl_count[8]++\n      }\n\n      while (n <= 255) {\n        static_ltree[n * 2 + 1] =\n          /* .Len */\n          9\n        n++\n        bl_count[9]++\n      }\n\n      while (n <= 279) {\n        static_ltree[n * 2 + 1] =\n          /* .Len */\n          7\n        n++\n        bl_count[7]++\n      }\n\n      while (n <= 287) {\n        static_ltree[n * 2 + 1] =\n          /* .Len */\n          8\n        n++\n        bl_count[8]++\n      }\n      /* Codes 286 and 287 do not exist, but we must include them in the\n       * tree construction to get a canonical Huffman tree (longest code\n       * all ones)\n       */\n\n      gen_codes(static_ltree, L_CODES + 1, bl_count)\n      /* The static distance tree is trivial: */\n\n      for (n = 0; n < D_CODES; n++) {\n        static_dtree[n * 2 + 1] =\n          /* .Len */\n          5\n        static_dtree[n * 2] =\n          /* .Code */\n          bi_reverse(n, 5)\n      } // Now data ready and we can init static trees\n\n      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS)\n      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS)\n      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)\n      // static_init_done = true;\n    }\n    /* ===========================================================================\n     * Initialize a new block.\n     */\n\n    var init_block = function init_block(s) {\n      var n\n      /* iterates over tree elements */\n\n      /* Initialize the trees. */\n\n      for (n = 0; n < L_CODES; n++) {\n        s.dyn_ltree[n * 2] =\n          /* .Freq */\n          0\n      }\n\n      for (n = 0; n < D_CODES; n++) {\n        s.dyn_dtree[n * 2] =\n          /* .Freq */\n          0\n      }\n\n      for (n = 0; n < BL_CODES; n++) {\n        s.bl_tree[n * 2] =\n          /* .Freq */\n          0\n      }\n\n      s.dyn_ltree[END_BLOCK * 2] =\n        /* .Freq */\n        1\n      s.opt_len = s.static_len = 0\n      s.last_lit = s.matches = 0\n    }\n    /* ===========================================================================\n     * Flush the bit buffer and align the output on a byte boundary\n     */\n\n    var bi_windup = function bi_windup(s) {\n      if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf)\n      } else if (s.bi_valid > 0) {\n        // put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf\n      }\n\n      s.bi_buf = 0\n      s.bi_valid = 0\n    }\n    /* ===========================================================================\n     * Copy a stored block, storing first the length and its\n     * one's complement if requested.\n     */\n\n    var copy_block = function copy_block(\n      s,\n      buf,\n      len,\n      header\n      // DeflateState *s;\n      // charf    *buf;    /* the input data */\n      // unsigned len;     /* its length */\n      // int      header;  /* true if block header must be written */\n    ) {\n      bi_windup(s)\n      /* align on byte boundary */\n\n      if (header) {\n        put_short(s, len)\n        put_short(s, ~len)\n      }\n      //  while (len--) {\n      //    put_byte(s, *buf++);\n      //  }\n\n      s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending)\n      s.pending += len\n    }\n    /* ===========================================================================\n     * Compares to subtrees, using the tree depth as tie breaker when\n     * the subtrees have equal frequency. This minimizes the worst case length.\n     */\n\n    var smaller = function smaller(tree, n, m, depth) {\n      var _n2 = n * 2\n\n      var _m2 = m * 2\n\n      return (\n        tree[_n2] <\n          /* .Freq */\n          tree[_m2] ||\n        /* .Freq */\n        (tree[_n2] ===\n          /* .Freq */\n          tree[_m2] &&\n          /* .Freq */\n          depth[n] <= depth[m])\n      )\n    }\n    /* ===========================================================================\n     * Restore the heap property by moving down the tree starting at node k,\n     * exchanging a node with the smallest of its two sons if necessary, stopping\n     * when the heap property is re-established (each father smaller than its\n     * two sons).\n     */\n\n    var pqdownheap = function pqdownheap(\n      s,\n      tree,\n      k\n      //    deflate_state *s;\n      //    ct_data *tree;  /* the tree to restore */\n      //    int k;               /* node to move down */\n    ) {\n      var v = s.heap[k]\n      var j = k << 1\n      /* left son of k */\n\n      while (j <= s.heap_len) {\n        /* Set j to the smallest of the two sons: */\n        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n          j++\n        }\n        /* Exit if v is smaller than both sons */\n\n        if (smaller(tree, v, s.heap[j], s.depth)) {\n          break\n        }\n        /* Exchange v with the smallest son */\n\n        s.heap[k] = s.heap[j]\n        k = j\n        /* And continue down the tree, setting j to the left son of k */\n\n        j <<= 1\n      }\n\n      s.heap[k] = v\n    } // inlined manually\n    // const SMALLEST = 1;\n\n    /* ===========================================================================\n     * Send the block data compressed using the given Huffman trees\n     */\n\n    var compress_block = function compress_block(\n      s,\n      ltree,\n      dtree\n      //    deflate_state *s;\n      //    const ct_data *ltree; /* literal tree */\n      //    const ct_data *dtree; /* distance tree */\n    ) {\n      var dist\n      /* distance of matched string */\n\n      var lc\n      /* match length or unmatched char (if dist == 0) */\n\n      var lx = 0\n      /* running index in l_buf */\n\n      var code\n      /* the code to send */\n\n      var extra\n      /* number of extra bits to send */\n\n      if (s.last_lit !== 0) {\n        do {\n          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | s.pending_buf[s.d_buf + lx * 2 + 1]\n          lc = s.pending_buf[s.l_buf + lx]\n          lx++\n\n          if (dist === 0) {\n            send_code(s, lc, ltree)\n            /* send a literal byte */\n            // Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n          } else {\n            /* Here, lc is the match length - MIN_MATCH */\n            code = _length_code[lc]\n            send_code(s, code + LITERALS + 1, ltree)\n            /* send the length code */\n\n            extra = extra_lbits[code]\n\n            if (extra !== 0) {\n              lc -= base_length[code]\n              send_bits(s, lc, extra)\n              /* send the extra length bits */\n            }\n\n            dist--\n            /* dist is now the match distance - 1 */\n\n            code = d_code(dist) // Assert (code < D_CODES, \"bad d_code\");\n\n            send_code(s, code, dtree)\n            /* send the distance code */\n\n            extra = extra_dbits[code]\n\n            if (extra !== 0) {\n              dist -= base_dist[code]\n              send_bits(s, dist, extra)\n              /* send the extra distance bits */\n            }\n          }\n          /* literal or match pair ? */\n\n          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n          // Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n          //       \"pendingBuf overflow\");\n        } while (lx < s.last_lit)\n      }\n\n      send_code(s, END_BLOCK, ltree)\n    }\n    /* ===========================================================================\n     * Construct one Huffman tree and assigns the code bit strings and lengths.\n     * Update the total bit length for the current block.\n     * IN assertion: the field freq is set for all tree elements.\n     * OUT assertions: the fields len and code are set to the optimal bit length\n     *     and corresponding code. The length opt_len is updated; static_len is\n     *     also updated if stree is not null. The field max_code is set.\n     */\n\n    var build_tree = function build_tree(\n      s,\n      desc //    deflate_state *s; //    tree_desc *desc; /* the tree descriptor */\n    ) {\n      var tree = desc.dyn_tree\n      var stree = desc.stat_desc.static_tree\n      var has_stree = desc.stat_desc.has_stree\n      var elems = desc.stat_desc.elems\n      var n\n      var m\n      /* iterate over heap elements */\n\n      var max_code = -1\n      /* largest code with non zero frequency */\n\n      var node\n      /* new node being created */\n\n      /* Construct the initial heap, with least frequent element in\n       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n       * heap[0] is not used.\n       */\n\n      s.heap_len = 0\n      s.heap_max = HEAP_SIZE\n\n      for (n = 0; n < elems; n++) {\n        if (\n          tree[n * 2] !==\n          /* .Freq */\n          0\n        ) {\n          s.heap[++s.heap_len] = max_code = n\n          s.depth[n] = 0\n        } else {\n          tree[n * 2 + 1] =\n            /* .Len */\n            0\n        }\n      }\n      /* The pkzip format requires that at least one distance code exists,\n       * and that at least one bit should be sent even if there is only one\n       * possible code. So to avoid special checks later on we force at least\n       * two codes of non zero frequency.\n       */\n\n      while (s.heap_len < 2) {\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0\n        tree[node * 2] =\n          /* .Freq */\n          1\n        s.depth[node] = 0\n        s.opt_len--\n\n        if (has_stree) {\n          s.static_len -= stree[node * 2 + 1]\n          /* .Len */\n        }\n        /* node is 0 or 1 so it does not have extra bits */\n      }\n\n      desc.max_code = max_code\n      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n       * establish sub-heaps of increasing lengths:\n       */\n\n      for (\n        n = s.heap_len >> 1;\n        /* int /2 */\n        n >= 1;\n        n--\n      ) {\n        pqdownheap(s, tree, n)\n      }\n      /* Construct the Huffman tree by repeatedly combining the least two\n       * frequent nodes.\n       */\n\n      node = elems\n      /* next internal node of the tree */\n\n      do {\n        // pqremove(s, tree, n);  /* n = node of least frequency */\n\n        /** * pqremove ** */\n        n = s.heap[1]\n        /* SMALLEST */\n        s.heap[1] = s.heap[s.heap_len--]\n        /* SMALLEST */\n        pqdownheap(\n          s,\n          tree,\n          1\n          /* SMALLEST */\n        )\n        /***/\n\n        m = s.heap[1]\n        /* SMALLEST */\n        /* m = node of next least frequency */\n\n        s.heap[--s.heap_max] = n\n        /* keep the nodes sorted by frequency */\n\n        s.heap[--s.heap_max] = m\n        /* Create a new node father of n and m */\n\n        tree[node * 2] =\n          /* .Freq */\n          tree[n * 2] +\n          /* .Freq */\n          tree[m * 2]\n        /* .Freq */\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1\n        tree[n * 2 + 1] =\n          /* .Dad */\n          tree[m * 2 + 1] =\n            /* .Dad */\n            node\n        /* and insert the new node in the heap */\n\n        s.heap[1] = node++\n        /* SMALLEST */\n        pqdownheap(\n          s,\n          tree,\n          1\n          /* SMALLEST */\n        )\n      } while (s.heap_len >= 2)\n\n      s.heap[--s.heap_max] = s.heap[1]\n      /* SMALLEST */\n      /* At this point, the fields freq and dad are set. We can now\n       * generate the bit lengths.\n       */\n\n      gen_bitlen(s, desc)\n      /* The field len is now set, we can generate the bit codes */\n\n      gen_codes(tree, max_code, s.bl_count)\n    }\n    /* ===========================================================================\n     * Scan a literal or distance tree to determine the frequencies of the codes\n     * in the bit length tree.\n     */\n\n    var scan_tree = function scan_tree(\n      s,\n      tree,\n      max_code\n      //    deflate_state *s;\n      //    ct_data *tree;   /* the tree to be scanned */\n      //    int max_code;    /* and its largest code of non zero frequency */\n    ) {\n      var n\n      /* iterates over all tree elements */\n\n      var prevlen = -1\n      /* last emitted length */\n\n      var curlen\n      /* length of current code */\n\n      var nextlen = tree[0 * 2 + 1]\n      /* .Len */\n      /* length of next code */\n\n      var count = 0\n      /* repeat count of the current code */\n\n      var max_count = 7\n      /* max repeat count */\n\n      var min_count = 4\n      /* min repeat count */\n\n      if (nextlen === 0) {\n        max_count = 138\n        min_count = 3\n      }\n\n      tree[(max_code + 1) * 2 + 1] =\n        /* .Len */\n        0xffff\n      /* guard */\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen\n        nextlen = tree[(n + 1) * 2 + 1]\n        /* .Len */\n\n        if (++count < max_count && curlen === nextlen) {\n          continue\n        } else if (count < min_count) {\n          s.bl_tree[curlen * 2] +=\n            /* .Freq */\n            count\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            s.bl_tree[curlen * 2] /* .Freq */++\n          }\n\n          s.bl_tree[REP_3_6 * 2] /* .Freq */++\n        } else if (count <= 10) {\n          s.bl_tree[REPZ_3_10 * 2] /* .Freq */++\n        } else {\n          s.bl_tree[REPZ_11_138 * 2] /* .Freq */++\n        }\n\n        count = 0\n        prevlen = curlen\n\n        if (nextlen === 0) {\n          max_count = 138\n          min_count = 3\n        } else if (curlen === nextlen) {\n          max_count = 6\n          min_count = 3\n        } else {\n          max_count = 7\n          min_count = 4\n        }\n      }\n    }\n    /* ===========================================================================\n     * Send a literal or distance tree in compressed form, using the codes in\n     * bl_tree.\n     */\n\n    var send_tree = function send_tree(\n      s,\n      tree,\n      max_code\n      //    deflate_state *s;\n      //    ct_data *tree; /* the tree to be scanned */\n      //    int max_code;       /* and its largest code of non zero frequency */\n    ) {\n      var n\n      /* iterates over all tree elements */\n\n      var prevlen = -1\n      /* last emitted length */\n\n      var curlen\n      /* length of current code */\n\n      var nextlen = tree[0 * 2 + 1]\n      /* .Len */\n      /* length of next code */\n\n      var count = 0\n      /* repeat count of the current code */\n\n      var max_count = 7\n      /* max repeat count */\n\n      var min_count = 4\n      /* min repeat count */\n\n      /* tree[max_code+1].Len = -1; */\n\n      /* guard already set */\n\n      if (nextlen === 0) {\n        max_count = 138\n        min_count = 3\n      }\n\n      for (n = 0; n <= max_code; n++) {\n        curlen = nextlen\n        nextlen = tree[(n + 1) * 2 + 1]\n        /* .Len */\n\n        if (++count < max_count && curlen === nextlen) {\n          continue\n        } else if (count < min_count) {\n          do {\n            send_code(s, curlen, s.bl_tree)\n          } while (--count !== 0)\n        } else if (curlen !== 0) {\n          if (curlen !== prevlen) {\n            send_code(s, curlen, s.bl_tree)\n            count--\n          } // Assert(count >= 3 && count <= 6, \" 3_6?\");\n\n          send_code(s, REP_3_6, s.bl_tree)\n          send_bits(s, count - 3, 2)\n        } else if (count <= 10) {\n          send_code(s, REPZ_3_10, s.bl_tree)\n          send_bits(s, count - 3, 3)\n        } else {\n          send_code(s, REPZ_11_138, s.bl_tree)\n          send_bits(s, count - 11, 7)\n        }\n\n        count = 0\n        prevlen = curlen\n\n        if (nextlen === 0) {\n          max_count = 138\n          min_count = 3\n        } else if (curlen === nextlen) {\n          max_count = 6\n          min_count = 3\n        } else {\n          max_count = 7\n          min_count = 4\n        }\n      }\n    }\n    /* ===========================================================================\n     * Construct the Huffman tree for the bit lengths and return the index in\n     * bl_order of the last bit length code to send.\n     */\n\n    var build_bl_tree = function build_bl_tree(s) {\n      var max_blindex\n      /* index of last bit length code of non zero freq */\n\n      /* Determine the bit length frequencies for literal and distance trees */\n\n      scan_tree(s, s.dyn_ltree, s.l_desc.max_code)\n      scan_tree(s, s.dyn_dtree, s.d_desc.max_code)\n      /* Build the bit length tree: */\n\n      build_tree(s, s.bl_desc)\n      /* opt_len now includes the length of the tree representations, except\n       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n       */\n\n      /* Determine the number of bit length codes to send. The pkzip format\n       * requires that at least 4 bit length codes be sent. (appnote.txt says\n       * 3 but the actual value used is 4.)\n       */\n\n      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n        if (\n          s.bl_tree[bl_order[max_blindex] * 2 + 1] !==\n          /* .Len */\n          0\n        ) {\n          break\n        }\n      }\n      /* Update opt_len to include the bit length tree and counts */\n\n      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4 // Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n      //        s->opt_len, s->static_len));\n\n      return max_blindex\n    }\n    /* ===========================================================================\n     * Send the header for a block using dynamic Huffman trees: the counts, the\n     * lengths of the bit length codes, the literal tree and the distance tree.\n     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n     */\n\n    var send_all_trees = function send_all_trees(\n      s,\n      lcodes,\n      dcodes,\n      blcodes //    deflate_state *s; //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n    ) {\n      var rank\n      /* index in bl_order */\n      // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n      // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n      //        \"too many codes\");\n      // Tracev((stderr, \"\\nbl counts: \"));\n\n      send_bits(s, lcodes - 257, 5)\n      /* not +255 as stated in appnote.txt */\n\n      send_bits(s, dcodes - 1, 5)\n      send_bits(s, blcodes - 4, 4)\n      /* not -3 as stated in appnote.txt */\n\n      for (rank = 0; rank < blcodes; rank++) {\n        // Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(\n          s,\n          s.bl_tree[bl_order[rank] * 2 + 1],\n          /* .Len */\n          3\n        )\n      } // Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n      send_tree(s, s.dyn_ltree, lcodes - 1)\n      /* literal tree */\n      // Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n      send_tree(s, s.dyn_dtree, dcodes - 1)\n      /* distance tree */\n      // Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n    }\n    /* ===========================================================================\n     * Check if the data type is TEXT or BINARY, using the following algorithm:\n     * - TEXT if the two conditions below are satisfied:\n     *    a) There are no non-portable control characters belonging to the\n     *       \"black list\" (0..6, 14..25, 28..31).\n     *    b) There is at least one printable character belonging to the\n     *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n     * - BINARY otherwise.\n     * - The following partially-portable control characters form a\n     *   \"gray list\" that is ignored in this detection algorithm:\n     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n     * IN assertion: the fields Freq of dyn_ltree are set.\n     */\n\n    var detect_data_type = function detect_data_type(s) {\n      /* black_mask is the bit mask of black-listed bytes\n       * set bits 0..6, 14..25, and 28..31\n       * 0xf3ffc07f = binary 11110011111111111100000001111111\n       */\n      var black_mask = 0xf3ffc07f\n      var n\n      /* Check for non-textual (\"black-listed\") bytes. */\n\n      for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n        if (\n          black_mask & 1 &&\n          s.dyn_ltree[n * 2] !==\n            /* .Freq */\n            0\n        ) {\n          return Z_BINARY\n        }\n      }\n      /* Check for textual (\"white-listed\") bytes. */\n\n      if (\n        s.dyn_ltree[9 * 2] !==\n          /* .Freq */\n          0 ||\n        s.dyn_ltree[10 * 2] !==\n          /* .Freq */\n          0 ||\n        s.dyn_ltree[13 * 2] !==\n          /* .Freq */\n          0\n      ) {\n        return Z_TEXT\n      }\n\n      for (n = 32; n < LITERALS; n++) {\n        if (\n          s.dyn_ltree[n * 2] !==\n          /* .Freq */\n          0\n        ) {\n          return Z_TEXT\n        }\n      }\n      /* There are no \"black-listed\" or \"white-listed\" bytes:\n       * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n       */\n\n      return Z_BINARY\n    }\n\n    var static_init_done = false\n    /* ===========================================================================\n     * Initialize the tree data structures for a new zlib stream.\n     */\n\n    var _tr_init = function _tr_init(s) {\n      if (!static_init_done) {\n        tr_static_init()\n        static_init_done = true\n      }\n\n      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc)\n      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc)\n      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc)\n      s.bi_buf = 0\n      s.bi_valid = 0\n      /* Initialize the first block of the first file: */\n\n      init_block(s)\n    }\n    /* ===========================================================================\n     * Send a stored block\n     */\n\n    var _tr_stored_block = function _tr_stored_block(\n      s,\n      buf,\n      stored_len,\n      last\n      // DeflateState *s;\n      // charf *buf;       /* input block */\n      // ulg stored_len;   /* length of input block */\n      // int last;         /* one if this is the last block for a file */\n    ) {\n      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3)\n      /* send block type */\n\n      copy_block(s, buf, stored_len, true)\n      /* with header */\n    }\n    /* ===========================================================================\n     * Send one empty static block to give enough lookahead for inflate.\n     * This takes 10 bits, of which 7 may remain in the bit buffer.\n     */\n\n    var _tr_align = function _tr_align(s) {\n      send_bits(s, STATIC_TREES << 1, 3)\n      send_code(s, END_BLOCK, static_ltree)\n      bi_flush(s)\n    }\n    /* ===========================================================================\n     * Determine the best encoding for the current block: dynamic trees, static\n     * trees or store, and output the encoded block to the zip file.\n     */\n\n    var _tr_flush_block = function _tr_flush_block(\n      s,\n      buf,\n      stored_len,\n      last\n      // DeflateState *s;\n      // charf *buf;       /* input block, or NULL if too old */\n      // ulg stored_len;   /* length of input block */\n      // int last;         /* one if this is the last block for a file */\n    ) {\n      var opt_lenb\n      var static_lenb\n      /* opt_len and static_len in bytes */\n\n      var max_blindex = 0\n      /* index of last bit length code of non zero freq */\n\n      /* Build the Huffman trees unless a stored block is forced */\n\n      if (s.level > 0) {\n        /* Check if the file is binary or text */\n        if (s.strm.data_type === Z_UNKNOWN) {\n          s.strm.data_type = detect_data_type(s)\n        }\n        /* Construct the literal and distance trees */\n\n        build_tree(s, s.l_desc) // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        build_tree(s, s.d_desc) // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n\n        /* At this point, opt_len and static_len are the total bit lengths of\n         * the compressed block data, excluding the tree representations.\n         */\n\n        /* Build the bit length tree for the above two trees, and get the index\n         * in bl_order of the last bit length code to send.\n         */\n\n        max_blindex = build_bl_tree(s)\n        /* Determine the best encoding. Compute the block lengths in bytes. */\n\n        opt_lenb = (s.opt_len + 3 + 7) >>> 3\n        static_lenb = (s.static_len + 3 + 7) >>> 3 // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n\n        if (static_lenb <= opt_lenb) {\n          opt_lenb = static_lenb\n        }\n      } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5\n        /* force a stored block */\n      }\n\n      if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */\n\n        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n         * Otherwise we can't have processed more than WSIZE input bytes since\n         * the last block flush, because compression would have been\n         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n         * transform a block into a stored block.\n         */\n        _tr_stored_block(s, buf, stored_len, last)\n      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3)\n        compress_block(s, static_ltree, static_dtree)\n      } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3)\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1)\n        compress_block(s, s.dyn_ltree, s.dyn_dtree)\n      } // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\n      /* The above check is made mod 2^32, for files larger than 512 MB\n       * and uLong implemented on 32 bits.\n       */\n\n      init_block(s)\n\n      if (last) {\n        bi_windup(s)\n      } // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n      //       s->compressed_len-7*last));\n    }\n    /* ===========================================================================\n     * Save the match info and tally the frequency counts. Return true if\n     * the current block must be flushed.\n     */\n\n    var _tr_tally = function _tr_tally(\n      s,\n      dist,\n      lc\n      //    deflate_state *s;\n      //    unsigned dist;  /* distance of matched string */\n      //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n    ) {\n      // let out_length, in_length, dcode;\n      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff\n      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff\n      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff\n      s.last_lit++\n\n      if (dist === 0) {\n        /* lc is the unmatched char */\n        s.dyn_ltree[lc * 2] /* .Freq */++\n      } else {\n        s.matches++\n        /* Here, lc is the match length - MIN_MATCH */\n\n        dist--\n        /* dist = match distance - 1 */\n        // Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /* .Freq */++\n        s.dyn_dtree[d_code(dist) * 2] /* .Freq */++\n      } // (!) This block is disabled in zlib defaults,\n      // don't enable it for binary compatibility\n      // #ifdef TRUNCATE_BLOCK\n      //  /* Try to guess if it is profitable to stop the current block here */\n      //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n      //    /* Compute an upper bound for the compressed length */\n      //    out_length = s.last_lit*8;\n      //    in_length = s.strstart - s.block_start;\n      //\n      //    for (dcode = 0; dcode < D_CODES; dcode++) {\n      //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n      //    }\n      //    out_length >>>= 3;\n      //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n      //    //       s->last_lit, in_length, out_length,\n      //    //       100L - out_length*100L/in_length));\n      //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n      //      return true;\n      //    }\n      //  }\n      // #endif\n\n      return s.last_lit === s.lit_bufsize - 1\n      /* We avoid equality with lit_bufsize because of wraparound at 64K\n       * on 16 bit machines and because stored blocks are restricted to\n       * 64K-1 bytes.\n       */\n    }\n\n    var _tr_init_1 = _tr_init\n    var _tr_stored_block_1 = _tr_stored_block\n    var _tr_flush_block_1 = _tr_flush_block\n    var _tr_tally_1 = _tr_tally\n    var _tr_align_1 = _tr_align\n    var trees = {\n      _tr_init: _tr_init_1,\n      _tr_stored_block: _tr_stored_block_1,\n      _tr_flush_block: _tr_flush_block_1,\n      _tr_tally: _tr_tally_1,\n      _tr_align: _tr_align_1,\n    }\n\n    // It isn't worth it to make additional optimizations as in original.\n    // Small size is preferable.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var adler32 = function adler32(adler, buf, len, pos) {\n      var s1 = (adler & 0xffff) | 0\n      var s2 = ((adler >>> 16) & 0xffff) | 0\n      var n = 0\n\n      while (len !== 0) {\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len\n        len -= n\n\n        do {\n          s1 = (s1 + buf[pos++]) | 0\n          s2 = (s2 + s1) | 0\n        } while (--n)\n\n        s1 %= 65521\n        s2 %= 65521\n      }\n\n      return s1 | (s2 << 16) | 0\n    }\n\n    var adler32_1 = adler32\n\n    // So write code to minimize size - no pregenerated tables\n    // and array tools dependencies.\n    // (C) 1995-2013 Jean-loup Gailly and Mark Adler\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n    // Use ordinary array, since untyped makes no boost here\n\n    var makeTable = function makeTable() {\n      var c\n      var table = []\n\n      for (var n = 0; n < 256; n++) {\n        c = n\n\n        for (var k = 0; k < 8; k++) {\n          c = c & 1 ? 0xedb88320 ^ (c >>> 1) : c >>> 1\n        }\n\n        table[n] = c\n      }\n\n      return table\n    } // Create table on load. Just 255 signed longs. Not a problem.\n\n    var crcTable = new Uint32Array(makeTable())\n\n    var crc32 = function crc32(crc, buf, len, pos) {\n      var t = crcTable\n      var end = pos + len\n      crc ^= -1\n\n      for (var i = pos; i < end; i++) {\n        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xff]\n      }\n\n      return crc ^ -1 // >>> 0;\n    }\n\n    var crc32_1 = crc32\n\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var messages = {\n      2: 'need dictionary',\n\n      /* Z_NEED_DICT       2  */\n      1: 'stream end',\n\n      /* Z_STREAM_END      1  */\n      0: '',\n\n      /* Z_OK              0  */\n      '-1': 'file error',\n\n      /* Z_ERRNO         (-1) */\n      '-2': 'stream error',\n\n      /* Z_STREAM_ERROR  (-2) */\n      '-3': 'data error',\n\n      /* Z_DATA_ERROR    (-3) */\n      '-4': 'insufficient memory',\n\n      /* Z_MEM_ERROR     (-4) */\n      '-5': 'buffer error',\n\n      /* Z_BUF_ERROR     (-5) */\n      '-6': 'incompatible version',\n      /* Z_VERSION_ERROR (-6) */\n    }\n\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var constants = {\n      /* Allowed flush values; see deflate() and inflate() below for details */\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_TREES: 6,\n\n      /* Return codes for the compression/decompression functions. Negative values\n       * are errors, positive values are used for special but normal events.\n       */\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_MEM_ERROR: -4,\n      Z_BUF_ERROR: -5,\n      // Z_VERSION_ERROR: -6,\n\n      /* compression levels */\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n\n      /* Possible values of the data_type field (though see inflate()) */\n      Z_BINARY: 0,\n      Z_TEXT: 1,\n      // Z_ASCII:                1, // = Z_TEXT (deprecated)\n      Z_UNKNOWN: 2,\n\n      /* The deflate compression method */\n      Z_DEFLATED: 8, // Z_NULL:                 null // Use -1 or null inline, depending on var type\n    }\n\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    var _tr_init$1 = trees._tr_init\n    var _tr_stored_block$1 = trees._tr_stored_block\n    var _tr_flush_block$1 = trees._tr_flush_block\n    var _tr_tally$1 = trees._tr_tally\n    var _tr_align$1 = trees._tr_align\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n\n    var Z_NO_FLUSH = constants.Z_NO_FLUSH\n    var Z_PARTIAL_FLUSH = constants.Z_PARTIAL_FLUSH\n    var Z_FULL_FLUSH = constants.Z_FULL_FLUSH\n    var Z_FINISH = constants.Z_FINISH\n    var Z_BLOCK = constants.Z_BLOCK\n    var Z_OK = constants.Z_OK\n    var Z_STREAM_END = constants.Z_STREAM_END\n    var Z_STREAM_ERROR = constants.Z_STREAM_ERROR\n    var Z_DATA_ERROR = constants.Z_DATA_ERROR\n    var Z_BUF_ERROR = constants.Z_BUF_ERROR\n    var Z_DEFAULT_COMPRESSION = constants.Z_DEFAULT_COMPRESSION\n    var Z_FILTERED = constants.Z_FILTERED\n    var Z_HUFFMAN_ONLY = constants.Z_HUFFMAN_ONLY\n    var Z_RLE = constants.Z_RLE\n    var Z_FIXED$1 = constants.Z_FIXED\n    var Z_DEFAULT_STRATEGY = constants.Z_DEFAULT_STRATEGY\n    var Z_UNKNOWN$1 = constants.Z_UNKNOWN\n    var Z_DEFLATED = constants.Z_DEFLATED\n    /* ============================================================================ */\n\n    var MAX_MEM_LEVEL = 9\n    /* Maximum value for memLevel in deflateInit2 */\n\n    var MAX_WBITS = 15\n    /* 32K LZ77 window */\n\n    var DEF_MEM_LEVEL = 8\n    var LENGTH_CODES$1 = 29\n    /* number of length codes, not counting the special END_BLOCK code */\n\n    var LITERALS$1 = 256\n    /* number of literal bytes 0..255 */\n\n    var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1\n    /* number of Literal or Length codes, including the END_BLOCK code */\n\n    var D_CODES$1 = 30\n    /* number of distance codes */\n\n    var BL_CODES$1 = 19\n    /* number of codes used to transfer the bit lengths */\n\n    var HEAP_SIZE$1 = 2 * L_CODES$1 + 1\n    /* maximum heap size */\n\n    var MAX_BITS$1 = 15\n    /* All codes must not exceed MAX_BITS bits */\n\n    var MIN_MATCH$1 = 3\n    var MAX_MATCH$1 = 258\n    var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1\n    var PRESET_DICT = 0x20\n    var INIT_STATE = 42\n    var EXTRA_STATE = 69\n    var NAME_STATE = 73\n    var COMMENT_STATE = 91\n    var HCRC_STATE = 103\n    var BUSY_STATE = 113\n    var FINISH_STATE = 666\n    var BS_NEED_MORE = 1\n    /* block not completed, need more input or more output */\n\n    var BS_BLOCK_DONE = 2\n    /* block flush performed */\n\n    var BS_FINISH_STARTED = 3\n    /* finish started, need only more output at next deflate */\n\n    var BS_FINISH_DONE = 4\n    /* finish done, accept no more input or output */\n\n    var OS_CODE = 0x03 // Unix :) . Don't detect, use this default.\n\n    var err = function err(strm, errorCode) {\n      strm.msg = messages[errorCode]\n      return errorCode\n    }\n\n    var rank = function rank(f) {\n      return (f << 1) - (f > 4 ? 9 : 0)\n    }\n\n    var zero$1 = function zero(buf) {\n      var len = buf.length\n\n      while (--len >= 0) {\n        buf[len] = 0\n      }\n    }\n\n    var HASH_ZLIB = function HASH_ZLIB(s, prev, data) {\n      return ((prev << s.hash_shift) ^ data) & s.hash_mask\n    } // This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n    // But breaks binary compatibility\n    // let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n\n    var HASH = HASH_ZLIB\n    /* =========================================================================\n     * Flush as much pending output as possible. All deflate() output goes\n     * through this function so some applications may wish to modify it\n     * to avoid allocating a large strm->output buffer and copying into it.\n     * (See also read_buf()).\n     */\n\n    var flush_pending = function flush_pending(strm) {\n      var s = strm.state // _tr_flush_bits(s);\n\n      var len = s.pending\n\n      if (len > strm.avail_out) {\n        len = strm.avail_out\n      }\n\n      if (len === 0) {\n        return\n      }\n\n      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out)\n      strm.next_out += len\n      s.pending_out += len\n      strm.total_out += len\n      strm.avail_out -= len\n      s.pending -= len\n\n      if (s.pending === 0) {\n        s.pending_out = 0\n      }\n    }\n\n    var flush_block_only = function flush_block_only(s, last) {\n      _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last)\n\n      s.block_start = s.strstart\n      flush_pending(s.strm)\n    }\n\n    var put_byte = function put_byte(s, b) {\n      s.pending_buf[s.pending++] = b\n    }\n    /* =========================================================================\n     * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n     * IN assertion: the stream state is correct and there is enough room in\n     * pending_buf.\n     */\n\n    var putShortMSB = function putShortMSB(s, b) {\n      //  put_byte(s, (Byte)(b >> 8));\n      //  put_byte(s, (Byte)(b & 0xff));\n      s.pending_buf[s.pending++] = (b >>> 8) & 0xff\n      s.pending_buf[s.pending++] = b & 0xff\n    }\n    /* ===========================================================================\n     * Read a new buffer from the current input stream, update the adler32\n     * and total number of bytes read.  All deflate() input goes through\n     * this function so some applications may wish to modify it to avoid\n     * allocating a large strm->input buffer and copying from it.\n     * (See also flush_pending()).\n     */\n\n    var read_buf = function read_buf(strm, buf, start, size) {\n      var len = strm.avail_in\n\n      if (len > size) {\n        len = size\n      }\n\n      if (len === 0) {\n        return 0\n      }\n\n      strm.avail_in -= len // zmemcpy(buf, strm->next_in, len);\n\n      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start)\n\n      if (strm.state.wrap === 1) {\n        strm.adler = adler32_1(strm.adler, buf, len, start)\n      } else if (strm.state.wrap === 2) {\n        strm.adler = crc32_1(strm.adler, buf, len, start)\n      }\n\n      strm.next_in += len\n      strm.total_in += len\n      return len\n    }\n    /* ===========================================================================\n     * Set match_start to the longest match starting at the given string and\n     * return its length. Matches shorter or equal to prev_length are discarded,\n     * in which case the result is equal to prev_length and match_start is\n     * garbage.\n     * IN assertions: cur_match is the head of the hash chain for the current\n     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n     * OUT assertion: the match length is not greater than s->lookahead.\n     */\n\n    var longest_match = function longest_match(s, cur_match) {\n      var chain_length = s.max_chain_length\n      /* max hash chain length */\n\n      var scan = s.strstart\n      /* current string */\n\n      var match\n      /* matched string */\n\n      var len\n      /* length of current match */\n\n      var best_len = s.prev_length\n      /* best match length so far */\n\n      var nice_match = s.nice_match\n      /* stop if match long enough */\n\n      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0\n      /* NIL */\n      var _win = s.window // shortcut\n\n      var wmask = s.w_mask\n      var prev = s.prev\n      /* Stop when cur_match becomes <= limit. To simplify the code,\n       * we prevent matches with the string of window index 0.\n       */\n\n      var strend = s.strstart + MAX_MATCH$1\n      var scan_end1 = _win[scan + best_len - 1]\n      var scan_end = _win[scan + best_len]\n      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n       * It is easy to get rid of this optimization if necessary.\n       */\n      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n      /* Do not waste too much time if we already have a good match: */\n\n      if (s.prev_length >= s.good_match) {\n        chain_length >>= 2\n      }\n      /* Do not look for matches beyond the end of the input. This is necessary\n       * to make deflate deterministic.\n       */\n\n      if (nice_match > s.lookahead) {\n        nice_match = s.lookahead\n      } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n      do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match\n        /* Skip to next match if the match length cannot increase\n         * or if the match length is less than 2.  Note that the checks below\n         * for insufficient lookahead only occur occasionally for performance\n         * reasons.  Therefore uninitialized memory will be accessed, and\n         * conditional jumps will be made that depend on those values.\n         * However the length of the match is limited to the lookahead, so\n         * the output of deflate is not affected by the uninitialized values.\n         */\n\n        if (\n          _win[match + best_len] !== scan_end ||\n          _win[match + best_len - 1] !== scan_end1 ||\n          _win[match] !== _win[scan] ||\n          _win[++match] !== _win[scan + 1]\n        ) {\n          continue\n        }\n        /* The check at best_len-1 can be removed because it will be made\n         * again later. (This heuristic is not always a win.)\n         * It is not necessary to compare scan[2] and match[2] since they\n         * are always equal when the other bytes match, given that\n         * the hash keys are equal and that HASH_BITS >= 8.\n         */\n\n        scan += 2\n        match++ // Assert(*scan == *match, \"match[2]?\");\n\n        /* We check for insufficient lookahead only every 8th comparison;\n         * the 256th check will be made at strstart+258.\n         */\n\n        do {\n          /* jshint noempty:false */\n        } while (\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          _win[++scan] === _win[++match] &&\n          scan < strend\n        ) // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n        len = MAX_MATCH$1 - (strend - scan)\n        scan = strend - MAX_MATCH$1\n\n        if (len > best_len) {\n          s.match_start = cur_match\n          best_len = len\n\n          if (len >= nice_match) {\n            break\n          }\n\n          scan_end1 = _win[scan + best_len - 1]\n          scan_end = _win[scan + best_len]\n        }\n      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0)\n\n      if (best_len <= s.lookahead) {\n        return best_len\n      }\n\n      return s.lookahead\n    }\n    /* ===========================================================================\n     * Fill the window when the lookahead becomes insufficient.\n     * Updates strstart and lookahead.\n     *\n     * IN assertion: lookahead < MIN_LOOKAHEAD\n     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n     *    At least one byte has been read, or avail_in == 0; reads are\n     *    performed for at least two bytes (required for the zip translate_eol\n     *    option -- not supported here).\n     */\n\n    var fill_window = function fill_window(s) {\n      var _w_size = s.w_size\n      var p\n      var n\n      var m\n      var more\n      var str // Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n      do {\n        more = s.window_size - s.lookahead - s.strstart // JS ints have 32 bit, block below not needed\n\n        /* Deal with !@#$% 64K limit: */\n        // if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        // }\n\n        /* If the window is almost full and there is insufficient lookahead,\n         * move the upper half to the lower one to make room in the upper half.\n         */\n\n        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n          s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0)\n          s.match_start -= _w_size\n          s.strstart -= _w_size\n          /* we now have strstart >= MAX_DIST */\n\n          s.block_start -= _w_size\n          /* Slide the hash table (could be avoided with 32 bit values\n         at the expense of memory usage). We slide even when level == 0\n         to keep the hash table consistent if we switch back to level > 0\n         later. (Using level 0 permanently is not an optimal usage of\n         zlib, so we don't care about this pathological case.)\n         */\n\n          n = s.hash_size\n          p = n\n\n          do {\n            m = s.head[--p]\n            s.head[p] = m >= _w_size ? m - _w_size : 0\n          } while (--n)\n\n          n = _w_size\n          p = n\n\n          do {\n            m = s.prev[--p]\n            s.prev[p] = m >= _w_size ? m - _w_size : 0\n            /* If n is not on any hash chain, prev[n] is garbage but\n             * its value will never be used.\n             */\n          } while (--n)\n\n          more += _w_size\n        }\n\n        if (s.strm.avail_in === 0) {\n          break\n        }\n        /* If there was no sliding:\n         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n         *    more == window_size - lookahead - strstart\n         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n         * => more >= window_size - 2*WSIZE + 2\n         * In the BIG_MEM or MMAP case (not yet supported),\n         *   window_size == input_size + MIN_LOOKAHEAD  &&\n         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n         * Otherwise, window_size == 2*WSIZE so more >= 2.\n         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n         */\n        // Assert(more >= 2, \"more < 2\");\n\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more)\n        s.lookahead += n\n        /* Initialize the hash value now that we have some input: */\n\n        if (s.lookahead + s.insert >= MIN_MATCH$1) {\n          str = s.strstart - s.insert\n          s.ins_h = s.window[str]\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\n          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]) // #if MIN_MATCH != 3\n          //        Call update_hash() MIN_MATCH-3 more times\n          // #endif\n\n          while (s.insert) {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1])\n            s.prev[str & s.w_mask] = s.head[s.ins_h]\n            s.head[s.ins_h] = str\n            str++\n            s.insert--\n\n            if (s.lookahead + s.insert < MIN_MATCH$1) {\n              break\n            }\n          }\n        }\n        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n         * but this is not important since only literal bytes will be emitted.\n         */\n      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)\n      /* If the WIN_INIT bytes after the end of the current data have never been\n       * written, then zero those bytes in order to avoid memory check reports of\n       * the use of uninitialized (or uninitialised as Julian writes) bytes by\n       * the longest match routines.  Update the high water mark for the next\n       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n       */\n      //  if (s.high_water < s.window_size) {\n      //    const curr = s.strstart + s.lookahead;\n      //    let init = 0;\n      //\n      //    if (s.high_water < curr) {\n      //      /* Previous high water mark below current data -- zero WIN_INIT\n      //       * bytes or up to end of window, whichever is less.\n      //       */\n      //      init = s.window_size - curr;\n      //      if (init > WIN_INIT)\n      //        init = WIN_INIT;\n      //      zmemzero(s->window + curr, (unsigned)init);\n      //      s->high_water = curr + init;\n      //    }\n      //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n      //      /* High water mark at or above current data, but below current data\n      //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n      //       * to end of window, whichever is less.\n      //       */\n      //      init = (ulg)curr + WIN_INIT - s->high_water;\n      //      if (init > s->window_size - s->high_water)\n      //        init = s->window_size - s->high_water;\n      //      zmemzero(s->window + s->high_water, (unsigned)init);\n      //      s->high_water += init;\n      //    }\n      //  }\n      //\n      //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n      //    \"not enough room for search\");\n    }\n    /* ===========================================================================\n     * Copy without compression as much as possible from the input stream, return\n     * the current block state.\n     * This function does not insert new strings in the dictionary since\n     * uncompressible data is probably not useful. This function is used\n     * only for the level=0 compression option.\n     * NOTE: this function should be optimized to avoid extra copying from\n     * window to pending_buf.\n     */\n\n    var deflate_stored = function deflate_stored(s, flush) {\n      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n       * to pending_buf_size, and each stored block has a 5 byte header:\n       */\n      var max_block_size = 0xffff\n\n      if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5\n      }\n      /* Copy as much as possible from input to output: */\n\n      for (;;) {\n        /* Fill the window as much as possible: */\n        if (s.lookahead <= 1) {\n          // Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n          //  s->block_start >= (long)s->w_size, \"slide too late\");\n          //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n          //        s.block_start >= s.w_size)) {\n          //        throw  new Error(\"slide too late\");\n          //      }\n          fill_window(s)\n\n          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE\n          }\n\n          if (s.lookahead === 0) {\n            break\n          }\n          /* flush the current block */\n        } // Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n        s.strstart += s.lookahead\n        s.lookahead = 0\n        /* Emit a stored block if pending_buf will be full: */\n\n        var max_start = s.block_start + max_block_size\n\n        if (s.strstart === 0 || s.strstart >= max_start) {\n          /* strstart == 0 is possible when wraparound on 16-bit machine */\n          s.lookahead = s.strstart - max_start\n          s.strstart = max_start\n          /** * FLUSH_BLOCK(s, 0); ** */\n\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n        /* Flush if we may have to slide, otherwise block_start may become\n         * negative and the data will be gone:\n         */\n\n        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.strstart > s.block_start) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_NEED_MORE\n    }\n    /* ===========================================================================\n     * Compress as much as possible from the input stream, return the current\n     * block state.\n     * This function does not perform lazy evaluation of matches and inserts\n     * new strings in the dictionary only for unmatched strings or for short\n     * matches. It is used only for the fast compression options.\n     */\n\n    var deflate_fast = function deflate_fast(s, flush) {\n      var hash_head\n      /* head of the hash chain */\n\n      var bflush\n      /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s)\n\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE\n          }\n\n          if (s.lookahead === 0) {\n            break\n            /* flush the current block */\n          }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n        hash_head = 0\n        /* NIL */\n\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = s.strstart\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         * At this point we have always match_length < MIN_MATCH\n         */\n\n        if (\n          hash_head !== 0 &&\n          /* NIL */\n          s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n        ) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head)\n          /* longest_match() sets match_start */\n        }\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n          /** * _tr_tally_dist(s, s.strstart - s.match_start,\n                       s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1)\n          s.lookahead -= s.match_length\n          /* Insert new strings in the hash table only if the match length\n           * is not too large. This saves time but degrades compression.\n           */\n\n          if (\n            s.match_length <= s.max_lazy_match &&\n            /* max_insert_length */\n            s.lookahead >= MIN_MATCH$1\n          ) {\n            s.match_length--\n            /* string at strstart already in table */\n\n            do {\n              s.strstart++\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n              s.head[s.ins_h] = s.strstart\n              /***/\n\n              /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n               * always MIN_MATCH bytes ahead.\n               */\n            } while (--s.match_length !== 0)\n\n            s.strstart++\n          } else {\n            s.strstart += s.match_length\n            s.match_length = 0\n            s.ins_h = s.window[s.strstart]\n            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\n            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]) // #if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            // #endif\n\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n             * matter since it will be recomputed at next deflate call.\n             */\n          }\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n          s.lookahead--\n          s.strstart++\n        }\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE\n    }\n    /* ===========================================================================\n     * Same as above, but achieves better compression. We use a lazy\n     * evaluation for matches: a match is finally adopted only if there is\n     * no better match at the next window position.\n     */\n\n    var deflate_slow = function deflate_slow(s, flush) {\n      var hash_head\n      /* head of hash chain */\n\n      var bflush\n      /* set if current block must be flushed */\n\n      var max_insert\n      /* Process the input block. */\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the next match, plus MIN_MATCH bytes to insert the\n         * string following the next match.\n         */\n        if (s.lookahead < MIN_LOOKAHEAD) {\n          fill_window(s)\n\n          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE\n          }\n\n          if (s.lookahead === 0) {\n            break\n          }\n          /* flush the current block */\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n         * dictionary, and set hash_head to the head of the hash chain:\n         */\n\n        hash_head = 0\n        /* NIL */\n\n        if (s.lookahead >= MIN_MATCH$1) {\n          /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = s.strstart\n          /***/\n        }\n        /* Find the longest match, discarding those <= prev_length.\n         */\n\n        s.prev_length = s.match_length\n        s.prev_match = s.match_start\n        s.match_length = MIN_MATCH$1 - 1\n\n        if (\n          hash_head !== 0 &&\n          /* NIL */\n          s.prev_length < s.max_lazy_match &&\n          s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n          /* MAX_DIST(s) */\n        ) {\n          /* To simplify the code, we prevent matches with the string\n           * of window index 0 (in particular we have to avoid a match\n           * of the string with itself at the start of the input file).\n           */\n          s.match_length = longest_match(s, hash_head)\n          /* longest_match() sets match_start */\n\n          if (\n            s.match_length <= 5 &&\n            (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096))\n            /* TOO_FAR */\n          ) {\n            /* If prev_match is also MIN_MATCH, match_start is garbage\n             * but we will ignore the current match anyway.\n             */\n            s.match_length = MIN_MATCH$1 - 1\n          }\n        }\n        /* If there was a match at the previous step and the current\n         * match is not better, output the previous match:\n         */\n\n        if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {\n          max_insert = s.strstart + s.lookahead - MIN_MATCH$1\n          /* Do not insert strings in hash table beyond this. */\n          // check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n          /** *_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                       s.prev_length - MIN_MATCH, bflush);** */\n\n          bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1)\n          /* Insert in hash table all strings up to the end of the match.\n           * strstart-1 and strstart are already inserted. If there is not\n           * enough lookahead, the last two strings are not inserted in\n           * the hash table.\n           */\n\n          s.lookahead -= s.prev_length - 1\n          s.prev_length -= 2\n\n          do {\n            if (++s.strstart <= max_insert) {\n              /** * INSERT_STRING(s, s.strstart, hash_head); ** */\n              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1])\n              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n              s.head[s.ins_h] = s.strstart\n              /***/\n            }\n          } while (--s.prev_length !== 0)\n\n          s.match_available = 0\n          s.match_length = MIN_MATCH$1 - 1\n          s.strstart++\n\n          if (bflush) {\n            /** * FLUSH_BLOCK(s, 0); ** */\n            flush_block_only(s, false)\n\n            if (s.strm.avail_out === 0) {\n              return BS_NEED_MORE\n            }\n            /***/\n          }\n        } else if (s.match_available) {\n          /* If there was no match at the previous position, output a\n           * single literal. If there was a match but the current match\n           * is longer, truncate the previous match to a single literal.\n           */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1])\n\n          if (bflush) {\n            /** * FLUSH_BLOCK_ONLY(s, 0) ** */\n            flush_block_only(s, false)\n            /***/\n          }\n\n          s.strstart++\n          s.lookahead--\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n        } else {\n          /* There is no previous match to compare with, wait for\n           * the next step to decide.\n           */\n          s.match_available = 1\n          s.strstart++\n          s.lookahead--\n        }\n      } // Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\n      if (s.match_available) {\n        // Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\n        /** * _tr_tally_lit(s, s.window[s.strstart-1], bflush); ** */\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1])\n        s.match_available = 0\n      }\n\n      s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE\n    }\n    /* ===========================================================================\n     * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n     * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n     * deflate switches away from Z_RLE.)\n     */\n\n    var deflate_rle = function deflate_rle(s, flush) {\n      var bflush\n      /* set if current block must be flushed */\n\n      var prev\n      /* byte at distance one to match */\n\n      var scan\n      var strend\n      /* scan goes up to strend for length of run */\n\n      var _win = s.window\n\n      for (;;) {\n        /* Make sure that we always have enough lookahead, except\n         * at the end of the input file. We need MAX_MATCH bytes\n         * for the longest run, plus one for the unrolled loop.\n         */\n        if (s.lookahead <= MAX_MATCH$1) {\n          fill_window(s)\n\n          if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {\n            return BS_NEED_MORE\n          }\n\n          if (s.lookahead === 0) {\n            break\n          }\n          /* flush the current block */\n        }\n        /* See how many times the previous byte repeats */\n\n        s.match_length = 0\n\n        if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {\n          scan = s.strstart - 1\n          prev = _win[scan]\n\n          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n            strend = s.strstart + MAX_MATCH$1\n\n            do {\n              /* jshint noempty:false */\n            } while (\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              prev === _win[++scan] &&\n              scan < strend\n            )\n\n            s.match_length = MAX_MATCH$1 - (strend - scan)\n\n            if (s.match_length > s.lookahead) {\n              s.match_length = s.lookahead\n            }\n          } // Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\n        if (s.match_length >= MIN_MATCH$1) {\n          // check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n          /** * _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ** */\n          bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1)\n          s.lookahead -= s.match_length\n          s.strstart += s.match_length\n          s.match_length = 0\n        } else {\n          /* No match, output a literal byte */\n          // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n          /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n          bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n          s.lookahead--\n          s.strstart++\n        }\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE\n    }\n    /* ===========================================================================\n     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n     * (It will be regenerated if this run of deflate switches away from Huffman.)\n     */\n\n    var deflate_huff = function deflate_huff(s, flush) {\n      var bflush\n      /* set if current block must be flushed */\n\n      for (;;) {\n        /* Make sure that we have a literal to write. */\n        if (s.lookahead === 0) {\n          fill_window(s)\n\n          if (s.lookahead === 0) {\n            if (flush === Z_NO_FLUSH) {\n              return BS_NEED_MORE\n            }\n\n            break\n            /* flush the current block */\n          }\n        }\n        /* Output a literal byte */\n\n        s.match_length = 0 // Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\n        /** * _tr_tally_lit(s, s.window[s.strstart], bflush); ** */\n\n        bflush = _tr_tally$1(s, 0, s.window[s.strstart])\n        s.lookahead--\n        s.strstart++\n\n        if (bflush) {\n          /** * FLUSH_BLOCK(s, 0); ** */\n          flush_block_only(s, false)\n\n          if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE\n          }\n          /***/\n        }\n      }\n\n      s.insert = 0\n\n      if (flush === Z_FINISH) {\n        /** * FLUSH_BLOCK(s, 1); ** */\n        flush_block_only(s, true)\n\n        if (s.strm.avail_out === 0) {\n          return BS_FINISH_STARTED\n        }\n        /***/\n\n        return BS_FINISH_DONE\n      }\n\n      if (s.last_lit) {\n        /** * FLUSH_BLOCK(s, 0); ** */\n        flush_block_only(s, false)\n\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n\n      return BS_BLOCK_DONE\n    }\n    /* Values for max_lazy_match, good_match and max_chain_length, depending on\n     * the desired pack level (0..9). The values given below have been tuned to\n     * exclude worst case performance for pathological files. Better values may be\n     * found for specific files.\n     */\n\n    function Config(good_length, max_lazy, nice_length, max_chain, func) {\n      this.good_length = good_length\n      this.max_lazy = max_lazy\n      this.nice_length = nice_length\n      this.max_chain = max_chain\n      this.func = func\n    }\n\n    var configuration_table = [\n      /*      good lazy nice chain */\n      new Config(0, 0, 0, 0, deflate_stored),\n      /* 0 store only */\n      new Config(4, 4, 8, 4, deflate_fast),\n      /* 1 max speed, no lazy matches */\n      new Config(4, 5, 16, 8, deflate_fast),\n      /* 2 */\n      new Config(4, 6, 32, 32, deflate_fast),\n      /* 3 */\n      new Config(4, 4, 16, 16, deflate_slow),\n      /* 4 lazy matches */\n      new Config(8, 16, 32, 32, deflate_slow),\n      /* 5 */\n      new Config(8, 16, 128, 128, deflate_slow),\n      /* 6 */\n      new Config(8, 32, 128, 256, deflate_slow),\n      /* 7 */\n      new Config(32, 128, 258, 1024, deflate_slow),\n      /* 8 */\n      new Config(32, 258, 258, 4096, deflate_slow),\n      /* 9 max compression */\n    ]\n    /* ===========================================================================\n     * Initialize the \"longest match\" routines for a new zlib stream\n     */\n\n    var lm_init = function lm_init(s) {\n      s.window_size = 2 * s.w_size\n      /** * CLEAR_HASH(s); ** */\n\n      zero$1(s.head) // Fill with NIL (= 0);\n\n      /* Set the default configuration parameters:\n       */\n\n      s.max_lazy_match = configuration_table[s.level].max_lazy\n      s.good_match = configuration_table[s.level].good_length\n      s.nice_match = configuration_table[s.level].nice_length\n      s.max_chain_length = configuration_table[s.level].max_chain\n      s.strstart = 0\n      s.block_start = 0\n      s.lookahead = 0\n      s.insert = 0\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1\n      s.match_available = 0\n      s.ins_h = 0\n    }\n\n    function DeflateState() {\n      this.strm = null\n      /* pointer back to this zlib stream */\n\n      this.status = 0\n      /* as the name implies */\n\n      this.pending_buf = null\n      /* output still pending */\n\n      this.pending_buf_size = 0\n      /* size of pending_buf */\n\n      this.pending_out = 0\n      /* next pending byte to output to the stream */\n\n      this.pending = 0\n      /* nb of bytes in the pending buffer */\n\n      this.wrap = 0\n      /* bit 0 true for zlib, bit 1 true for gzip */\n\n      this.gzhead = null\n      /* gzip header information to write */\n\n      this.gzindex = 0\n      /* where in extra, name, or comment */\n\n      this.method = Z_DEFLATED\n      /* can only be DEFLATED */\n\n      this.last_flush = -1\n      /* value of flush param for previous deflate call */\n\n      this.w_size = 0\n      /* LZ77 window size (32K by default) */\n\n      this.w_bits = 0\n      /* log2(w_size)  (8..16) */\n\n      this.w_mask = 0\n      /* w_size - 1 */\n\n      this.window = null\n      /* Sliding window. Input bytes are read into the second half of the window,\n       * and move to the first half later to keep a dictionary of at least wSize\n       * bytes. With this organization, matches are limited to a distance of\n       * wSize-MAX_MATCH bytes, but this ensures that IO is always\n       * performed with a length multiple of the block size.\n       */\n\n      this.window_size = 0\n      /* Actual size of window: 2*wSize, except when the user input buffer\n       * is directly used as sliding window.\n       */\n\n      this.prev = null\n      /* Link to older string with same hash index. To limit the size of this\n       * array to 64K, this link is maintained only for the last 32K strings.\n       * An index in this array is thus a window index modulo 32K.\n       */\n\n      this.head = null\n      /* Heads of the hash chains or NIL. */\n\n      this.ins_h = 0\n      /* hash index of string to be inserted */\n\n      this.hash_size = 0\n      /* number of elements in hash table */\n\n      this.hash_bits = 0\n      /* log2(hash_size) */\n\n      this.hash_mask = 0\n      /* hash_size-1 */\n\n      this.hash_shift = 0\n      /* Number of bits by which ins_h must be shifted at each input\n       * step. It must be such that after MIN_MATCH steps, the oldest\n       * byte no longer takes part in the hash key, that is:\n       *   hash_shift * MIN_MATCH >= hash_bits\n       */\n\n      this.block_start = 0\n      /* Window position at the beginning of the current output block. Gets\n       * negative when the window is moved backwards.\n       */\n\n      this.match_length = 0\n      /* length of best match */\n\n      this.prev_match = 0\n      /* previous match */\n\n      this.match_available = 0\n      /* set if previous match exists */\n\n      this.strstart = 0\n      /* start of string to insert */\n\n      this.match_start = 0\n      /* start of matching string */\n\n      this.lookahead = 0\n      /* number of valid bytes ahead in window */\n\n      this.prev_length = 0\n      /* Length of the best match at previous step. Matches not greater than this\n       * are discarded. This is used in the lazy match evaluation.\n       */\n\n      this.max_chain_length = 0\n      /* To speed up deflation, hash chains are never searched beyond this\n       * length.  A higher limit improves compression ratio but degrades the\n       * speed.\n       */\n\n      this.max_lazy_match = 0\n      /* Attempt to find a better match only when the current match is strictly\n       * smaller than this value. This mechanism is used only for compression\n       * levels >= 4.\n       */\n      // That's alias to max_lazy_match, don't use directly\n      // this.max_insert_length = 0;\n\n      /* Insert new strings in the hash table only if the match length is not\n       * greater than this length. This saves time but degrades compression.\n       * max_insert_length is used only for compression levels <= 3.\n       */\n\n      this.level = 0\n      /* compression level (1..9) */\n\n      this.strategy = 0\n      /* favor or force Huffman coding */\n\n      this.good_match = 0\n      /* Use a faster search when the previous match is longer than this */\n\n      this.nice_match = 0\n      /* Stop searching when current match exceeds this */\n\n      /* used by trees.c: */\n\n      /* Didn't use ct_data typedef below to suppress compiler warning */\n      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n      // Use flat array of DOUBLE size, with interleaved fata,\n      // because JS does not support effective\n\n      this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2)\n      this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2)\n      this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2)\n      zero$1(this.dyn_ltree)\n      zero$1(this.dyn_dtree)\n      zero$1(this.bl_tree)\n      this.l_desc = null\n      /* desc. for literal tree */\n\n      this.d_desc = null\n      /* desc. for distance tree */\n\n      this.bl_desc = null\n      /* desc. for bit length tree */\n      // ush bl_count[MAX_BITS+1];\n\n      this.bl_count = new Uint16Array(MAX_BITS$1 + 1)\n      /* number of codes at each bit length for an optimal tree */\n      // int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\n      this.heap = new Uint16Array(2 * L_CODES$1 + 1)\n      /* heap used to build the Huffman trees */\n\n      zero$1(this.heap)\n      this.heap_len = 0\n      /* number of elements in the heap */\n\n      this.heap_max = 0\n      /* element of largest frequency */\n\n      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n       * The same heap array is used to build all trees.\n       */\n\n      this.depth = new Uint16Array(2 * L_CODES$1 + 1) // uch depth[2*L_CODES+1];\n\n      zero$1(this.depth)\n      /* Depth of each subtree used as tie breaker for trees of equal frequency\n       */\n\n      this.l_buf = 0\n      /* buffer index for literals or lengths */\n\n      this.lit_bufsize = 0\n      /* Size of match buffer for literals/lengths.  There are 4 reasons for\n       * limiting lit_bufsize to 64K:\n       *   - frequencies can be kept in 16 bit counters\n       *   - if compression is not successful for the first block, all input\n       *     data is still in the window so we can still emit a stored block even\n       *     when input comes from standard input.  (This can also be done for\n       *     all blocks if lit_bufsize is not greater than 32K.)\n       *   - if compression is not successful for a file smaller than 64K, we can\n       *     even emit a stored file instead of a stored block (saving 5 bytes).\n       *     This is applicable only for zip (not gzip or zlib).\n       *   - creating new Huffman trees less frequently may not provide fast\n       *     adaptation to changes in the input data statistics. (Take for\n       *     example a binary file with poorly compressible code followed by\n       *     a highly compressible string table.) Smaller buffer sizes give\n       *     fast adaptation but have of course the overhead of transmitting\n       *     trees more frequently.\n       *   - I can't count above 4\n       */\n\n      this.last_lit = 0\n      /* running index in l_buf */\n\n      this.d_buf = 0\n      /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n       * the same number of elements. To use different lengths, an extra flag\n       * array would be necessary.\n       */\n\n      this.opt_len = 0\n      /* bit length of current block with optimal trees */\n\n      this.static_len = 0\n      /* bit length of current block with static trees */\n\n      this.matches = 0\n      /* number of string matches in current block */\n\n      this.insert = 0\n      /* bytes at end of window left to insert */\n\n      this.bi_buf = 0\n      /* Output buffer. bits are inserted starting at the bottom (least\n       * significant bits).\n       */\n\n      this.bi_valid = 0\n      /* Number of valid bits in bi_buf.  All bits above the last valid bit\n       * are always zero.\n       */\n      // Used for window memory init. We safely ignore it for JS. That makes\n      // sense only for pointers and memory check tools.\n      // this.high_water = 0;\n\n      /* High water mark offset in window for initialized bytes -- bytes above\n       * this are set to zero in order to avoid memory check warnings when\n       * longest match routines access bytes past the input.  This is then\n       * updated to the new high water mark.\n       */\n    }\n\n    var deflateResetKeep = function deflateResetKeep(strm) {\n      if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR)\n      }\n\n      strm.total_in = strm.total_out = 0\n      strm.data_type = Z_UNKNOWN$1\n      var s = strm.state\n      s.pending = 0\n      s.pending_out = 0\n\n      if (s.wrap < 0) {\n        s.wrap = -s.wrap\n        /* was made negative by deflate(..., Z_FINISH); */\n      }\n\n      s.status = s.wrap ? INIT_STATE : BUSY_STATE\n      strm.adler =\n        s.wrap === 2\n          ? 0 // crc32(0, Z_NULL, 0)\n          : 1 // adler32(0, Z_NULL, 0)\n\n      s.last_flush = Z_NO_FLUSH\n\n      _tr_init$1(s)\n\n      return Z_OK\n    }\n\n    var deflateReset = function deflateReset(strm) {\n      var ret = deflateResetKeep(strm)\n\n      if (ret === Z_OK) {\n        lm_init(strm.state)\n      }\n\n      return ret\n    }\n\n    var deflateSetHeader = function deflateSetHeader(strm, head) {\n      if (!strm || !strm.state) {\n        return Z_STREAM_ERROR\n      }\n\n      if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR\n      }\n\n      strm.state.gzhead = head\n      return Z_OK\n    }\n\n    var deflateInit2 = function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n      if (!strm) {\n        // === Z_NULL\n        return Z_STREAM_ERROR\n      }\n\n      var wrap = 1\n\n      if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6\n      }\n\n      if (windowBits < 0) {\n        /* suppress zlib wrapper */\n        wrap = 0\n        windowBits = -windowBits\n      } else if (windowBits > 15) {\n        wrap = 2\n        /* write gzip wrapper instead */\n\n        windowBits -= 16\n      }\n\n      if (\n        memLevel < 1 ||\n        memLevel > MAX_MEM_LEVEL ||\n        method !== Z_DEFLATED ||\n        windowBits < 8 ||\n        windowBits > 15 ||\n        level < 0 ||\n        level > 9 ||\n        strategy < 0 ||\n        strategy > Z_FIXED$1\n      ) {\n        return err(strm, Z_STREAM_ERROR)\n      }\n\n      if (windowBits === 8) {\n        windowBits = 9\n      }\n      /* until 256-byte window bug fixed */\n\n      var s = new DeflateState()\n      strm.state = s\n      s.strm = strm\n      s.wrap = wrap\n      s.gzhead = null\n      s.w_bits = windowBits\n      s.w_size = 1 << s.w_bits\n      s.w_mask = s.w_size - 1\n      s.hash_bits = memLevel + 7\n      s.hash_size = 1 << s.hash_bits\n      s.hash_mask = s.hash_size - 1\n      s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1)\n      s.window = new Uint8Array(s.w_size * 2)\n      s.head = new Uint16Array(s.hash_size)\n      s.prev = new Uint16Array(s.w_size) // Don't need mem init magic for JS.\n      // s.high_water = 0;  /* nothing written to s->window yet */\n\n      s.lit_bufsize = 1 << (memLevel + 6)\n      /* 16K elements by default */\n\n      s.pending_buf_size = s.lit_bufsize * 4\n      // overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n      // s->pending_buf = (uchf *) overlay;\n\n      // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n      s.pending_buf = new Uint8Array(s.pending_buf_size)\n      // s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\n      s.d_buf = 1 * s.lit_bufsize // s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\n      s.l_buf = (1 + 2) * s.lit_bufsize\n      s.level = level\n      s.strategy = strategy\n      s.method = method\n      return deflateReset(strm)\n    }\n\n    var deflateInit = function deflateInit(strm, level) {\n      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)\n    }\n\n    var deflate = function deflate(strm, flush) {\n      var beg\n      var val // for gzip header write only\n\n      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR\n      }\n\n      var s = strm.state\n\n      if (!strm.output || (!strm.input && strm.avail_in !== 0) || (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)\n      }\n\n      s.strm = strm\n      /* just in case */\n\n      var old_flush = s.last_flush\n      s.last_flush = flush\n      /* Write the header */\n\n      if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n          // GZIP header\n          strm.adler = 0 // crc32(0L, Z_NULL, 0);\n\n          put_byte(s, 31)\n          put_byte(s, 139)\n          put_byte(s, 8)\n\n          if (!s.gzhead) {\n            // s->gzhead == Z_NULL\n            put_byte(s, 0)\n            put_byte(s, 0)\n            put_byte(s, 0)\n            put_byte(s, 0)\n            put_byte(s, 0)\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0)\n            put_byte(s, OS_CODE)\n            s.status = BUSY_STATE\n          } else {\n            put_byte(\n              s,\n              (s.gzhead.text ? 1 : 0) +\n                (s.gzhead.hcrc ? 2 : 0) +\n                (!s.gzhead.extra ? 0 : 4) +\n                (!s.gzhead.name ? 0 : 8) +\n                (!s.gzhead.comment ? 0 : 16)\n            )\n            put_byte(s, s.gzhead.time & 0xff)\n            put_byte(s, (s.gzhead.time >> 8) & 0xff)\n            put_byte(s, (s.gzhead.time >> 16) & 0xff)\n            put_byte(s, (s.gzhead.time >> 24) & 0xff)\n            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0)\n            put_byte(s, s.gzhead.os & 0xff)\n\n            if (s.gzhead.extra && s.gzhead.extra.length) {\n              put_byte(s, s.gzhead.extra.length & 0xff)\n              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff)\n            }\n\n            if (s.gzhead.hcrc) {\n              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0)\n            }\n\n            s.gzindex = 0\n            s.status = EXTRA_STATE\n          }\n        } // DEFLATE header\n        else {\n          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8\n          var level_flags = -1\n\n          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n            level_flags = 0\n          } else if (s.level < 6) {\n            level_flags = 1\n          } else if (s.level === 6) {\n            level_flags = 2\n          } else {\n            level_flags = 3\n          }\n\n          header |= level_flags << 6\n\n          if (s.strstart !== 0) {\n            header |= PRESET_DICT\n          }\n\n          header += 31 - (header % 31)\n          s.status = BUSY_STATE\n          putShortMSB(s, header)\n          /* Save the adler32 of the preset dictionary: */\n\n          if (s.strstart !== 0) {\n            putShortMSB(s, strm.adler >>> 16)\n            putShortMSB(s, strm.adler & 0xffff)\n          }\n\n          strm.adler = 1 // adler32(0L, Z_NULL, 0);\n        }\n      } // #ifdef GZIP\n\n      if (s.status === EXTRA_STATE) {\n        if (\n          s.gzhead.extra\n          /* != Z_NULL */\n        ) {\n          beg = s.pending\n          /* start of bytes to update crc */\n\n          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n              }\n\n              flush_pending(strm)\n              beg = s.pending\n\n              if (s.pending === s.pending_buf_size) {\n                break\n              }\n            }\n\n            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff)\n            s.gzindex++\n          }\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          if (s.gzindex === s.gzhead.extra.length) {\n            s.gzindex = 0\n            s.status = NAME_STATE\n          }\n        } else {\n          s.status = NAME_STATE\n        }\n      }\n\n      if (s.status === NAME_STATE) {\n        if (\n          s.gzhead.name\n          /* != Z_NULL */\n        ) {\n          beg = s.pending\n          /* start of bytes to update crc */\n          // int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n              }\n\n              flush_pending(strm)\n              beg = s.pending\n\n              if (s.pending === s.pending_buf_size) {\n                val = 1\n                break\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n\n            if (s.gzindex < s.gzhead.name.length) {\n              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff\n            } else {\n              val = 0\n            }\n\n            put_byte(s, val)\n          } while (val !== 0)\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          if (val === 0) {\n            s.gzindex = 0\n            s.status = COMMENT_STATE\n          }\n        } else {\n          s.status = COMMENT_STATE\n        }\n      }\n\n      if (s.status === COMMENT_STATE) {\n        if (\n          s.gzhead.comment\n          /* != Z_NULL */\n        ) {\n          beg = s.pending\n          /* start of bytes to update crc */\n          // int val;\n\n          do {\n            if (s.pending === s.pending_buf_size) {\n              if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n              }\n\n              flush_pending(strm)\n              beg = s.pending\n\n              if (s.pending === s.pending_buf_size) {\n                val = 1\n                break\n              }\n            } // JS specific: little magic to add zero terminator to end of string\n\n            if (s.gzindex < s.gzhead.comment.length) {\n              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff\n            } else {\n              val = 0\n            }\n\n            put_byte(s, val)\n          } while (val !== 0)\n\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n\n          if (val === 0) {\n            s.status = HCRC_STATE\n          }\n        } else {\n          s.status = HCRC_STATE\n        }\n      }\n\n      if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n          if (s.pending + 2 > s.pending_buf_size) {\n            flush_pending(strm)\n          }\n\n          if (s.pending + 2 <= s.pending_buf_size) {\n            put_byte(s, strm.adler & 0xff)\n            put_byte(s, (strm.adler >> 8) & 0xff)\n            strm.adler = 0 // crc32(0L, Z_NULL, 0);\n\n            s.status = BUSY_STATE\n          }\n        } else {\n          s.status = BUSY_STATE\n        }\n      } // #endif\n\n      /* Flush as much pending output as possible */\n\n      if (s.pending !== 0) {\n        flush_pending(strm)\n\n        if (strm.avail_out === 0) {\n          /* Since avail_out is 0, deflate will be called again with\n           * more output space, but possibly with both pending and\n           * avail_in equal to zero. There won't be anything to do,\n           * but this is not an error situation so make sure we\n           * return OK instead of BUF_ERROR at next call of deflate:\n           */\n          s.last_flush = -1\n          return Z_OK\n        }\n        /* Make sure there is something to do and avoid duplicate consecutive\n         * flushes. For repeated and useless calls with Z_FINISH, we keep\n         * returning Z_STREAM_END instead of Z_BUF_ERROR.\n         */\n      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR)\n      }\n      /* User must not provide more input after the first FINISH: */\n\n      if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR)\n      }\n      /* Start a new block or continue the current one.\n       */\n\n      if (strm.avail_in !== 0 || s.lookahead !== 0 || (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n        var bstate =\n          s.strategy === Z_HUFFMAN_ONLY\n            ? deflate_huff(s, flush)\n            : s.strategy === Z_RLE\n            ? deflate_rle(s, flush)\n            : configuration_table[s.level].func(s, flush)\n\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n          s.status = FINISH_STATE\n        }\n\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n          if (strm.avail_out === 0) {\n            s.last_flush = -1\n            /* avoid BUF_ERROR next call, see above */\n          }\n\n          return Z_OK\n          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n           * of deflate should use the same flush parameter to make sure\n           * that the flush is complete. So we don't have to output an\n           * empty block here, this will be done at next call. This also\n           * ensures that for a very small output buffer, we emit at most\n           * one empty block.\n           */\n        }\n\n        if (bstate === BS_BLOCK_DONE) {\n          if (flush === Z_PARTIAL_FLUSH) {\n            _tr_align$1(s)\n          } else if (flush !== Z_BLOCK) {\n            /* FULL_FLUSH or SYNC_FLUSH */\n            _tr_stored_block$1(s, 0, 0, false)\n            /* For a full flush, this empty block will be recognized\n             * as a special marker by inflate_sync().\n             */\n\n            if (flush === Z_FULL_FLUSH) {\n              /** * CLEAR_HASH(s); ** */\n\n              /* forget history */\n              zero$1(s.head) // Fill with NIL (= 0);\n\n              if (s.lookahead === 0) {\n                s.strstart = 0\n                s.block_start = 0\n                s.insert = 0\n              }\n            }\n          }\n\n          flush_pending(strm)\n\n          if (strm.avail_out === 0) {\n            s.last_flush = -1\n            /* avoid BUF_ERROR at next call, see above */\n\n            return Z_OK\n          }\n        }\n      } // Assert(strm->avail_out > 0, \"bug2\");\n      // if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n      if (flush !== Z_FINISH) {\n        return Z_OK\n      }\n\n      if (s.wrap <= 0) {\n        return Z_STREAM_END\n      }\n      /* Write the trailer */\n\n      if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff)\n        put_byte(s, (strm.adler >> 8) & 0xff)\n        put_byte(s, (strm.adler >> 16) & 0xff)\n        put_byte(s, (strm.adler >> 24) & 0xff)\n        put_byte(s, strm.total_in & 0xff)\n        put_byte(s, (strm.total_in >> 8) & 0xff)\n        put_byte(s, (strm.total_in >> 16) & 0xff)\n        put_byte(s, (strm.total_in >> 24) & 0xff)\n      } else {\n        putShortMSB(s, strm.adler >>> 16)\n        putShortMSB(s, strm.adler & 0xffff)\n      }\n\n      flush_pending(strm)\n      /* If avail_out is zero, the application will call deflate again\n       * to flush the rest.\n       */\n\n      if (s.wrap > 0) {\n        s.wrap = -s.wrap\n      }\n      /* write the trailer only once! */\n\n      return s.pending !== 0 ? Z_OK : Z_STREAM_END\n    }\n\n    var deflateEnd = function deflateEnd(strm) {\n      if (\n        !strm ||\n        /* == Z_NULL */\n        !strm.state\n        /* == Z_NULL */\n      ) {\n        return Z_STREAM_ERROR\n      }\n\n      var status = strm.state.status\n\n      if (\n        status !== INIT_STATE &&\n        status !== EXTRA_STATE &&\n        status !== NAME_STATE &&\n        status !== COMMENT_STATE &&\n        status !== HCRC_STATE &&\n        status !== BUSY_STATE &&\n        status !== FINISH_STATE\n      ) {\n        return err(strm, Z_STREAM_ERROR)\n      }\n\n      strm.state = null\n      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK\n    }\n    /* =========================================================================\n     * Initializes the compression dictionary from the given byte\n     * sequence without producing any compressed output.\n     */\n\n    var deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {\n      var dictLength = dictionary.length\n\n      if (\n        !strm ||\n        /* == Z_NULL */\n        !strm.state\n        /* == Z_NULL */\n      ) {\n        return Z_STREAM_ERROR\n      }\n\n      var s = strm.state\n      var wrap = s.wrap\n\n      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n        return Z_STREAM_ERROR\n      }\n      /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\n      if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */\n        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0)\n      }\n\n      s.wrap = 0\n      /* avoid computing Adler-32 in read_buf */\n\n      /* if dictionary would fill window, just replace the history */\n\n      if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n          /* already empty otherwise */\n\n          /** * CLEAR_HASH(s); ** */\n          zero$1(s.head) // Fill with NIL (= 0);\n\n          s.strstart = 0\n          s.block_start = 0\n          s.insert = 0\n        }\n        /* use the tail */\n        // dictionary = dictionary.slice(dictLength - s.w_size);\n\n        var tmpDict = new Uint8Array(s.w_size)\n        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0)\n        dictionary = tmpDict\n        dictLength = s.w_size\n      }\n      /* insert dictionary into window and hash */\n\n      var avail = strm.avail_in\n      var next = strm.next_in\n      var input = strm.input\n      strm.avail_in = dictLength\n      strm.next_in = 0\n      strm.input = dictionary\n      fill_window(s)\n\n      while (s.lookahead >= MIN_MATCH$1) {\n        var str = s.strstart\n        var n = s.lookahead - (MIN_MATCH$1 - 1)\n\n        do {\n          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1])\n          s.prev[str & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = str\n          str++\n        } while (--n)\n\n        s.strstart = str\n        s.lookahead = MIN_MATCH$1 - 1\n        fill_window(s)\n      }\n\n      s.strstart += s.lookahead\n      s.block_start = s.strstart\n      s.insert = s.lookahead\n      s.lookahead = 0\n      s.match_length = s.prev_length = MIN_MATCH$1 - 1\n      s.match_available = 0\n      strm.next_in = next\n      strm.input = input\n      strm.avail_in = avail\n      s.wrap = wrap\n      return Z_OK\n    }\n\n    var deflateInit_1 = deflateInit\n    var deflateInit2_1 = deflateInit2\n    var deflateReset_1 = deflateReset\n    var deflateResetKeep_1 = deflateResetKeep\n    var deflateSetHeader_1 = deflateSetHeader\n    var deflate_2 = deflate\n    var deflateEnd_1 = deflateEnd\n    var deflateSetDictionary_1 = deflateSetDictionary\n    var deflateInfo = 'pako deflate (from Nodeca project)'\n    /* Not implemented\n  module.exports.deflateBound = deflateBound;\n  module.exports.deflateCopy = deflateCopy;\n  module.exports.deflateParams = deflateParams;\n  module.exports.deflatePending = deflatePending;\n  module.exports.deflatePrime = deflatePrime;\n  module.exports.deflateTune = deflateTune;\n  */\n\n    var deflate_1 = {\n      deflateInit: deflateInit_1,\n      deflateInit2: deflateInit2_1,\n      deflateReset: deflateReset_1,\n      deflateResetKeep: deflateResetKeep_1,\n      deflateSetHeader: deflateSetHeader_1,\n      deflate: deflate_2,\n      deflateEnd: deflateEnd_1,\n      deflateSetDictionary: deflateSetDictionary_1,\n      deflateInfo,\n    }\n\n    // Join array of chunks to single array.\n    function flattenChunks(chunks) {\n      // calculate data length\n      var len = 0\n\n      for (var i = 0, l = chunks.length; i < l; i++) {\n        len += chunks[i].length\n      } // join chunks\n\n      var result = new Uint8Array(len)\n\n      for (var _i = 0, pos = 0, _l = chunks.length; _i < _l; _i++) {\n        var chunk = chunks[_i]\n        result.set(chunk, pos)\n        pos += chunk.length\n      }\n\n      return result\n    }\n\n    // String encode/decode helpers\n    //\n    // - apply(Array) can fail on Android 2.2\n    // - apply(Uint8Array) can fail on iOS 5.1 Safari\n    //\n\n    // Table with utf8 lengths (calculated by first byte of sequence)\n    // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n    // because max possible codepoint is 0x10ffff\n\n    var _utf8len = new Uint8Array(256)\n\n    for (var q = 0; q < 256; q++) {\n      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1\n    }\n\n    _utf8len[254] = _utf8len[254] = 1 // Invalid sequence start\n    // convert string to array (typed, when possible)\n\n    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n    //\n    // This software is provided 'as-is', without any express or implied\n    // warranty. In no event will the authors be held liable for any damages\n    // arising from the use of this software.\n    //\n    // Permission is granted to anyone to use this software for any purpose,\n    // including commercial applications, and to alter it and redistribute it\n    // freely, subject to the following restrictions:\n    //\n    // 1. The origin of this software must not be misrepresented; you must not\n    //   claim that you wrote the original software. If you use this software\n    //   in a product, an acknowledgment in the product documentation would be\n    //   appreciated but is not required.\n    // 2. Altered source versions must be plainly marked as such, and must not be\n    //   misrepresented as being the original software.\n    // 3. This notice may not be removed or altered from any source distribution.\n\n    function ZStream() {\n      /* next input byte */\n      this.input = null // JS specific, because we have no pointers\n\n      this.next_in = 0\n      /* number of bytes available at input */\n\n      this.avail_in = 0\n      /* total number of input bytes read so far */\n\n      this.total_in = 0\n      /* next output byte should be put there */\n\n      this.output = null // JS specific, because we have no pointers\n\n      this.next_out = 0\n      /* remaining free space at output */\n\n      this.avail_out = 0\n      /* total number of bytes output so far */\n\n      this.total_out = 0\n      /* last error message, NULL if no error */\n\n      this.msg = ''\n      /* Z_NULL */\n      /* not visible by applications */\n\n      this.state = null\n      /* best guess about the data type: binary or text */\n\n      this.data_type = 2\n      /* Z_UNKNOWN */\n      /* adler32 value of the uncompressed data */\n\n      this.adler = 0\n    }\n\n    var zstream = ZStream\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    var toString = Object.prototype.toString\n    /* Public constants ========================================================== */\n\n    /* =========================================================================== */\n\n    var Z_NO_FLUSH$1 = constants.Z_NO_FLUSH\n    var Z_SYNC_FLUSH = constants.Z_SYNC_FLUSH\n    var Z_FULL_FLUSH$1 = constants.Z_FULL_FLUSH\n    var Z_FINISH$1 = constants.Z_FINISH\n    var Z_OK$1 = constants.Z_OK\n    var Z_STREAM_END$1 = constants.Z_STREAM_END\n    var Z_DEFAULT_COMPRESSION$1 = constants.Z_DEFAULT_COMPRESSION\n    var Z_DEFAULT_STRATEGY$1 = constants.Z_DEFAULT_STRATEGY\n    var Z_DEFLATED$1 = constants.Z_DEFLATED\n    /* =========================================================================== */\n\n    /**\n     * class Deflate\n     *\n     * Generic JS-style wrapper for zlib calls. If you don't need\n     * streaming behaviour - use more simple functions: [[deflate]],\n     * [[deflateRaw]] and [[gzip]].\n     * */\n\n    /* internal\n     * Deflate.chunks -> Array\n     *\n     * Chunks of output data, if [[Deflate#onData]] not overridden.\n     * */\n\n    /**\n     * Deflate.result -> Uint8Array\n     *\n     * Compressed result, generated by default [[Deflate#onData]]\n     * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n     * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n     * */\n\n    /**\n     * Deflate.err -> Number\n     *\n     * Error code after deflate finished. 0 (Z_OK) on success.\n     * You will not need it in real life, because deflate errors\n     * are possible only on wrong options or bad `onData` / `onEnd`\n     * custom handlers.\n     * */\n\n    /**\n     * Deflate.msg -> String\n     *\n     * Error message, if [[Deflate.err]] != 0\n     * */\n\n    /**\n     * new Deflate(options)\n     * - options (Object): zlib deflate options.\n     *\n     * Creates new deflator instance with specified params. Throws exception\n     * on bad params. Supported options:\n     *\n     * - `level`\n     * - `windowBits`\n     * - `memLevel`\n     * - `strategy`\n     * - `dictionary`\n     *\n     * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n     * for more information on these.\n     *\n     * Additional options, for internal needs:\n     *\n     * * `chunkSize` - size of generated data chunks (16K by default)\n     * * `raw` (Boolean) - do raw deflate\n     * * `gzip` (Boolean) - create gzip wrapper\n     * * `header` (Object) - custom header for gzip\n     * ** `text` (Boolean) - true if compressed data believed to be text\n     * ** `time` (Number) - modification time, unix timestamp\n     * ** `os` (Number) - operation system code\n     * ** `extra` (Array) - array of bytes with extra data (max 65536)\n     * ** `name` (String) - file name (binary string)\n     * ** `comment` (String) - comment (binary string)\n     * ** `hcrc` (Boolean) - true if header crc should be added\n     *\n     * ##### Example:\n     *\n     * ```javascript\n     * const pako = require('pako')\n     *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n     *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n     *\n     * const deflate = new pako.Deflate({ level: 3});\n     *\n     * deflate.push(chunk1, false);\n     * deflate.push(chunk2, true);  // true -> last chunk\n     *\n     * if (deflate.err) { throw new Error(deflate.err); }\n     *\n     * console.log(deflate.result);\n     * ```\n     * */\n\n    function Deflate() {\n      this.options = {\n        level: Z_DEFAULT_COMPRESSION$1,\n        method: Z_DEFLATED$1,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY$1,\n      }\n      var opt = this.options\n\n      if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits\n      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16\n      }\n\n      this.err = 0 // error code, if happens (0 = Z_OK)\n\n      this.msg = '' // error message\n\n      this.ended = false // used to avoid multiple onEnd() calls\n\n      this.chunks = [] // chunks of compressed data\n\n      this.strm = new zstream()\n      this.strm.avail_out = 0\n      var status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy)\n\n      if (status !== Z_OK$1) {\n        throw new Error(messages[status])\n      }\n\n      if (opt.header) {\n        deflate_1.deflateSetHeader(this.strm, opt.header)\n      }\n\n      if (opt.dictionary) {\n        var dict // Convert data if needed\n\n        if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n          dict = new Uint8Array(opt.dictionary)\n        } else {\n          dict = opt.dictionary\n        }\n\n        status = deflate_1.deflateSetDictionary(this.strm, dict)\n\n        if (status !== Z_OK$1) {\n          throw new Error(messages[status])\n        }\n\n        this._dict_set = true\n      }\n    }\n    /**\n     * Deflate#push(data[, flush_mode]) -> Boolean\n     * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n     * converted to utf8 byte sequence.\n     * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n     * See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n     *\n     * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n     * new compressed chunks. Returns `true` on success. The last data block must\n     * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n     * buffers and call [[Deflate#onEnd]].\n     *\n     * On fail call [[Deflate#onEnd]] with error code and return false.\n     *\n     * ##### Example\n     *\n     * ```javascript\n     * push(chunk, false); // push one of data chunks\n     * ...\n     * push(chunk, true);  // push last chunk\n     * ```\n     * */\n\n    Deflate.prototype.push = function (data, flush_mode) {\n      var strm = this.strm\n      var chunkSize = this.options.chunkSize\n\n      var status\n      var _flush_mode\n\n      if (this.ended) {\n        return false\n      }\n\n      if (flush_mode === ~~flush_mode) {\n        _flush_mode = flush_mode\n      } else {\n        _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1\n      } // Convert data if needed\n\n      if (toString.call(data) === '[object ArrayBuffer]') {\n        strm.input = new Uint8Array(data)\n      } else {\n        strm.input = data\n      }\n\n      strm.next_in = 0\n      strm.avail_in = strm.input.length\n\n      for (;;) {\n        if (strm.avail_out === 0) {\n          strm.output = new Uint8Array(chunkSize)\n          strm.next_out = 0\n          strm.avail_out = chunkSize\n        } // Make sure avail_out > 6 to avoid repeating markers\n\n        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {\n          this.onData(strm.output.subarray(0, strm.next_out))\n          strm.avail_out = 0\n          continue\n        }\n\n        status = deflate_1.deflate(strm, _flush_mode) // Ended => flush and finish\n\n        if (status === Z_STREAM_END$1) {\n          if (strm.next_out > 0) {\n            this.onData(strm.output.subarray(0, strm.next_out))\n          }\n\n          status = deflate_1.deflateEnd(this.strm)\n          this.onEnd(status)\n          this.ended = true\n          return status === Z_OK$1\n        } // Flush if out buffer full\n\n        if (strm.avail_out === 0) {\n          this.onData(strm.output)\n          continue\n        } // Flush if requested and has data\n\n        if (_flush_mode > 0 && strm.next_out > 0) {\n          this.onData(strm.output.subarray(0, strm.next_out))\n          strm.avail_out = 0\n          continue\n        }\n\n        if (strm.avail_in === 0) {\n          break\n        }\n      }\n\n      return true\n    }\n    /**\n     * Deflate#onData(chunk) -> Void\n     * - chunk (Uint8Array): output data.\n     *\n     * By default, stores data blocks in `chunks[]` property and glue\n     * those in `onEnd`. Override this handler, if you need another behaviour.\n     * */\n\n    Deflate.prototype.onData = function (chunk) {\n      this.chunks.push(chunk)\n    }\n    /**\n     * Deflate#onEnd(status) -> Void\n     * - status (Number): deflate status. 0 (Z_OK) on success,\n     * other if not.\n     *\n     * Called once after you tell deflate that the input stream is\n     * complete (Z_FINISH). By default - join collected chunks,\n     * free memory and fill `results` / `err` properties.\n     * */\n\n    Deflate.prototype.onEnd = function (status) {\n      // On success - join\n      if (status === Z_OK$1) {\n        this.result = flattenChunks(this.chunks)\n      }\n\n      this.chunks = []\n      this.err = status\n      this.msg = this.strm.msg\n    }\n\n    // https://github.com/nodeca/pako/blob/26dff4fb3472c5532b3bd8856421146d35ab7592/lib/utils/strings.js#L26\n    function string2buf(str) {\n      if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n        return new TextEncoder().encode(str)\n      }\n\n      let buf\n      let c\n      let c2\n      let m_pos\n      let i\n      let str_len = str.length\n      let buf_len = 0\n\n      // count binary size\n      for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos)\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n          c2 = str.charCodeAt(m_pos + 1)\n          if ((c2 & 0xfc00) === 0xdc00) {\n            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)\n            m_pos++\n          }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4\n      }\n\n      // allocate buffer\n      buf = new Uint8Array(buf_len)\n\n      // convert\n      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos)\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n          c2 = str.charCodeAt(m_pos + 1)\n          if ((c2 & 0xfc00) === 0xdc00) {\n            c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00)\n            m_pos++\n          }\n        }\n        if (c < 0x80) {\n          /* one byte */\n          buf[i++] = c\n        } else if (c < 0x800) {\n          /* two bytes */\n          buf[i++] = 0xc0 | (c >>> 6)\n          buf[i++] = 0x80 | (c & 0x3f)\n        } else if (c < 0x10000) {\n          /* three bytes */\n          buf[i++] = 0xe0 | (c >>> 12)\n          buf[i++] = 0x80 | ((c >>> 6) & 0x3f)\n          buf[i++] = 0x80 | (c & 0x3f)\n        } else {\n          /* four bytes */\n          buf[i++] = 0xf0 | (c >>> 18)\n          buf[i++] = 0x80 | ((c >>> 12) & 0x3f)\n          buf[i++] = 0x80 | ((c >>> 6) & 0x3f)\n          buf[i++] = 0x80 | (c & 0x3f)\n        }\n      }\n\n      return buf\n    }\n\n    return { Deflate, constants, string2buf }\n  }\n}\n","import type { EventEmitter, TimeoutId } from '@datadog/browser-core'\nimport { ONE_SECOND, addEventListener, DOM_EVENT, monitor } from '@datadog/browser-core'\nimport type { LifeCycle, ViewContexts, RumSessionManager } from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport type { BrowserRecord, BrowserSegmentMetadata, CreationReason, SegmentContext } from '../../types'\nimport type { DeflateWorker } from './deflateWorker'\nimport { Segment } from './segment'\n\nexport const SEGMENT_DURATION_LIMIT = 30 * ONE_SECOND\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport let SEGMENT_BYTES_LIMIT = 60_000\n\n// Segments are the main data structure for session replays. They contain context information used\n// for indexing or UI needs, and a list of records (RRWeb 'events', renamed to avoid confusing\n// namings). They are stored without any processing from the intake, and fetched one after the\n// other while a session is being replayed. Their encoding (deflate) are carefully crafted to allow\n// concatenating multiple segments together. Segments have a size overhead (metadata), so our goal is to\n// build segments containing as many records as possible while complying with the various flush\n// strategies to guarantee a good replay quality.\n//\n// When the recording starts, a segment is initially created.  The segment is flushed (finalized and\n// sent) based on various events (non-exhaustive list):\n//\n// * the page visibility change or becomes to unload\n// * the segment duration reaches a limit\n// * the encoded segment bytes count reaches a limit\n// * ...\n//\n// A segment cannot be created without its context.  If the RUM session ends and no session id is\n// available when creating a new segment, records will be ignored, until the session is renewed and\n// a new session id is available.\n//\n// Empty segments (segments with no record) aren't useful and should be ignored.\n//\n// To help investigate session replays issues, each segment is created with a \"creation reason\",\n// indicating why the session has been created.\n\nexport function startSegmentCollection(\n  lifeCycle: LifeCycle,\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  send: (data: Uint8Array, metadata: BrowserSegmentMetadata, rawSegmentBytesCount: number) => void,\n  worker: DeflateWorker\n) {\n  return doStartSegmentCollection(\n    lifeCycle,\n    () => computeSegmentContext(applicationId, sessionManager, viewContexts),\n    send,\n    worker\n  )\n}\n\nconst enum SegmentCollectionStatus {\n  WaitingForInitialRecord,\n  SegmentPending,\n  Stopped,\n}\ntype SegmentCollectionState =\n  | {\n      status: SegmentCollectionStatus.WaitingForInitialRecord\n      nextSegmentCreationReason: CreationReason\n    }\n  | {\n      status: SegmentCollectionStatus.SegmentPending\n      segment: Segment\n      expirationTimeoutId: TimeoutId\n    }\n  | {\n      status: SegmentCollectionStatus.Stopped\n    }\n\nexport function doStartSegmentCollection(\n  lifeCycle: LifeCycle,\n  getSegmentContext: () => SegmentContext | undefined,\n  send: (data: Uint8Array, metadata: BrowserSegmentMetadata, rawSegmentBytesCount: number) => void,\n  worker: DeflateWorker,\n  emitter: EventEmitter = window\n) {\n  let state: SegmentCollectionState = {\n    status: SegmentCollectionStatus.WaitingForInitialRecord,\n    nextSegmentCreationReason: 'init',\n  }\n\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, () => {\n    flushSegment('view_change')\n  })\n\n  const { unsubscribe: unsubscribeBeforeUnload } = lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, () => {\n    flushSegment('before_unload')\n  })\n\n  const { stop: unsubscribeVisibilityChange } = addEventListener(\n    emitter,\n    DOM_EVENT.VISIBILITY_CHANGE,\n    () => {\n      if (document.visibilityState === 'hidden') {\n        flushSegment('visibility_hidden')\n      }\n    },\n    { capture: true }\n  )\n\n  function flushSegment(nextSegmentCreationReason?: CreationReason) {\n    if (state.status === SegmentCollectionStatus.SegmentPending) {\n      state.segment.flush()\n      clearTimeout(state.expirationTimeoutId)\n    }\n\n    if (nextSegmentCreationReason) {\n      state = {\n        status: SegmentCollectionStatus.WaitingForInitialRecord,\n        nextSegmentCreationReason,\n      }\n    } else {\n      state = {\n        status: SegmentCollectionStatus.Stopped,\n      }\n    }\n  }\n\n  function createNewSegment(creationReason: CreationReason, initialRecord: BrowserRecord) {\n    const context = getSegmentContext()\n    if (!context) {\n      return\n    }\n\n    const segment = new Segment(\n      worker,\n      context,\n      creationReason,\n      initialRecord,\n      (compressedSegmentBytesCount) => {\n        if (!segment.isFlushed && compressedSegmentBytesCount > SEGMENT_BYTES_LIMIT) {\n          flushSegment('segment_bytes_limit')\n        }\n      },\n      (data, rawSegmentBytesCount) => {\n        send(data, segment.metadata, rawSegmentBytesCount)\n      }\n    )\n\n    state = {\n      status: SegmentCollectionStatus.SegmentPending,\n      segment,\n      expirationTimeoutId: setTimeout(\n        monitor(() => {\n          flushSegment('segment_duration_limit')\n        }),\n        SEGMENT_DURATION_LIMIT\n      ),\n    }\n  }\n\n  return {\n    addRecord: (record: BrowserRecord) => {\n      switch (state.status) {\n        case SegmentCollectionStatus.WaitingForInitialRecord:\n          createNewSegment(state.nextSegmentCreationReason, record)\n          break\n\n        case SegmentCollectionStatus.SegmentPending:\n          state.segment.addRecord(record)\n          break\n      }\n    },\n\n    stop: () => {\n      flushSegment()\n      unsubscribeViewCreated()\n      unsubscribeBeforeUnload()\n      unsubscribeVisibilityChange()\n    },\n  }\n}\n\nexport function computeSegmentContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts\n) {\n  const session = sessionManager.findTrackedSession()\n  const viewContext = viewContexts.findView()\n  if (!session || !viewContext) {\n    return undefined\n  }\n  return {\n    application: {\n      id: applicationId,\n    },\n    session: {\n      id: session.id,\n    },\n    view: {\n      id: viewContext.id,\n    },\n  }\n}\n\nexport function setSegmentBytesLimit(newSegmentBytesLimit = 60_000) {\n  SEGMENT_BYTES_LIMIT = newSegmentBytesLimit\n}\n","import { addTelemetryError, display, includes, monitor } from '@datadog/browser-core'\nimport type { DeflateWorker } from './deflateWorker'\nimport { createDeflateWorker } from './deflateWorker'\n\n/**\n * In order to be sure that the worker is correctly working, we need a round trip of\n * initialization messages, making the creation asynchronous.\n * These worker lifecycle states handle this case.\n */\nconst enum DeflateWorkerStatus {\n  Nil,\n  Loading,\n  Error,\n  Initialized,\n}\n\ntype DeflateWorkerState =\n  | {\n      status: DeflateWorkerStatus.Nil\n    }\n  | {\n      status: DeflateWorkerStatus.Loading\n      callbacks: Array<(worker?: DeflateWorker) => void>\n    }\n  | {\n      status: DeflateWorkerStatus.Error\n    }\n  | {\n      status: DeflateWorkerStatus.Initialized\n      worker: DeflateWorker\n    }\n\nlet state: DeflateWorkerState = { status: DeflateWorkerStatus.Nil }\n\nexport function startDeflateWorker(\n  callback: (worker?: DeflateWorker) => void,\n  createDeflateWorkerImpl = createDeflateWorker\n) {\n  switch (state.status) {\n    case DeflateWorkerStatus.Nil:\n      state = { status: DeflateWorkerStatus.Loading, callbacks: [callback] }\n      doStartDeflateWorker(createDeflateWorkerImpl)\n      break\n    case DeflateWorkerStatus.Loading:\n      state.callbacks.push(callback)\n      break\n    case DeflateWorkerStatus.Error:\n      callback()\n      break\n    case DeflateWorkerStatus.Initialized:\n      callback(state.worker)\n      break\n  }\n}\n\nexport function resetDeflateWorkerState() {\n  state = { status: DeflateWorkerStatus.Nil }\n}\n\n/**\n * Starts the deflate worker and handle messages and errors\n *\n * The spec allow browsers to handle worker errors differently:\n * - Chromium throws an exception\n * - Firefox fires an error event\n *\n * more details: https://bugzilla.mozilla.org/show_bug.cgi?id=1736865#c2\n */\nexport function doStartDeflateWorker(createDeflateWorkerImpl = createDeflateWorker) {\n  try {\n    const worker = createDeflateWorkerImpl()\n    worker.addEventListener('error', monitor(onError))\n    worker.addEventListener(\n      'message',\n      monitor(({ data }) => {\n        if (data.type === 'errored') {\n          onError(data.error)\n        } else if (data.type === 'initialized') {\n          onInitialized(worker)\n        }\n      })\n    )\n    worker.postMessage({ action: 'init' })\n    return worker\n  } catch (error) {\n    onError(error)\n  }\n}\n\nfunction onInitialized(worker: DeflateWorker) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    state.callbacks.forEach((callback) => callback(worker))\n    state = { status: DeflateWorkerStatus.Initialized, worker }\n  }\n}\n\nfunction onError(error: unknown) {\n  if (state.status === DeflateWorkerStatus.Loading) {\n    display.error('Session Replay recording failed to start: an error occurred while creating the Worker:', error)\n    if (error instanceof Event || (error instanceof Error && includes(error.message, 'Content Security Policy'))) {\n      display.error(\n        'Please make sure CSP is correctly configured ' +\n          'https://docs.datadoghq.com/real_user_monitoring/faq/content_security_policy'\n      )\n    } else {\n      addTelemetryError(error)\n    }\n    state.callbacks.forEach((callback) => callback())\n    state = { status: DeflateWorkerStatus.Error }\n  } else {\n    addTelemetryError(error)\n  }\n}\n","import type { HttpRequest } from '@datadog/browser-core'\nimport { objectEntries } from '@datadog/browser-core'\nimport type { BrowserSegmentMetadata } from '../types'\n\nexport function send(\n  httpRequest: HttpRequest,\n  data: Uint8Array,\n  metadata: BrowserSegmentMetadata,\n  rawSegmentBytesCount: number\n): void {\n  const formData = new FormData()\n\n  formData.append(\n    'segment',\n    new Blob([data], {\n      type: 'application/octet-stream',\n    }),\n    `${metadata.session.id}-${metadata.start}`\n  )\n\n  toFormEntries(metadata, (key, value) => formData.append(key, value))\n  formData.append('raw_segment_size', rawSegmentBytesCount.toString())\n\n  httpRequest.sendOnExit({ data: formData, bytesCount: data.byteLength })\n}\n\nexport function toFormEntries(input: object, onEntry: (key: string, value: string) => void, prefix = '') {\n  objectEntries(input as { [key: string]: unknown }).forEach(([key, value]) => {\n    if (typeof value === 'object' && value !== null) {\n      toFormEntries(value, onEntry, `${prefix}${key}.`)\n    } else {\n      onEntry(`${prefix}${key}`, String(value))\n    }\n  })\n}\n","// Keep the following in sync with packages/rum-slim/src/entries/main.ts\nimport { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { RumPublicApi } from '@datadog/browser-rum-core'\nimport { makeRumPublicApi, startRum } from '@datadog/browser-rum-core'\n\nimport { startRecording } from '../boot/startRecording'\nimport { makeRecorderApi } from '../boot/recorderApi'\n\nexport {\n  CommonProperties,\n  RumPublicApi as RumGlobal,\n  RumInitConfiguration,\n  // Events\n  RumEvent,\n  RumActionEvent,\n  RumErrorEvent,\n  RumLongTaskEvent,\n  RumResourceEvent,\n  RumViewEvent,\n  // Events context\n  RumEventDomainContext,\n  RumViewEventDomainContext,\n  RumErrorEventDomainContext,\n  RumActionEventDomainContext,\n  RumFetchResourceEventDomainContext,\n  RumXhrResourceEventDomainContext,\n  RumOtherResourceEventDomainContext,\n  RumLongTaskEventDomainContext,\n} from '@datadog/browser-rum-core'\nexport { DefaultPrivacyLevel } from '@datadog/browser-core'\n\nconst recorderApi = makeRecorderApi(startRecording)\nexport const datadogRum = makeRumPublicApi(startRum, recorderApi)\n\ninterface BrowserWindow extends Window {\n  DD_RUM?: RumPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_RUM', datadogRum)\n","import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { assign } from '../tools/utils'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport function makePublicApi<T>(stub: T): T & { onReady(callback: () => void): void; version: string } {\n  const publicApi = assign(\n    {\n      version: __BUILD_ENV__SDK_VERSION__,\n\n      // This API method is intentionally not monitored, since the only thing executed is the\n      // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n      // we don't want to interfere with the user uncaught exceptions.\n      onReady(callback: () => void) {\n        callback()\n      },\n    },\n    stub\n  )\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable: { q?: Array<() => void> } | undefined = global[name]\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n","import { canUseEventBridge, noop, runOnReadyState } from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumSessionManager,\n  RecorderApi,\n  RumConfiguration,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\nimport { getReplayStats } from '../domain/replayStats'\nimport { startDeflateWorker } from '../domain/segmentCollection'\n\nimport type { startRecording } from './startRecording'\n\nexport type StartRecording = typeof startRecording\n\nconst enum RecorderStatus {\n  // The recorder is stopped.\n  Stopped,\n  // The user started the recording while it wasn't possible yet. The recorder should start as soon\n  // as possible.\n  IntentToStart,\n  // The recorder is starting. It does not record anything yet.\n  Starting,\n  // The recorder is started, it records the session.\n  Started,\n}\ntype RecorderState =\n  | {\n      status: RecorderStatus.Stopped\n    }\n  | {\n      status: RecorderStatus.IntentToStart\n    }\n  | {\n      status: RecorderStatus.Starting\n    }\n  | {\n      status: RecorderStatus.Started\n      stopRecording: () => void\n    }\n\nexport function makeRecorderApi(\n  startRecordingImpl: StartRecording,\n  startDeflateWorkerImpl = startDeflateWorker\n): RecorderApi {\n  if (canUseEventBridge() || !isBrowserSupported()) {\n    return {\n      start: noop,\n      stop: noop,\n      getReplayStats: () => undefined,\n      onRumStart: noop,\n      isRecording: () => false,\n    }\n  }\n\n  let state: RecorderState = {\n    status: RecorderStatus.Stopped,\n  }\n\n  let startStrategy = () => {\n    state = { status: RecorderStatus.IntentToStart }\n  }\n  let stopStrategy = () => {\n    state = { status: RecorderStatus.Stopped }\n  }\n  return {\n    start: () => startStrategy(),\n    stop: () => stopStrategy(),\n    getReplayStats,\n\n    onRumStart: (\n      lifeCycle: LifeCycle,\n      configuration: RumConfiguration,\n      sessionManager: RumSessionManager,\n      viewContexts: ViewContexts\n    ) => {\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_EXPIRED, () => {\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          stopStrategy()\n          state = { status: RecorderStatus.IntentToStart }\n        }\n      })\n\n      lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n        if (state.status === RecorderStatus.IntentToStart) {\n          startStrategy()\n        }\n      })\n\n      startStrategy = () => {\n        const session = sessionManager.findTrackedSession()\n        if (!session || !session.sessionReplayAllowed) {\n          state = { status: RecorderStatus.IntentToStart }\n          return\n        }\n\n        if (state.status === RecorderStatus.Starting || state.status === RecorderStatus.Started) {\n          return\n        }\n\n        state = { status: RecorderStatus.Starting }\n\n        runOnReadyState('interactive', () => {\n          if (state.status !== RecorderStatus.Starting) {\n            return\n          }\n\n          startDeflateWorkerImpl((worker) => {\n            if (state.status !== RecorderStatus.Starting) {\n              return\n            }\n\n            if (!worker) {\n              state = {\n                status: RecorderStatus.Stopped,\n              }\n              return\n            }\n\n            const { stop: stopRecording } = startRecordingImpl(\n              lifeCycle,\n              configuration,\n              sessionManager,\n              viewContexts,\n              worker\n            )\n            state = {\n              status: RecorderStatus.Started,\n              stopRecording,\n            }\n          })\n        })\n      }\n\n      stopStrategy = () => {\n        if (state.status === RecorderStatus.Stopped) {\n          return\n        }\n\n        if (state.status === RecorderStatus.Started) {\n          state.stopRecording()\n        }\n\n        state = {\n          status: RecorderStatus.Stopped,\n        }\n      }\n\n      if (state.status === RecorderStatus.IntentToStart) {\n        startStrategy()\n      }\n    },\n\n    isRecording: () => state.status === RecorderStatus.Started,\n  }\n}\n\n/**\n * Test for Browser features used while recording\n */\nfunction isBrowserSupported() {\n  return (\n    // Array.from is a bit less supported by browsers than CSSSupportsRule, but has higher chances\n    // to be polyfilled. Test for both to be more confident. We could add more things if we find out\n    // this test is not sufficient.\n    typeof Array.from === 'function' && typeof CSSSupportsRule === 'function'\n  )\n}\n","import type { RawError, HttpRequest } from '@datadog/browser-core'\nimport { timeStampNow, createHttpRequest } from '@datadog/browser-core'\nimport type {\n  LifeCycle,\n  ViewContexts,\n  RumConfiguration,\n  RumSessionManager,\n  ViewCreatedEvent,\n} from '@datadog/browser-rum-core'\nimport { LifeCycleEventType } from '@datadog/browser-rum-core'\n\nimport { record } from '../domain/record'\nimport type { DeflateWorker } from '../domain/segmentCollection'\nimport { startSegmentCollection, SEGMENT_BYTES_LIMIT } from '../domain/segmentCollection'\nimport { send } from '../transport/send'\nimport { RecordType } from '../types'\n\nexport function startRecording(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  worker: DeflateWorker,\n  httpRequest?: HttpRequest\n) {\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n  }\n\n  const replayRequest =\n    httpRequest || createHttpRequest(configuration.sessionReplayEndpointBuilder, SEGMENT_BYTES_LIMIT, reportError)\n\n  const { addRecord, stop: stopSegmentCollection } = startSegmentCollection(\n    lifeCycle,\n    configuration.applicationId,\n    sessionManager,\n    viewContexts,\n    (data, metadata, rawSegmentBytesCount) => send(replayRequest, data, metadata, rawSegmentBytesCount),\n    worker\n  )\n\n  const {\n    stop: stopRecording,\n    takeSubsequentFullSnapshot,\n    flushMutations,\n  } = record({\n    emit: addRecord,\n    configuration,\n    lifeCycle,\n  })\n\n  const { unsubscribe: unsubscribeViewEnded } = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, () => {\n    flushMutations()\n    addRecord({\n      timestamp: timeStampNow(),\n      type: RecordType.ViewEnd,\n    })\n  })\n  const { unsubscribe: unsubscribeViewCreated } = lifeCycle.subscribe(\n    LifeCycleEventType.VIEW_CREATED,\n    (view: ViewCreatedEvent) => {\n      takeSubsequentFullSnapshot(view.startClocks.timeStamp)\n    }\n  )\n\n  return {\n    stop: () => {\n      unsubscribeViewEnded()\n      unsubscribeViewCreated()\n      stopRecording()\n      stopSegmentCollection()\n    },\n  }\n}\n","import type { Context, InitConfiguration, TimeStamp, RelativeTime } from '@datadog/browser-core'\nimport {\n  willSyntheticsInjectRum,\n  assign,\n  BoundedBuffer,\n  buildCookieOptions,\n  createContextManager,\n  deepClone,\n  makePublicApi,\n  monitor,\n  clocksNow,\n  timeStampNow,\n  display,\n  callMonitored,\n  createHandlingStack,\n  canUseEventBridge,\n  areCookiesAuthorized,\n} from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport type { ViewContexts } from '../domain/contexts/viewContexts'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport type { User, ReplayStats } from '../rawRumEvent.types'\nimport { ActionType } from '../rawRumEvent.types'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport { validateAndBuildRumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/rumEventsCollection/view/trackViews'\nimport type { startRum } from './startRum'\n\nexport type RumPublicApi = ReturnType<typeof makeRumPublicApi>\n\nexport type StartRum = typeof startRum\n\ntype StartRumResult = ReturnType<typeof startRum>\n\nexport interface RecorderApi {\n  start: () => void\n  stop: () => void\n  onRumStart: (\n    lifeCycle: LifeCycle,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewContexts: ViewContexts\n  ) => void\n  isRecording: () => boolean\n  getReplayStats: (viewId: string) => ReplayStats | undefined\n}\ninterface RumPublicApiOptions {\n  ignoreInitIfSyntheticsWillInjectRum?: boolean\n}\n\nexport function makeRumPublicApi(\n  startRumImpl: StartRum,\n  recorderApi: RecorderApi,\n  { ignoreInitIfSyntheticsWillInjectRum = true }: RumPublicApiOptions = {}\n) {\n  let isAlreadyInitialized = false\n\n  const globalContextManager = createContextManager()\n  const userContextManager = createContextManager()\n\n  let getInternalContextStrategy: StartRumResult['getInternalContext'] = () => undefined\n  let getInitConfigurationStrategy = (): InitConfiguration | undefined => undefined\n\n  let bufferApiCalls = new BoundedBuffer()\n  let addTimingStrategy: StartRumResult['addTiming'] = (name, time = timeStampNow()) => {\n    bufferApiCalls.add(() => addTimingStrategy(name, time))\n  }\n  let startViewStrategy: StartRumResult['startView'] = (options, startClocks = clocksNow()) => {\n    bufferApiCalls.add(() => startViewStrategy(options, startClocks))\n  }\n  let addActionStrategy: StartRumResult['addAction'] = (\n    action,\n    commonContext = {\n      context: globalContextManager.getContext(),\n      user: userContextManager.getContext(),\n    }\n  ) => {\n    bufferApiCalls.add(() => addActionStrategy(action, commonContext))\n  }\n  let addErrorStrategy: StartRumResult['addError'] = (\n    providedError,\n    commonContext = {\n      context: globalContextManager.getContext(),\n      user: userContextManager.getContext(),\n    }\n  ) => {\n    bufferApiCalls.add(() => addErrorStrategy(providedError, commonContext))\n  }\n\n  function initRum(initConfiguration: RumInitConfiguration) {\n    // If we are in a Synthetics test configured to automatically inject a RUM instance, we want to\n    // completely discard the customer application RUM instance by ignoring their init() call.  But,\n    // we should not ignore the init() call from the Synthetics-injected RUM instance, so the\n    // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.\n    if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {\n      return\n    }\n\n    if (canUseEventBridge()) {\n      initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n    } else if (!canHandleSession(initConfiguration)) {\n      return\n    }\n\n    if (!canInitRum(initConfiguration)) {\n      return\n    }\n\n    const configuration = validateAndBuildRumConfiguration(initConfiguration)\n    if (!configuration) {\n      return\n    }\n\n    if (!configuration.trackViewsManually) {\n      doStartRum(initConfiguration, configuration)\n    } else {\n      // drain beforeInitCalls by buffering them until we start RUM\n      // if we get a startView, drain re-buffered calls before continuing to drain beforeInitCalls\n      // in order to ensure that calls are processed in order\n      const beforeInitCalls = bufferApiCalls\n      bufferApiCalls = new BoundedBuffer()\n\n      startViewStrategy = (options) => {\n        doStartRum(initConfiguration, configuration, options)\n      }\n      beforeInitCalls.drain()\n    }\n    getInitConfigurationStrategy = () => deepClone<InitConfiguration>(initConfiguration)\n\n    isAlreadyInitialized = true\n  }\n\n  function doStartRum(\n    initConfiguration: RumInitConfiguration,\n    configuration: RumConfiguration,\n    initialViewOptions?: ViewOptions\n  ) {\n    const startRumResults = startRumImpl(\n      initConfiguration,\n      configuration,\n      () => ({\n        user: userContextManager.getContext(),\n        context: globalContextManager.getContext(),\n        hasReplay: recorderApi.isRecording() ? true : undefined,\n      }),\n      recorderApi,\n      initialViewOptions\n    )\n\n    ;({\n      startView: startViewStrategy,\n      addAction: addActionStrategy,\n      addError: addErrorStrategy,\n      addTiming: addTimingStrategy,\n      getInternalContext: getInternalContextStrategy,\n    } = startRumResults)\n    bufferApiCalls.drain()\n\n    recorderApi.onRumStart(\n      startRumResults.lifeCycle,\n      configuration,\n      startRumResults.session,\n      startRumResults.viewContexts\n    )\n  }\n\n  const startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  } = monitor((options?: string | ViewOptions) => {\n    const sanitizedOptions = typeof options === 'object' ? options : { name: options }\n    startViewStrategy(sanitizedOptions)\n  })\n\n  const rumPublicApi = makePublicApi({\n    init: monitor(initRum),\n\n    /** @deprecated: use setGlobalContextProperty instead */\n    addRumGlobalContext: monitor(globalContextManager.add),\n    setGlobalContextProperty: monitor(globalContextManager.setContextProperty),\n\n    /** @deprecated: use removeGlobalContextProperty instead */\n    removeRumGlobalContext: monitor(globalContextManager.remove),\n    removeGlobalContextProperty: monitor(globalContextManager.removeContextProperty),\n\n    /** @deprecated: use getGlobalContext instead */\n    getRumGlobalContext: monitor(globalContextManager.get),\n    getGlobalContext: monitor(globalContextManager.getContext),\n\n    /** @deprecated: use setGlobalContext instead */\n    setRumGlobalContext: monitor(globalContextManager.set),\n    setGlobalContext: monitor(globalContextManager.setContext),\n\n    clearGlobalContext: monitor(globalContextManager.clearContext),\n\n    getInternalContext: monitor((startTime?: number) => getInternalContextStrategy(startTime)),\n    getInitConfiguration: monitor(() => getInitConfigurationStrategy()),\n\n    addAction: monitor((name: string, context?: object) => {\n      addActionStrategy({\n        name,\n        context: deepClone(context as Context),\n        startClocks: clocksNow(),\n        type: ActionType.CUSTOM,\n      })\n    }),\n\n    addError: (error: unknown, context?: object) => {\n      const handlingStack = createHandlingStack()\n      callMonitored(() => {\n        addErrorStrategy({\n          error,\n          handlingStack,\n          context: deepClone(context as Context),\n          startClocks: clocksNow(),\n        })\n      })\n    },\n\n    addTiming: monitor((name: string, time?: number) => {\n      addTimingStrategy(name, time as RelativeTime | TimeStamp | undefined)\n    }),\n\n    setUser: monitor((newUser: User) => {\n      if (typeof newUser !== 'object' || !newUser) {\n        display.error('Unsupported user:', newUser)\n      } else {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n    }),\n\n    getUser: monitor(userContextManager.getContext),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n    }),\n\n    removeUserProperty: monitor(userContextManager.removeContextProperty),\n\n    /** @deprecated: renamed to clearUser */\n    removeUser: monitor(userContextManager.clearContext),\n    clearUser: monitor(userContextManager.clearContext),\n\n    startView,\n\n    startSessionReplayRecording: monitor(recorderApi.start),\n    stopSessionReplayRecording: monitor(recorderApi.stop),\n  })\n  return rumPublicApi\n\n  function sanitizeUser(newUser: Context) {\n    const shallowClonedUser = assign(newUser, {})\n    if ('id' in shallowClonedUser) {\n      shallowClonedUser.id = String(shallowClonedUser.id)\n    }\n    if ('name' in shallowClonedUser) {\n      shallowClonedUser.name = String(shallowClonedUser.name)\n    }\n    if ('email' in shallowClonedUser) {\n      shallowClonedUser.email = String(shallowClonedUser.email)\n    }\n    return shallowClonedUser\n  }\n\n  function canHandleSession(initConfiguration: RumInitConfiguration): boolean {\n    if (!areCookiesAuthorized(buildCookieOptions(initConfiguration))) {\n      display.warn('Cookies are not authorized, we will not send any data.')\n      return false\n    }\n\n    if (isLocalFile()) {\n      display.error('Execution is not allowed in the current context.')\n      return false\n    }\n    return true\n  }\n\n  function canInitRum(initConfiguration: RumInitConfiguration) {\n    if (isAlreadyInitialized) {\n      if (!initConfiguration.silentMultipleInit) {\n        display.error('DD_RUM is already initialized.')\n      }\n      return false\n    }\n    return true\n  }\n\n  function overrideInitConfigurationForBridge<C extends InitConfiguration>(initConfiguration: C): C {\n    return assign({}, initConfiguration, {\n      applicationId: '00000000-aaaa-0000-aaaa-000000000000',\n      clientToken: 'empty',\n      sampleRate: 100,\n    })\n  }\n\n  function isLocalFile() {\n    return window.location.protocol === 'file:'\n  }\n}\n","import type { Configuration, InitConfiguration, MatchOption, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  serializeConfiguration,\n  assign,\n  DefaultPrivacyLevel,\n  display,\n  isPercentage,\n  objectHasValue,\n  validateAndBuildConfiguration,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport interface RumInitConfiguration extends InitConfiguration {\n  // global options\n  applicationId: string\n  beforeSend?: ((event: RumEvent, context: RumEventDomainContext) => void | boolean) | undefined\n  /**\n   * @deprecated use sessionReplaySampleRate instead\n   */\n  premiumSampleRate?: number | undefined\n  excludedActivityUrls?: MatchOption[] | undefined\n\n  // tracing options\n  allowedTracingOrigins?: MatchOption[] | undefined\n  tracingSampleRate?: number | undefined\n\n  // replay options\n  defaultPrivacyLevel?: DefaultPrivacyLevel | undefined\n  /**\n   * @deprecated use sessionReplaySampleRate instead\n   */\n  replaySampleRate?: number | undefined\n  sessionReplaySampleRate?: number | undefined\n\n  // action options\n  trackInteractions?: boolean | undefined\n  trackFrustrations?: boolean | undefined\n  actionNameAttribute?: string | undefined\n\n  // view options\n  trackViewsManually?: boolean | undefined\n\n  trackResources?: boolean | undefined\n  trackLongTasks?: boolean | undefined\n}\n\nexport type HybridInitConfiguration = Omit<RumInitConfiguration, 'applicationId' | 'clientToken'>\n\nexport interface RumConfiguration extends Configuration {\n  // Built from init configuration\n  actionNameAttribute: string | undefined\n  allowedTracingOrigins: MatchOption[]\n  tracingSampleRate: number | undefined\n  excludedActivityUrls: MatchOption[]\n  applicationId: string\n  defaultPrivacyLevel: DefaultPrivacyLevel\n  oldPlansBehavior: boolean\n  sessionReplaySampleRate: number\n  trackInteractions: boolean\n  trackFrustrations: boolean\n  trackViewsManually: boolean\n  trackResources: boolean | undefined\n  trackLongTasks: boolean | undefined\n  version?: string\n}\n\nexport function validateAndBuildRumConfiguration(\n  initConfiguration: RumInitConfiguration\n): RumConfiguration | undefined {\n  if (!initConfiguration.applicationId) {\n    display.error('Application ID is not configured, no RUM data will be collected.')\n    return\n  }\n\n  if (\n    initConfiguration.sessionReplaySampleRate !== undefined &&\n    !isPercentage(initConfiguration.sessionReplaySampleRate)\n  ) {\n    display.error('Session Replay Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  // TODO remove fallback in next major\n  let premiumSampleRate = initConfiguration.premiumSampleRate ?? initConfiguration.replaySampleRate\n  if (premiumSampleRate !== undefined && initConfiguration.sessionReplaySampleRate !== undefined) {\n    display.warn('Ignoring Premium Sample Rate because Session Replay Sample Rate is set')\n    premiumSampleRate = undefined\n  }\n\n  if (premiumSampleRate !== undefined && !isPercentage(premiumSampleRate)) {\n    display.error('Premium Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.tracingSampleRate !== undefined && !isPercentage(initConfiguration.tracingSampleRate)) {\n    display.error('Tracing Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.allowedTracingOrigins !== undefined) {\n    if (!Array.isArray(initConfiguration.allowedTracingOrigins)) {\n      display.error('Allowed Tracing Origins should be an array')\n      return\n    }\n    if (initConfiguration.allowedTracingOrigins.length !== 0 && initConfiguration.service === undefined) {\n      display.error('Service need to be configured when tracing is enabled')\n      return\n    }\n  }\n\n  if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {\n    display.error('Excluded Activity Urls should be an array')\n    return\n  }\n\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n  if (!baseConfiguration) {\n    return\n  }\n\n  const trackFrustrations = !!initConfiguration.trackFrustrations\n\n  return assign(\n    {\n      applicationId: initConfiguration.applicationId,\n      version: initConfiguration.version,\n      actionNameAttribute: initConfiguration.actionNameAttribute,\n      sessionReplaySampleRate: initConfiguration.sessionReplaySampleRate ?? premiumSampleRate ?? 100,\n      oldPlansBehavior: initConfiguration.sessionReplaySampleRate === undefined,\n      allowedTracingOrigins: initConfiguration.allowedTracingOrigins ?? [],\n      tracingSampleRate: initConfiguration.tracingSampleRate,\n      excludedActivityUrls: initConfiguration.excludedActivityUrls ?? [],\n      trackInteractions: !!initConfiguration.trackInteractions || trackFrustrations,\n      trackFrustrations,\n      trackViewsManually: !!initConfiguration.trackViewsManually,\n      trackResources: initConfiguration.trackResources,\n      trackLongTasks: initConfiguration.trackLongTasks,\n      defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)\n        ? initConfiguration.defaultPrivacyLevel\n        : DefaultPrivacyLevel.MASK_USER_INPUT,\n    },\n    baseConfiguration\n  )\n}\n\nexport function serializeRumConfiguration(configuration: RumInitConfiguration): RawTelemetryConfiguration {\n  const baseSerializedConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      premium_sample_rate: configuration.premiumSampleRate,\n      replay_sample_rate: configuration.replaySampleRate,\n      session_replay_sample_rate: configuration.sessionReplaySampleRate,\n      trace_sample_rate: configuration.tracingSampleRate,\n      action_name_attribute: configuration.actionNameAttribute,\n      use_allowed_tracing_origins:\n        Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0,\n      default_privacy_level: configuration.defaultPrivacyLevel,\n      use_excluded_activity_urls:\n        Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0,\n      track_frustrations: configuration.trackFrustrations,\n      track_views_manually: configuration.trackViewsManually,\n      track_interactions: configuration.trackInteractions,\n    },\n    baseSerializedConfiguration\n  )\n}\n","import type { Observable, TelemetryEvent, RawError } from '@datadog/browser-core'\nimport {\n  TelemetryService,\n  addTelemetryConfiguration,\n  startTelemetry,\n  canUseEventBridge,\n  getEventBridge,\n} from '@datadog/browser-core'\nimport { createDOMMutationObservable } from '../browser/domMutationObservable'\nimport { startPerformanceCollection } from '../browser/performanceCollection'\nimport { startRumAssembly } from '../domain/assembly'\nimport { startForegroundContexts } from '../domain/contexts/foregroundContexts'\nimport { startInternalContext } from '../domain/contexts/internalContext'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startViewContexts } from '../domain/contexts/viewContexts'\nimport { startRequestCollection } from '../domain/requestCollection'\nimport { startActionCollection } from '../domain/rumEventsCollection/action/actionCollection'\nimport { startErrorCollection } from '../domain/rumEventsCollection/error/errorCollection'\nimport { startLongTaskCollection } from '../domain/rumEventsCollection/longTask/longTaskCollection'\nimport { startResourceCollection } from '../domain/rumEventsCollection/resource/resourceCollection'\nimport { startViewCollection } from '../domain/rumEventsCollection/view/viewCollection'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport { startRumSessionManager, startRumSessionManagerStub } from '../domain/rumSessionManager'\nimport type { CommonContext } from '../rawRumEvent.types'\nimport { startRumBatch } from '../transport/startRumBatch'\nimport { startRumEventBridge } from '../transport/startRumEventBridge'\nimport { startUrlContexts } from '../domain/contexts/urlContexts'\nimport type { LocationChange } from '../browser/locationChangeObservable'\nimport { createLocationChangeObservable } from '../browser/locationChangeObservable'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport { serializeRumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/rumEventsCollection/view/trackViews'\nimport type { RecorderApi } from './rumPublicApi'\n\nexport function startRum(\n  initConfiguration: RumInitConfiguration,\n  configuration: RumConfiguration,\n  getCommonContext: () => CommonContext,\n  recorderApi: RecorderApi,\n  initialViewOptions?: ViewOptions\n) {\n  const lifeCycle = new LifeCycle()\n\n  const telemetry = startRumTelemetry(configuration)\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: configuration.applicationId,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: viewContexts.findView()?.id,\n    },\n    action: {\n      id: actionContexts.findActionId(),\n    },\n  }))\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n  }\n  if (!canUseEventBridge()) {\n    startRumBatch(configuration, lifeCycle, telemetry.observable, reportError)\n  } else {\n    startRumEventBridge(lifeCycle)\n  }\n\n  const session = !canUseEventBridge() ? startRumSessionManager(configuration, lifeCycle) : startRumSessionManagerStub()\n  const domMutationObservable = createDOMMutationObservable()\n  const locationChangeObservable = createLocationChangeObservable(location)\n\n  const { viewContexts, foregroundContexts, urlContexts, actionContexts, addAction } = startRumEventCollection(\n    lifeCycle,\n    configuration,\n    location,\n    session,\n    locationChangeObservable,\n    domMutationObservable,\n    getCommonContext,\n    reportError\n  )\n  addTelemetryConfiguration(serializeRumConfiguration(initConfiguration))\n\n  startLongTaskCollection(lifeCycle, session)\n  startResourceCollection(lifeCycle, configuration, session)\n  const { addTiming, startView } = startViewCollection(\n    lifeCycle,\n    configuration,\n    location,\n    domMutationObservable,\n    locationChangeObservable,\n    foregroundContexts,\n    recorderApi,\n    initialViewOptions\n  )\n  const { addError } = startErrorCollection(lifeCycle, foregroundContexts)\n\n  startRequestCollection(lifeCycle, configuration, session)\n  startPerformanceCollection(lifeCycle, configuration)\n\n  const internalContext = startInternalContext(\n    configuration.applicationId,\n    session,\n    viewContexts,\n    actionContexts,\n    urlContexts\n  )\n\n  return {\n    addAction,\n    addError,\n    addTiming,\n    startView,\n    lifeCycle,\n    viewContexts,\n    session,\n    getInternalContext: internalContext.get,\n  }\n}\n\nfunction startRumTelemetry(configuration: RumConfiguration) {\n  const telemetry = startTelemetry(TelemetryService.RUM, configuration)\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n  }\n  return telemetry\n}\n\nexport function startRumEventCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  sessionManager: RumSessionManager,\n  locationChangeObservable: Observable<LocationChange>,\n  domMutationObservable: Observable<void>,\n  getCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  const viewContexts = startViewContexts(lifeCycle)\n  const urlContexts = startUrlContexts(lifeCycle, locationChangeObservable, location)\n  const foregroundContexts = startForegroundContexts()\n  const { addAction, actionContexts } = startActionCollection(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    foregroundContexts\n  )\n\n  startRumAssembly(\n    configuration,\n    lifeCycle,\n    sessionManager,\n    viewContexts,\n    urlContexts,\n    actionContexts,\n    getCommonContext,\n    reportError\n  )\n\n  return {\n    viewContexts,\n    foregroundContexts,\n    urlContexts,\n    addAction,\n    actionContexts,\n    stop: () => {\n      viewContexts.stop()\n      foregroundContexts.stop()\n    },\n  }\n}\n","import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumEventBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'rum', RumEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    bridge.send('rum', serverRumEvent)\n  })\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, ContextHistory } from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { ViewCreatedEvent } from '../rumEventsCollection/view/trackViews'\n\nexport const VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface ViewContext {\n  service?: string\n  version?: string\n  id: string\n  name?: string\n}\n\nexport interface ViewContexts {\n  findView: (startTime?: RelativeTime) => ViewContext | undefined\n  stop: () => void\n}\n\nexport function startViewContexts(lifeCycle: LifeCycle): ViewContexts {\n  const viewContextHistory = new ContextHistory<ViewContext>(VIEW_CONTEXT_TIME_OUT_DELAY)\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n    viewContextHistory.add(buildViewContext(view), view.startClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    viewContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    viewContextHistory.reset()\n  })\n\n  function buildViewContext(view: ViewCreatedEvent) {\n    return {\n      service: view.service,\n      version: view.version,\n      id: view.id,\n      name: view.name,\n    }\n  }\n\n  return {\n    findView: (startTime) => viewContextHistory.find(startTime),\n    stop: () => {\n      viewContextHistory.stop()\n    },\n  }\n}\n","import type { RelativeTime, Observable } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, relativeNow, ContextHistory } from '@datadog/browser-core'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\n/**\n * We want to attach to an event:\n * - the url corresponding to its start\n * - the referrer corresponding to the previous view url (or document referrer for initial view)\n */\n\nexport const URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface UrlContext {\n  url: string\n  referrer: string\n}\n\nexport interface UrlContexts {\n  findUrl: (startTime?: RelativeTime) => UrlContext | undefined\n  stop: () => void\n}\n\nexport function startUrlContexts(\n  lifeCycle: LifeCycle,\n  locationChangeObservable: Observable<LocationChange>,\n  location: Location\n) {\n  const urlContextHistory = new ContextHistory<UrlContext>(URL_CONTEXT_TIME_OUT_DELAY)\n\n  let previousViewUrl: string | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    urlContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, ({ startClocks }) => {\n    const viewUrl = location.href\n    urlContextHistory.add(\n      buildUrlContext({\n        url: viewUrl,\n        referrer: !previousViewUrl ? document.referrer : previousViewUrl,\n      }),\n      startClocks.relative\n    )\n    previousViewUrl = viewUrl\n  })\n\n  const locationChangeSubscription = locationChangeObservable.subscribe(({ newLocation }) => {\n    const current = urlContextHistory.find()\n    if (current) {\n      const changeTime = relativeNow()\n      urlContextHistory.closeActive(changeTime)\n      urlContextHistory.add(\n        buildUrlContext({\n          url: newLocation.href,\n          referrer: current.referrer,\n        }),\n        changeTime\n      )\n    }\n  })\n\n  function buildUrlContext({ url, referrer }: { url: string; referrer: string }) {\n    return {\n      url,\n      referrer,\n    }\n  }\n\n  return {\n    findUrl: (startTime?: RelativeTime) => urlContextHistory.find(startTime),\n    stop: () => {\n      locationChangeSubscription.unsubscribe()\n      urlContextHistory.stop()\n    },\n  }\n}\n","import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core'\nimport type { RawRumLongTaskEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumSessionManager } from '../../rumSessionManager'\n\nexport function startLongTaskCollection(lifeCycle: LifeCycle, sessionManager: RumSessionManager) {\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType !== 'longtask') {\n        break\n      }\n      const session = sessionManager.findTrackedSession(entry.startTime)\n      if (!session || !session.longTaskAllowed) {\n        break\n      }\n      const startClocks = relativeToClocks(entry.startTime)\n      const rawRumEvent: RawRumLongTaskEvent = {\n        date: startClocks.timeStamp,\n        long_task: {\n          id: generateUUID(),\n          duration: toServerDuration(entry.duration),\n        },\n        type: RumEventType.LONG_TASK,\n        _dd: {\n          discarded: false,\n        },\n      }\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n        rawRumEvent,\n        startTime: startClocks.relative,\n        domainContext: { performanceEntry: entry.toJSON() },\n      })\n    }\n  })\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport type { ActionContexts } from '../rumEventsCollection/action/actionCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { ViewContexts } from './viewContexts'\nimport type { UrlContexts } from './urlContexts'\n\nexport interface InternalContext {\n  application_id: string\n  session_id: string | undefined\n  view?: {\n    id: string\n    url: string\n    referrer: string\n    name?: string\n  }\n  user_action?: {\n    id: string | string[]\n  }\n}\n\n/**\n * Internal context keep returning v1 format\n * to not break compatibility with logs data format\n */\nexport function startInternalContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  actionContexts: ActionContexts,\n  urlContexts: UrlContexts\n) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const viewContext = viewContexts.findView(startTime as RelativeTime)\n      const urlContext = urlContexts.findUrl(startTime as RelativeTime)\n      const session = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (session && viewContext && urlContext) {\n        const actionId = actionContexts.findActionId(startTime as RelativeTime)\n        return {\n          application_id: applicationId,\n          session_id: session.id,\n          user_action: actionId ? { id: actionId } : undefined,\n          view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url },\n        }\n      }\n    },\n  }\n}\n"],"sourceRoot":""}