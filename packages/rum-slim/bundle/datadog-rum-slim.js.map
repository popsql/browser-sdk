{"version":3,"sources":["webpack:///../core/src/tools/display.ts","webpack:///../core/src/tools/monitor.ts","webpack:///../core/src/tools/utils.ts","webpack:///../core/src/tools/catchUserErrors.ts","webpack:///../core/src/tools/contextManager.ts","webpack:///../core/src/tools/boundedBuffer.ts","webpack:///../core/src/tools/timeUtils.ts","webpack:///../core/src/browser/cookie.ts","webpack:///../core/src/domain/synthetics/syntheticsWorkerValues.ts","webpack:///../core/src/transport/eventBridge.ts","webpack:///../core/src/domain/tracekit/computeStackTrace.ts","webpack:///../core/src/tools/error.ts","webpack:///../core/src/domain/configuration/experimentalFeatures.ts","webpack:///../core/src/tools/urlPolyfill.ts","webpack:///../core/src/domain/configuration/intakeSites.ts","webpack:///../core/src/domain/configuration/endpointBuilder.ts","webpack:///../core/src/domain/configuration/tags.ts","webpack:///../core/src/domain/configuration/transportConfiguration.ts","webpack:///../core/src/domain/configuration/configuration.ts","webpack:///../core/src/tools/observable.ts","webpack:///../core/src/domain/telemetry/rawTelemetryEvent.types.ts","webpack:///../core/src/domain/telemetry/telemetry.ts","webpack:///../rum-core/src/browser/domMutationObservable.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/resourceUtils.ts","webpack:///../rum-core/src/domain/tracing/getDocumentTraceId.ts","webpack:///../rum-core/src/browser/viewportObservable.ts","webpack:///../rum-core/src/domain/contexts/displayContext.ts","webpack:///../rum-core/src/browser/performanceCollection.ts","webpack:///../core/src/tools/createEventRateLimiter.ts","webpack:///../core/src/tools/limitModification.ts","webpack:///../rum-core/src/domain/contexts/syntheticsContext.ts","webpack:///../rum-core/src/domain/assembly.ts","webpack:///../rum-core/src/domain/contexts/ciTestContext.ts","webpack:///../rum-core/src/domain/contexts/foregroundContexts.ts","webpack:///../rum-core/src/domain/lifeCycle.ts","webpack:///../core/src/browser/xhrObservable.ts","webpack:///../core/src/domain/session/sessionConstants.ts","webpack:///../core/src/tools/contextHistory.ts","webpack:///../core/src/tools/instrumentMethod.ts","webpack:///../core/src/browser/fetchObservable.ts","webpack:///../rum-core/src/domain/tracing/tracer.ts","webpack:///../rum-core/src/domain/requestCollection.ts","webpack:///../rum-core/src/domain/trackEventCounts.ts","webpack:///../rum-core/src/domain/waitPageActivityEnd.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/clickChain.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/getActionNameFromElement.ts","webpack:///../core/src/tools/browserDetection.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/getSelectorsFromElement.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/listenActionEvents.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/computeFrustration.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/trackClickActions.ts","webpack:///../rum-core/src/domain/rumEventsCollection/action/actionCollection.ts","webpack:///../core/src/domain/tracekit/tracekit.ts","webpack:///../core/src/domain/console/consoleObservable.ts","webpack:///../core/src/domain/report/reportObservable.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackFirstHidden.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/errorCollection.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/trackConsoleError.ts","webpack:///../core/src/domain/error/trackRuntimeError.ts","webpack:///../rum-core/src/domain/rumEventsCollection/error/trackReportError.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/matchRequestTiming.ts","webpack:///../rum-core/src/domain/rumEventsCollection/resource/resourceCollection.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackInitialViewTimings.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackViewMetrics.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/trackViews.ts","webpack:///../rum-core/src/domain/rumEventsCollection/view/viewCollection.ts","webpack:///../core/src/domain/session/sessionCookieStore.ts","webpack:///../core/src/domain/session/sessionStore.ts","webpack:///../core/src/domain/session/sessionManager.ts","webpack:///../core/src/domain/session/oldCookiesMigration.ts","webpack:///../rum-core/src/domain/rumSessionManager.ts","webpack:///../core/src/transport/batch.ts","webpack:///../core/src/transport/sendWithRetryStrategy.ts","webpack:///../core/src/transport/httpRequest.ts","webpack:///../rum-core/src/transport/startRumBatch.ts","webpack:///../rum-core/src/browser/locationChangeObservable.ts","webpack:///./src/entries/main.ts","webpack:///../core/src/boot/init.ts","webpack:///../rum-core/src/boot/rumPublicApi.ts","webpack:///../rum-core/src/domain/configuration.ts","webpack:///../rum-core/src/boot/startRum.ts","webpack:///../rum-core/src/transport/startRumEventBridge.ts","webpack:///../rum-core/src/domain/contexts/viewContexts.ts","webpack:///../rum-core/src/domain/contexts/urlContexts.ts","webpack:///../rum-core/src/domain/rumEventsCollection/longTask/longTaskCollection.ts","webpack:///../rum-core/src/domain/contexts/internalContext.ts"],"names":["ConsoleApiName","log","debug","info","warn","error","display","api","Object","prototype","hasOwnProperty","call","args","console","bind","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","fn","callMonitored","this","arguments","context","apply","e","displayIfDebugEnabled","ONE_SECOND","ONE_MINUTE","throttle","wait","options","pendingExecutionWithParameters","pendingTimeoutId","needLeadingExecution","undefined","leading","needTrailingExecution","trailing","inWaitPeriod","throttled","parameters","setTimeout","cancel","clearTimeout","target","toAssign","forEach","source","key","shallowClone","object","generateUUID","placeholder","parseInt","Math","random","toString","replace","performDraw","threshold","round","num","decimals","toFixed","jsonStringify","value","space","JSON","stringify","circularReferenceChecker","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","Array","restoreValuePrototypeToJson","getPrototypeOf","restoreValueToJson","createCircularReferenceChecker","_key","type","getType","hasAlreadyBeenSeen","objectToJson","toJSON","includes","candidate","search","indexOf","arrayFrom","arrayLike","from","array","Set","item","push","i","length","find","predicate","isPercentage","isNumber","objectValues","keys","map","objectEntries","isEmptyObject","startsWith","slice","getGlobalObject","globalThis","defineProperty","get","configurable","globalObject","_dd_temp_","self","window","getLinkElementOrigin","element","origin","sanitizedHost","host","protocol","findCommaSeparatedValue","rawString","name","matches","RegExp","exec","safeTruncate","suffix","lastChar","charCodeAt","correctedLength","addEventListener","emitter","event","listener","addEventListeners","events","once","capture","passive","wrappedListener","stop","removeEventListener","runOnReadyState","expectedReadyState","callback","document","readyState","isArray","WeakMap","has","set","mergeInto","destination","Date","getTime","flags","global","ignoreCase","multiline","sticky","unicode","join","merged","deepClone","combine","sources","matchList","list","some","test","cssEscape","str","CSS","escape","ch","asCodePoint","catchUserErrors","errorMsg","err","createContextManager","add","remove","newContext","getContext","setContext","setContextProperty","property","removeContextProperty","clearContext","navigationStart","buffer","splice","drain","relativeToClocks","relative","timeStamp","getCorrectedTimeStamp","relativeTime","correctedOrigin","dateNow","performance","now","getNavigationStart","addDuration","getTimeStamp","toServerDuration","duration","timeStampNow","relativeNow","clocksNow","clocksOrigin","elapsed","start","end","a","b","getRelativeTime","timestamp","timing","getCookieOverride","setCookieOverride","getCurrentSiteCache","setCookieHandling","getCookie","setCookie","expireDelay","date","setTime","expires","toUTCString","sameSite","crossSite","domain","secure","cookie","deleteCookie","willSyntheticsInjectRum","Boolean","_DATADOG_SYNTHETICS_INJECTS_RUM","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getAllowedWebViewHosts","parse","send","eventType","canUseEventBridge","currentHost","location","hostname","bridge","allowedHost","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","String","split","line","stackFrame","parts","CHROME_LINE_RE","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","url","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","enabledExperimentalFeatures","isURLSupported","ErrorSource","computeRawError","stackTrace","originalError","handlingStack","startClocks","nonErrorPrefix","handling","Error","toStackTraceString","causes","flattenErrorCauses","result","formatErrorMessage","frame","createHandlingStack","formattedStack","parentSource","currentError","cause","isExperimentalFeatureEnabled","featureName","getExperimentalFeatures","normalizeUrl","buildUrl","href","getOrigin","base","URL","checkURLSupported","doc","anchorElement","createElement","baseElement","implementation","createHTMLDocument","head","appendChild","body","INTAKE_SITE_US1","ENDPOINTS","logs","rum","sessionReplay","INTAKE_TRACKS","createEndpointBuilder","initConfiguration","endpointType","tags","site","clientToken","domainParts","extension","pop","baseUrl","proxyUrl","build","encodeURIComponent","concat","endpointUrl","buildIntakeUrl","FORBIDDEN_CHARACTERS","buildTag","rawValue","valueSizeLimit","sanitizedValue","computeTransportConfiguration","configuration","env","service","version","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","intakeEndpoints","builder","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","isIntakeUrl","intakeEndpoint","DefaultPrivacyLevel","ALLOW","MASK","MASK_USER_INPUT","validateAndBuildConfiguration","sampleRate","telemetrySampleRate","telemetryConfigurationSampleRate","enabledFeatures","enableExperimentalFeatures","filter","flag","beforeSend","cookieOptions","buildCookieOptions","silentMultipleInit","batchBytesLimit","eventRateLimiterThreshold","maxTelemetryEventsPerPage","flushTimeout","batchMessagesLimit","messageBytesLimit","useSecureSessionCookie","useCrossSiteSessionCookie","mustUseSecureCookie","trackSessionAcrossSubdomains","testCookieName","domainLevels","candidateDomain","getCurrentSite","onFirstSubscribe","observers","subscribe","f","onLastUnsubscribe","unsubscribe","other","notify","data","observer","mergeObservables","globalObservable","Observable","subscriptions","observables","observable","subscription","onRawTelemetryEventCollected","TelemetryType","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","telemetryConfiguration","maxEventsPerPage","sentEventCount","telemetryEnabled","telemetryConfigurationEnabled","startTelemetry","telemetryService","contextProvider","_dd","format_version","telemetry","experimental_features","toTelemetryEvent","addTelemetryError","setContextProvider","provider","addTelemetry","status","kind","scrubCustomerFrames","formatError","allowedFrameUrl","createDOMMutationObservable","MutationObserver","constructor","browserWindow","Zone","zoneSymbol","__symbol__","originalInstance","getMutationObserverConstructor","observe","attributes","characterData","childList","subtree","disconnect","FAKE_INITIAL_DOCUMENT","RESOURCE_TYPES","initiatorType","_","path","computeResourceKind","isValidUrl","pathname","getPathName","isType","areInOrder","numbers","computePerformanceResourceDetails","entry","validEntry","toValidEntry","startTime","fetchStart","redirectStart","redirectEnd","domainLookupStart","domainLookupEnd","connectStart","secureConnectionStart","connectEnd","requestStart","responseStart","details","download","formatTiming","first_byte","connect","ssl","dns","hasRedirection","redirect","responseEnd","computeSize","decodedBodySize","isAllowedRequestUrl","viewportObservable","viewport","getDocumentTraceId","traceIdMeta","querySelector","traceTimeMeta","createDocumentTraceData","content","getDocumentTraceDataFromMeta","comment","childNodes","getTraceCommentFromNode","node","isTextNode","findTraceComment","getDocumentTraceDataFromComment","traceTime","traceId","rawTraceTime","Number","nodeName","isCommentNode","match","supportPerformanceObject","supportPerformanceTimingEvent","entryType","PerformanceObserver","supportedEntryTypes","startPerformanceCollection","lifeCycle","handleRumPerformanceEntries","forcedAttributes","getEntriesByType","relativePerformanceTiming","computeRelativePerformanceTiming","getEntries","entries","mainEntries","experimentalEntries","buffered","entryTypes","clearResourceTimings","sendFakeTiming","retrieveNavigationTiming","startTimeStamp","timingSent","removeEventListeners","evt","cancelable","processingStart","sendTimingIfPointerIsNotCancelled","sendTiming","delay","retrieveFirstInputTiming","numberKey","timingElement","rumAllowedPerformanceEntries","loadEventEnd","isIncompleteNavigation","isForbiddenResource","createEventRateLimiter","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","current","field","isValidObjectContaining","fields","getSyntheticsContext","testId","_DATADOG_SYNTHETICS_PUBLIC_ID","resultId","_DATADOG_SYNTHETICS_RESULT_ID","getSyntheticsResultId","test_id","result_id","injected","initViewportObservable","updateDimension","getViewportDimension","visual","visualViewport","width","scale","height","innerWidth","innerHeight","getDisplayContext","viewportDimension","VIEW_EVENTS_MODIFIABLE_FIELD_PATHS","OTHER_EVENTS_MODIFIABLE_FIELD_PATHS","startRumAssembly","sessionManager","viewContexts","urlContexts","actionContexts","getCommonContext","reportError","eventRateLimiters","syntheticsContext","ciTestContext","testExecutionId","Cypress","test_execution_id","getCiTestContext","rawRumEvent","domainContext","savedCommonContext","customerContext","viewContext","findView","urlContext","findUrl","session","findTrackedSession","commonContext","actionId","findActionId","serverRumEvent","drift","plan","browser_sdk_version","application","id","view","referrer","action","synthetics","ci_test","has_replay","hasReplay","user","usr","modifiableFieldPaths","modifier","clone","originalValue","newValue","originalType","newType","limitModification","shouldSend","foregroundPeriods","startForegroundContexts","hasFocus","addNewForegroundPeriod","onFocusChange","onBlurChange","stopForegroundTracking","isTrusted","stopBlurTracking","closeForegroundPeriod","isInForegroundAt","selectInForegroundPeriodsFor","currentForegroundPeriod","foregroundPeriod","eventStartTime","eventEndTime","filteredForegroundPeriods","earliestIndex","max","startDuration","endDuration","unshift","xhrObservable","callbacks","eventCallbacks","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","END_OF_TIMES","Infinity","clearOldContextsInterval","setInterval","clearOldContexts","endTime","index","close","closeActive","latestEntry","findAll","reset","clearInterval","oldTimeThreshold","instrumentMethod","method","instrumentationFactory","original","instrumentation","instrumentationWrapper","instrumentMethodAndCallOriginal","before","after","fetchObservable","xhrContexts","initXhrObservable","stopInstrumentingStart","XMLHttpRequest","openXhr","stopInstrumentingSend","sendXhr","stopInstrumentingAbort","abortXhr","state","startContext","isAborted","xhr","hasBeenReported","stopInstrumentingOnReadyStateChange","DONE","onEnd","completeContext","initFetchObservable","fetch","originalFetch","input","init","responsePromise","afterSend","reportFetch","response","DOMException","code","ABORT_ERR","responseType","then","clearTracingIfNeeded","spanId","traceSampled","injectHeadersIfTracingAllowed","inject","getCrypto","requestUrl","allowedTracingOrigins","isAllowedUrl","TraceIdentifier","tracingSampleRate","toDecimalString","crypto","msCrypto","Uint8Array","getRandomValues","radix","high","readInt32","low","mod","floor","offset","nextRequestIndex","startRequestCollection","tracer","traceFetch","tracingHeaders","Request","headers","append","Headers","header","traceXhr","setRequestHeader","startTracer","rawContext","requestIndex","getNextRequestIndex","trackXhr","trackFetch","trackEventCounts","eventCounts","errorCount","longTaskCount","resourceCount","actionCount","frustrationCount","frustration","waitPageActivityEnd","domMutationObservable","pageActivityEndCallback","maxDuration","pageActivityObservable","firstRequestIndex","pendingRequestsCount","notifyPageActivity","isExcludedUrl","startEvent","request","stopTrackingWindowOpen","s","isBusy","createPageActivityObservable","pageActivityEndTimeoutId","hasCompleted","validationTimeoutId","complete","hadActivity","maxDurationTimeoutId","pageActivitySubscription","lastChangeTime","doWaitPageActivityEnd","excludedActivityUrls","MAX_DURATION_BETWEEN_CLICKS","createClickChain","firstClick","onFinalize","maxDurationBetweenClicksTimeout","bufferedClicks","appendClick","click","stopObservable","tryFinalize","dontAcceptMoreClick","every","isStopped","tryAppend","first","second","sqrt","pow","clientX","clientY","DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE","getActionNameFromElement","userProgrammaticAttribute","getActionNameFromElementProgrammatically","getActionNameFromElementForStrategies","priorityStrategies","fallbackStrategies","targetElement","programmaticAttribute","elementWithAttribute","supportsElementClosestResult","HTMLElement","supportsElementClosest","closest","hasAttribute","parentElement","truncate","normalizeWhitespace","getAttribute","trim","supportsLabelPropertyResult","HTMLInputElement","supportsLabelProperty","labels","getTextualContent","label","ownerDocument","querySelectorAll","htmlFor","labelledByAttribute","refElement","getElementById","strategies","recursionCounter","strategy","trimmedName","isContentEditable","innerText","removeTextFromElements","query","textToReplace","documentMode","textContent","stableAttributeSelectorsCache","supportScopeSelectorCache","STABLE_ATTRIBUTES","getSelectorsFromElement","actionNameAttribute","attributeSelectors","attribute","getAttributeSelector","getStableAttributeSelectors","globallyUniqueSelectorStrategies","getIDSelector","uniqueAmongChildrenSelectorStrategies","getClassSelector","getTagNameSelector","selector","getSelectorFromElement","selector_combined","useCombinedSelectors","selector_stopping_when_unique","selector_all_together","isGeneratedValue","targetElementSelector","globallyUniqueSelector","findSelector","isSelectorUniqueGlobally","combineSelector","isSelectorUniqueAmongSiblings","getPositionSelector","tagName","classList","className","attributeName","elementIndex","sibling","firstElementChild","currentIndex","nextElementSibling","selectorGetters","childSelector","elementSelector","selectorGetter","fullSelector","supportScopeSelector","parent","child","isSelectionEmpty","selection","getSelection","isCollapsed","isMouseEventOnElement","Element","computeFrustration","clicks","rageClick","getUserActivity","isRage","addFrustration","isDead","hasError","hasSelectionChanged","hasPageActivity","msMatchesSelector","trackClickActions","currentClickChain","history","ContextHistory","stopClickChain","selectionEmptyAtPointerDown","clickContext","onPointerDown","onClick","hasInputChanged","listeners","stopActionEventsListener","pointerDownEvent","trackFrustrations","clickActionBase","position","rect","getBoundingClientRect","x","left","y","top","computeClickActionBase","processPointerDown","clickEvent","appendClickToClickChain","newClick","stopWaitPageActivityEnd","pageActivityEndEvent","discard","validate","viewEndedSubscription","endClocks","stopSubscription","processClick","finalizeClicks","activityEndTime","historyEntry","eventCountsSubscription","frustrationTypes","newActivityEndTime","frustrationType","domEvents","clickAction","counts","processAction","foregroundContexts","autoActionProperties","isAutoAction","loading_time","count","long_task","resource","actionEvent","inForeground","in_foreground","ERROR_TYPES_RE","startUnhandledErrorCollection","stopInstrumentingOnError","lineNo","columnNo","errorObj","msg","groups","instrumentOnError","stopInstrumentingOnUnhandledRejection","reason","instrumentUnhandledRejection","consoleObservablesByApi","initConsoleObservable","apis","consoleObservables","originalConsoleApi","params","buildConsoleLog","createConsoleObservable","param","formatConsoleParameters","firstErrorParam","trackFirstHiddenSingleton","RawReportType","initReportObservable","handleCspViolation","blockedURI","effectiveDirective","subtype","buildStack","originalPolicy","sourceFile","lineNumber","columnNumber","buildRawReportFromCspViolation","reportTypes","ReportingObserver","handleReports","reports","report","types","createReportObservable","startErrorCollection","errorObservable","consoleError","trackConsoleError","trackRuntimeError","trackReportError","handling_stack","source_type","processError","addError","rawError","doStartErrorCollection","matchRequestTiming","sameNameEntries","getEntriesByName","correspondingEntries","candidates","errorMargin","startResourceCollection","matchingTiming","correspondingTimingOverrides","computePerformanceEntryMetrics","tracingInfo","span_id","trace_id","rule_psr","getRulePsr","computeRequestTracingInfo","indexingInfo","computeIndexingInfo","resourceEvent","status_code","performanceEntry","requestInput","requestInit","processRequest","processResourceEntry","entryMetrics","computeEntryTracingInfo","size","resourceStart","discarded","resourceAllowed","trackFirstHidden","visibilityState","TIMING_MAXIMUM_DELAY","trackInitialViewTimings","timings","setTimings","newTimings","stopNavigationTracking","domComplete","domContentLoaded","domContentLoadedEventEnd","domInteractive","loadEvent","firstByte","trackNavigationTimings","stopFCPTracking","firstHidden","fcpEntry","trackFirstContentfulPaintTiming","firstContentfulPaint","stopLCPTracking","firstInteractionTimestamp","stopEventListener","unsubscribeLifeCycle","lcpEntry","findLast","trackLargestContentfulPaintTiming","largestContentfulPaint","stopFIDTracking","firstInputEntry","firstInputDelay","firstInputTime","trackFirstInputTimings","trackViewMetrics","scheduleViewUpdate","loadingType","viewStart","stopCLSTracking","viewMetrics","stopEventCountsTracking","newEventCounts","loadType","isWaitingForLoadEvent","isWaitingForActivityLoadingTime","loadingTimeCandidates","invokeCallbackIfAllCandidatesAreReceived","setLoadEvent","trackLoadingTime","newLoadingTime","loadingTime","stopLoadingTimeTracking","cumulativeLayoutShift","maxClsValue","update","slidingSessionWindow","hadRecentInput","trackCumulativeLayoutShift","trackViews","locationChangeObservable","areViewsTrackedAutomatically","initialViewOptions","locationChangeSubscription","initialView","newView","updateTimings","scheduleUpdate","trackInitialView","stopInitialViewTracking","currentView","stopViewLifeCycle","trackViewChange","triggerUpdate","keepAliveInterval","startViewLifeCycle","viewOptions","currentLocation","otherLocation","hash","correspondingId","oldLocation","newLocation","substr","getPathFromHash","renewViewOnLocationChange","addTiming","time","startView","initialLocation","customTimings","documentVersion","triggerViewUpdate","cancelScheduleViewUpdate","stopViewMetricsTracking","currentEnd","isActive","clocks","looksLikeRelativeTime","sanitized","sanitizeTiming","startViewCollection","recorderApi","replayStats","getReplayStats","viewEvent","document_version","replay_stats","cumulative_layout_shift","dom_complete","dom_content_loaded","dom_interactive","first_contentful_paint","first_input_delay","first_input_time","is_active","largest_contentful_paint","load_event","discardNegativeDuration","loading_type","time_spent","in_foreground_periods","custom_timings","newObject","mapValues","processViewUpdate","trackViewsManually","ongoingOperations","SESSION_ENTRY_REGEXP","SESSION_ENTRY_SEPARATOR","SESSION_COOKIE_NAME","bufferedOperations","withCookieLockAccess","operations","numberOfRetries","next","currentLock","currentSession","retrieveSession","isCookieLockEnabled","lock","retryLater","setSession","processedSession","process","persistSession","isExpiredState","chrome","navigator","userAgent","currentNumberOfRetries","nextOperations","shift","clearSession","expire","toSessionString","sessionString","isValidSessionString","startSessionStore","productKey","computeSessionState","renewObservable","expireObservable","watchSessionTimeoutId","cookieSession","isActiveSession","synchronizeSession","sessionCache","retrieveActiveSession","hasSessionInCache","isSessionInCacheOutdated","created","expandOrRenewSession","isTracked","synchronizedSession","trackingType","expandOrRenewCookie","renewSession","expandSession","getSession","stopCallbacks","startSessionManager","oldSessionId","oldRumType","oldLogsType","tryOldCookiesMigration","sessionStore","sessionContextHistory","buildSessionContext","expandSessionWhenVisible","visibilityCheckInterval","trackVisibility","findActiveSession","startRumSessionManager","rawTrackingType","hasValidRumSession","sessionReplaySampleRate","isTypeTracked","sessionReplayAllowed","longTaskAllowed","trackLongTasks","oldPlansBehavior","trackResources","rumSessionType","HAS_MULTI_BYTES_CHARACTERS","beforeUnloadCallback","pushOnlyBuffer","upsertBuffer","bufferBytesCount","bufferMessagesCount","setupFlushOnExit","flushPeriodically","addOrUpdate","upsert","flush","sendFn","messages","bytesCount","flushOnExit","sendOnExit","computeBytesCount","TextEncoder","encode","Blob","processedMessage","messageBytesCount","hasMessageFor","willReachedBytesLimitWith","isFull","removedMessage","sendBeacon","MAX_QUEUE_BYTES_COUNT","sendWithRetryStrategy","payload","sendStrategy","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","dequeue","currentBackoffTime","min","shouldRetryRequest","ongoingRequestCount","queueFullReported","previousQueue","newPayloadQueue","queue","createHttpRequest","endpointBuilder","bytesLimit","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","isKeepAliveSupported","keepalive","sendXHR","fetchKeepAliveStrategy","hasReportedBeaconError","reportBeaconError","sendBeaconStrategy","onLoadEnd","open","startRumBatch","telemetryEventObservable","batch","replicaBatch","primaryBatch","createRumBatch","unloadCallback","Batch","withReplicaApplicationId","replicated","makeRumBatch","isTelemetryReplicationAllowed","createLocationChangeObservable","onHistoryChange","stopInstrumentingPushState","stopInstrumentingReplaceState","removeListener","onHashChange","stopHistoryTracking","onLocationChange","stopHashTracking","existingGlobalVariable","datadogRum","startRumImpl","ignoreInitIfSyntheticsWillInjectRum","isAlreadyInitialized","globalContextManager","userContextManager","getInternalContextStrategy","getInitConfigurationStrategy","bufferApiCalls","BoundedBuffer","addTimingStrategy","startViewStrategy","addActionStrategy","addErrorStrategy","providedError","doStartRum","startRumResults","isRecording","onRumStart","stub","publicApi","rumPublicApi","overrideInitConfigurationForBridge","testCookieValue","isCookieCorrectlySet","areCookiesAuthorized","canHandleSession","canInitRum","premiumSampleRate","replaySampleRate","baseConfiguration","trackInteractions","defaultPrivacyLevel","validateAndBuildRumConfiguration","beforeInitCalls","addRumGlobalContext","setGlobalContextProperty","removeRumGlobalContext","removeGlobalContextProperty","getRumGlobalContext","getGlobalContext","setRumGlobalContext","setGlobalContext","clearGlobalContext","getInternalContext","getInitConfiguration","addAction","setUser","newUser","sanitizeUser","getUser","setUserProperty","sanitizedProperty","removeUserProperty","removeUser","clearUser","startSessionReplayRecording","stopSessionReplayRecording","onReady","enumerable","shallowClonedUser","email","makeRumPublicApi","LifeCycle","startRumTelemetry","startRumEventBridge","startRumSessionManagerStub","viewContextHistory","buildViewContext","startViewContexts","previousViewUrl","urlContextHistory","viewUrl","buildUrlContext","changeTime","startUrlContexts","startActionCollection","startRumEventCollection","addTelemetryConfiguration","baseSerializedConfiguration","session_sample_rate","telemetry_sample_rate","telemetry_configuration_sample_rate","use_before_send","use_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","serializeConfiguration","premium_sample_rate","replay_sample_rate","session_replay_sample_rate","trace_sample_rate","action_name_attribute","use_allowed_tracing_origins","default_privacy_level","use_excluded_activity_urls","track_frustrations","track_views_manually","track_interactions","serializeRumConfiguration","startLongTaskCollection","internalContext","application_id","session_id","user_action","startInternalContext","q"],"mappings":"yBASO,IAAMA,EAAiB,CAC5BC,IAAK,MACLC,MAAO,QACPC,KAAM,OACNC,KAAM,OACNC,MAAO,SAcIC,EAAmB,SAACC,G,IAAK,wDAC/BC,OAAOC,UAAUC,eAAeC,KAAKX,EAAgBO,KACxDA,EAAMP,EAAeC,KAEvBK,EAAQC,GAAI,MAAZD,EAAgBM,EAClB,EAEAN,EAAQJ,MAAQW,QAAQX,MAAMY,KAAKD,SACnCP,EAAQL,IAAMY,QAAQZ,IAAIa,KAAKD,SAC/BP,EAAQH,KAAOU,QAAQV,KAAKW,KAAKD,SACjCP,EAAQF,KAAOS,QAAQT,KAAKU,KAAKD,SACjCP,EAAQD,MAAQQ,QAAQR,MAAMS,KAAKD,S,ICrC/BE,E,kMACAC,GAAY,EAMT,SAASC,EAAaC,GAC3BF,EAAYE,CACd,CAmBO,SAAS,EAA2CC,GACzD,OAAO,WAEL,OAAOC,EAAcD,EAAIE,KAAMC,UACjC,CACF,CAQO,SAASF,EACdD,EACAI,EACAX,GAEA,IAEE,OAAOO,EAAGK,MAAMD,EAASX,E,CACzB,MAAOa,GAEP,GADAC,EAAsB1B,EAAeK,MAAOoB,GACxCV,EACF,IACEA,EAAwBU,E,CACxB,MAAOA,GACPC,EAAsB1B,EAAeK,MAAOoB,E,EAIpD,CAEO,SAASC,EAAsBnB,G,IAAqB,wDACrDS,GACFV,EAAA,WAAQ,EAAD,GAACC,EAAK,aAAgBK,GAAI,GAErC,CChEO,IAAMe,EAAa,IACbC,EAAa,IA2DnB,SAASC,EACdV,EACAW,EACAC,GAEA,IAGIC,EACAC,EAJEC,GAAuBH,QAA+BI,IAApBJ,EAAQK,SAAwBL,EAAQK,QAC1EC,GAAwBN,QAAgCI,IAArBJ,EAAQO,UAAyBP,EAAQO,SAC9EC,GAAe,EAInB,MAAO,CACLC,UAAW,W,IAAC,sDACND,EACFP,EAAiCS,GAG/BP,EACFf,EAAE,aAAIsB,GAENT,EAAiCS,EAEnCF,GAAe,EACfN,EAAmBS,YAAW,WACxBL,GAAyBL,GAC3Bb,EAAE,aAAIa,GAERO,GAAe,EACfP,OAAiCG,CACnC,GAAGL,GACL,EACAa,OAAQ,WACNC,aAAaX,GACbM,GAAe,EACfP,OAAiCG,CACnC,EAEJ,CASO,SAAS,EAAOU,G,IAAoB,wDAQzC,OAPAC,EAASC,SAAQ,SAACC,GAChB,IAAK,IAAMC,KAAOD,EACZxC,OAAOC,UAAUC,eAAeC,KAAKqC,EAAQC,KAC/CJ,EAAOI,GAAOD,EAAOC,GAG3B,IACOJ,CACT,CAEO,SAASK,EAAgBC,GAC9B,OAAO,EAAO,CAAC,EAAGA,EACpB,CAMO,SAASC,EAAaC,GAC3B,OAAOA,GAEFC,SAASD,EAAa,IAAwB,GAAhBE,KAAKC,UAAmBF,SAASD,EAAa,IAAM,GAAKI,SAAS,IACjG,UAAG,IAAG,YAAI,IAAG,YAAI,IAAG,YAAI,IAAG,YAAI,MAAOC,QAAQ,SAAUN,EAC9D,CAMO,SAASO,EAAYC,GAC1B,OAAqB,IAAdA,GAAmC,IAAhBL,KAAKC,UAAkBI,CACnD,CAEO,SAASC,EAAMC,EAAaC,GACjC,OAAQD,EAAIE,QAAQD,EACtB,CAGO,SAAS,IAAQ,CAUjB,SAASE,EAAcC,EAAgBC,GAC5C,GAAqB,iBAAVD,GAAgC,OAAVA,EAC/B,OAAOE,KAAKC,UAAUH,GAKxB,IAqVMI,EArVAC,EAA+BC,EAAmBhE,OAAOC,WACzDgE,EAA8BD,EAAmBE,MAAMjE,WACvDkE,EAA8BH,EAAmBhE,OAAOoE,eAAeV,IACvEW,EAAqBL,EAAmBN,GAE9C,IACE,OAAOE,KAAKC,UAAUH,GA+UlBI,EAA2BQ,IAC1B,SAACC,EAAcb,GACpB,IAAMc,EAAOC,EAAQf,GACrB,MAAc,WAATc,GAA8B,UAATA,IAAqBV,EAAyBY,mBAAmBhB,GAGpFA,EAFE,4CAGX,GAtVoDC,E,CAClD,SACA,MAAO,qC,SAEPI,IACAE,IACAE,IACAE,G,CAEJ,CAKA,SAASL,EAAmBN,GAC1B,IAAMf,EAASe,EACTiB,EAAehC,EAAOiC,OAC5B,OAAID,UACKhC,EAAOiC,OACP,WACLjC,EAAOiC,OAASD,CAClB,GAEK,CACT,CAIO,SAASE,EAASC,EAA+BC,GACtD,OAAsC,IAA/BD,EAAUE,QAAQD,EAC3B,CAEO,SAASE,EAAaC,GAC3B,GAAIhB,MAAMiB,KACR,OAAOjB,MAAMiB,KAAKD,GAGpB,IAAME,EAAQ,GAEd,GAAIF,aAAqBG,IACvBH,EAAU3C,SAAQ,SAAC+C,GAAS,OAAAF,EAAMG,KAAKD,EAAX,SAE5B,IAAK,IAAIE,EAAI,EAAGA,EAAIN,EAAUO,OAAQD,IACpCJ,EAAMG,KAAKL,EAAUM,IAIzB,OAAOJ,CACT,CAOO,SAASM,EACdN,EACAO,GAEA,IAAK,IAAIH,EAAI,EAAGA,EAAIJ,EAAMK,OAAQD,GAAK,EAAG,CACxC,IAAMF,EAAOF,EAAMI,GACnB,GAAIG,EAAUL,EAAME,GAClB,OAAOF,C,CAIb,CAeO,SAASM,EAAalC,GAC3B,OAAOmC,EAASnC,IAAUA,GAAS,GAAKA,GAAS,GACnD,CAEO,SAASmC,EAASnC,GACvB,MAAwB,iBAAVA,CAChB,CAEO,SAASoC,EAA0BnD,GACxC,OAAO3C,OAAO+F,KAAKpD,GAAQqD,KAAI,SAACvD,GAAQ,OAAAE,EAAOF,EAAP,GAC1C,CAMO,SAASwD,EAActD,GAC5B,OAAO3C,OAAO+F,KAAKpD,GAAQqD,KAAI,SAACvD,GAAQ,OAACA,EAAKE,EAAOF,GAAb,GAC1C,CAEO,SAASyD,EAAcvD,GAC5B,OAAsC,IAA/B3C,OAAO+F,KAAKpD,GAAQ8C,MAC7B,CAUO,SAASU,EAAWrB,EAAmBC,GAC5C,OAAOD,EAAUsB,MAAM,EAAGrB,EAAOU,UAAYV,CAC/C,CASO,SAASsB,IACd,GAA0B,iBAAfC,WACT,OAAOA,WAETtG,OAAOuG,eAAevG,OAAOC,UAAW,YAAa,CACnDuG,IAAA,WACE,OAAO3F,IACT,EACA4F,cAAc,IAGhB,IAAIC,EAAwBC,UAc5B,cAZO3G,OAAOC,UAAU0G,UACI,iBAAjBD,IAIPA,EADkB,iBAATE,KACMA,KACY,iBAAXC,OACDA,OAEA,CAAC,GAGbH,CACT,CAUO,SAASI,EAAqBC,GACnC,GAAIA,EAAQC,OACV,OAAOD,EAAQC,OAEjB,IAAMC,EAAgBF,EAAQG,KAAKhE,QAAQ,cAAe,IAC1D,MAAO,UAAG6D,EAAQI,SAAQ,aAAKF,EACjC,CAEO,SAASG,EAAwBC,EAAmBC,GACzD,IACMC,EADQ,IAAIC,OAAO,qBAAcF,EAAI,qBACrBG,KAAKJ,GAC3B,OAAOE,EAAUA,EAAQ,QAAK5F,CAChC,CAEO,SAAS+F,EAAa5C,EAAmBW,EAAgBkC,QAAA,IAAAA,MAAA,IAC9D,IAAMC,EAAW9C,EAAU+C,WAAWpC,EAAS,GAEzCqC,EAD0BF,GAAY,OAAUA,GAAY,MAChBnC,EAAS,EAAIA,EAE/D,OAAIX,EAAUW,QAAUqC,EAAwBhD,EAEzC,UAAGA,EAAUsB,MAAM,EAAG0B,IAAgB,OAAGH,EAClD,CA+BO,SAASI,EACdC,EACAC,EACAC,EACA3G,GAEA,OAAO4G,EAAkBH,EAAS,CAACC,GAAQC,EAAU3G,EACvD,CAcO,SAAS4G,EACdH,EACAI,EACAF,EACA,G,IAAA,aAAuF,CAAC,EAAC,EAAvFG,EAAI,OAAEC,EAAO,UAAEC,EAAO,UAElBC,EAAkB,EACtBH,EACI,SAACJ,GACCQ,IACAP,EAASD,EACX,EACCC,GAGD3G,EAAUgH,EAAU,CAAED,QAAO,EAAEC,QAAO,GAAKD,EACjDF,EAAO7F,SAAQ,SAAC0F,GAAU,OAAAD,EAAQD,iBAAiBE,EAAOO,EAAiBjH,EAAjD,IAC1B,IAAMkH,EAAO,WAAM,OAAAL,EAAO7F,SAAQ,SAAC0F,GAAU,OAAAD,EAAQU,oBAAoBT,EAAOO,EAAiBjH,EAApD,GAA1B,EAEnB,MAAO,CACLkH,KAAI,EAER,CAaO,SAASE,EAAgBC,EAAgDC,GAC1EC,SAASC,aAAeH,GAA8C,aAAxBE,SAASC,WACzDF,IAGAd,EAAiBlB,OADwB,aAAvB+B,EAAoC,OAAiB,mBACnCC,EAAU,CAAER,MAAM,GAE1D,CAKO,SAAS5D,EAAQf,GACtB,OAAc,OAAVA,EACK,OAELQ,MAAM8E,QAAQtF,GACT,eAEKA,CAChB,CA2BA,SAASY,IAEP,IAAM0B,EAA6B,IAAIiD,QACvC,MAAO,CACLvE,mBAAkB,SAAChB,GACjB,IAAMwF,EAAMlD,EAAIkD,IAAIxF,GAIpB,OAHKwF,GACHlD,EAAImD,IAAIzF,GAAO,GAEVwF,CACT,EAEJ,CAqBO,SAASE,EACdC,EACA7G,EACAsB,GAGA,QAHA,IAAAA,MAA2BQ,UAGZ3C,IAAXa,EACF,OAAO6G,EAGT,GAAsB,iBAAX7G,GAAkC,OAAXA,EAEhC,OAAOA,EACF,GAAIA,aAAkB8G,KAC3B,OAAO,IAAIA,KAAK9G,EAAO+G,WAClB,GAAI/G,aAAkBgF,OAAQ,CACnC,IAAMgC,EACJhH,EAAOgH,OAEP,CACEhH,EAAOiH,OAAS,IAAM,GACtBjH,EAAOkH,WAAa,IAAM,GAC1BlH,EAAOmH,UAAY,IAAM,GACzBnH,EAAOoH,OAAS,IAAM,GACtBpH,EAAOqH,QAAU,IAAM,IACvBC,KAAK,IACT,OAAO,IAAItC,OAAOhF,EAAOA,OAAQgH,E,CAGnC,IAAI1F,EAAyBY,mBAAmBlC,GAAhD,CAGO,GAAI0B,MAAM8E,QAAQxG,GAAS,CAEhC,IADA,IAAM,EAAgB0B,MAAM8E,QAAQK,GAAeA,EAAc,GACxD7D,EAAI,EAAGA,EAAIhD,EAAOiD,SAAUD,EACnC,EAAOA,GAAK4D,EAAU,EAAO5D,GAAIhD,EAAOgD,GAAI1B,GAE9C,OAAO,C,CAGT,IAAMiG,EAAoD,WAAzBtF,EAAQ4E,GAA4BA,EAAc,CAAC,EACpF,IAAK,IAAM5G,KAAOD,EACZxC,OAAOC,UAAUC,eAAeC,KAAKqC,EAAQC,KAC/CsH,EAAOtH,GAAO2G,EAAUW,EAAOtH,GAAMD,EAAOC,GAAMqB,IAGtD,OAAOiG,C,CACT,CAQO,SAASC,EAAatG,GAC3B,OAAO0F,OAAUzH,EAAW+B,EAC9B,CAiDO,SAASuG,I,IAAQ,IAClBZ,EADkB,kDAGtB,IAAqB,UAAAa,EAAA,eAAS,CAAzB,IAAM1H,EAAM,KAEXA,UAIJ6G,EAAcD,EAAUC,EAAa7G,G,CAGvC,OAAO6G,CACT,CAyBO,SAASc,EAAUC,EAAqB1G,GAC7C,OAAO0G,EAAKC,MAAK,SAAC/E,GAChB,GAAoB,mBAATA,EACT,IACE,OAAOA,EAAK5B,E,CACZ,MAAOzC,GAEP,OADAnB,EAAQD,MAAMoB,IACP,C,CAGX,OAAIqE,aAAgBkC,OACXlC,EAAKgF,KAAK5G,GAEZ4B,IAAS5B,CAClB,GACF,CAGO,SAAS6G,EAAUC,GACxB,OAAI3D,OAAO4D,KAAO5D,OAAO4D,IAAIC,OACpB7D,OAAO4D,IAAIC,OAAOF,GAIpBA,EAAItH,QAAQ,gDAAgD,SAAUyH,EAAIC,GAC/E,OAAIA,EAES,OAAPD,EACK,IAGF,UAAGA,EAAGvE,MAAM,GAAI,GAAE,aAAKuE,EAAG9C,WAAW8C,EAAGlF,OAAS,GAAGxC,SAAS,IAAG,KAGlE,YAAK0H,EACd,GACF,CC1rBO,SAASE,EAAuClK,EAA0BmK,GAC/E,OAAO,W,IAAC,sDACN,IACE,OAAOnK,EAAE,aAAIP,E,CACb,MAAO2K,GACPjL,EAAQD,MAAMiL,EAAUC,E,CAE5B,CACF,CCNO,SAASC,IACd,IAAIjK,EAAmB,CAAC,EAExB,MAAO,CAELyF,IAAK,WAAM,OAAAzF,CAAA,EAGXkK,IAAK,SAACxI,EAAaiB,GACjB3C,EAAQ0B,GAAOiB,CACjB,EAGAwH,OAAQ,SAACzI,UACA1B,EAAQ0B,EACjB,EAGA0G,IAAK,SAACgC,GACJpK,EAAUoK,CACZ,EAEAC,WAAY,WAAM,OAAApB,EAAUjJ,EAAV,EAElBsK,WAAY,SAACF,GACXpK,EAAUiJ,EAAUmB,EACtB,EAEAG,mBAAoB,SAAC7I,EAAa8I,GAChCxK,EAAQ0B,GAAOuH,EAAUuB,EAC3B,EAEAC,sBAAuB,SAAC/I,UACf1B,EAAQ0B,EACjB,EAEAgJ,aAAc,WACZ1K,EAAU,CAAC,CACb,EAEJ,CC5CA,IC8FI2K,ED5FJ,0BACU,KAAAC,OAA4B,EAatC,QAXE,YAAAV,IAAA,SAAIpC,GACahI,KAAK8K,OAAOpG,KAAKsD,GANf,KAQfhI,KAAK8K,OAAOC,OAAO,EAAG,EAE1B,EAEA,YAAAC,MAAA,WACEhL,KAAK8K,OAAOpJ,SAAQ,SAACsG,GAAa,OAAAA,GAAA,IAClChI,KAAK8K,OAAOlG,OAAS,CACvB,EACF,EAdA,GCMO,SAASqG,EAAiBC,GAC/B,MAAO,CAAEA,SAAQ,EAAEC,UAAWC,EAAsBF,GACtD,CAEA,SAASE,EAAsBC,GAC7B,IAAMC,EAAmBC,IAAYC,YAAYC,MAEjD,OAAIH,EAAkBI,KACbxJ,KAAKM,MAAMmJ,GAAYL,EAAiBD,IAmE5C,SAAsBA,GAC3B,OAAOnJ,KAAKM,MAAMmJ,GAAYD,KAAsBL,GACtD,CAnESO,CAAaP,EACtB,CAQO,SAASQ,EAAiBC,GAC/B,OAAK9G,EAAS8G,GAGPtJ,EAAiB,IAAXsJ,EAAgB,GAFpBA,CAGX,CAEO,SAASP,IAMd,OAAO,IAAI9C,MAAOC,SACpB,CAEO,SAASqD,IACd,OAAOR,GACT,CAEO,SAASS,IACd,OAAOR,YAAYC,KACrB,CAEO,SAASQ,IACd,MAAO,CAAEf,SAAUc,IAAeb,UAAWY,IAC/C,CAEO,SAASG,KACd,MAAO,CAAEhB,SAAU,EAAmBC,UAAWO,KACnD,CAIO,SAASS,GAAQC,EAAeC,GACrC,OAAQA,EAAMD,CAChB,CAKO,SAAST,GAAYW,EAAWC,GACrC,OAAOD,EAAIC,CACb,CASO,SAASC,GAAgBC,GAC9B,OAAQA,EAAYf,IACtB,CAeA,SAASA,KAIP,YAHwB5K,IAApB+J,IACFA,EAAkBW,YAAYkB,OAAO7B,iBAEhCA,CACT,CClGO,IAaH8B,GAAsCC,GA0DtCC,GAzDG,SAASC,GAAkBC,EAA8BC,GAC9DL,GAAoBI,EACpBH,GAAoBI,CACtB,CAEO,SAASA,GAAUvG,EAAc5D,EAAeoK,EAAqBvM,GAC1E,GAAIkM,GACFA,GAAkBnG,EAAM5D,EAAOoK,OADjC,CAIA,IAAMC,EAAO,IAAIzE,KACjByE,EAAKC,QAAQD,EAAKxE,UAAYuE,GAC9B,IAAMG,EAAU,kBAAWF,EAAKG,eAC1BC,EAAW5M,GAAWA,EAAQ6M,UAAY,OAAS,SACnDC,EAAS9M,GAAWA,EAAQ8M,OAAS,kBAAW9M,EAAQ8M,QAAW,GACnEC,EAAS/M,GAAWA,EAAQ+M,OAAS,UAAY,GACvDxF,SAASyF,OAAS,UAAGjH,EAAI,YAAI5D,EAAK,YAAIuK,EAAO,4BAAoBE,GAAQ,OAAGE,GAAM,OAAGC,E,CACvF,CAEO,SAASV,GAAUtG,GACxB,OAAIkG,GACKA,GAAkBlG,GAEpBF,EAAwB0B,SAASyF,OAAQjH,EAClD,CAEO,SAASkH,GAAalH,EAAc/F,GACzCsM,GAAUvG,EAAM,GAAI,EAAG/F,EACzB,CCjCO,SAASkN,KACd,OAAOC,QACJ7H,OAAyB8H,iCAAmCf,GAVf,kCAYlD,CCLO,SAASgB,KACd,IAAMC,EA2BCxI,IAAgDyI,mBAzBvD,GAAKD,EAIL,MAAO,CACLE,uBAAA,WACE,OAAOnL,KAAKoL,MAAMH,EAAkBE,yBACtC,EACAE,KAAA,SAAKC,EAAcjH,GACjB4G,EAAkBI,KAAKrL,KAAKC,UAAU,CAAEqL,UAAS,EAAEjH,MAAK,IAC1D,EAEJ,CAEO,SAASkH,GAAkBC,G,WAAA,IAAAA,MAAgD,QAAhD,EAAc/I,IAA0BgJ,gBAAQ,eAAEC,UAClF,IAAMC,EAASX,KACf,QACIW,GACFA,EACGR,yBACA1E,MAAK,SAACmF,GAAgB,OAAAJ,IAAgBI,IP8PpB1K,EO9P4CsK,EP8PzBrK,EO9PsC,WAAIyK,GP+P7E1K,EAAUsB,OAAOrB,EAAOU,UAAYV,GADtC,IAAkBD,EAAmBC,CO9Pf,GAE7B,CCjCA,IAAM0K,GAAmB,IAKlB,SAASC,GAAkBC,GAChC,IAAMC,EAAsB,GAExBC,EAAgBC,GAAeH,EAAI,SACjCI,EAAWC,OAAOL,GAkBxB,OAjBIE,GAAiB1J,EAAW0J,EAAeE,KAC7CF,EAAgBA,EAAczJ,MAAM2J,EAAStK,SAE3CoK,GACFA,EAAcI,MAAM,MAAM1N,SAAQ,SAAC2N,GACjC,IAAMC,EAwBZ,SAAyBD,GACvB,IAAME,EAAQC,GAAe5I,KAAKyI,GAElC,IAAKE,EACH,OAGF,IAAME,EAAWF,EAAM,IAAqC,IAA/BA,EAAM,GAAGpL,QAAQ,UACxCuL,EAASH,EAAM,IAAmC,IAA7BA,EAAM,GAAGpL,QAAQ,QACtCwL,EAAWC,GAAehJ,KAAK2I,EAAM,IAEvCG,GAAUC,IAEZJ,EAAM,GAAKI,EAAS,GACpBJ,EAAM,GAAKI,EAAS,GACpBJ,EAAM,GAAKI,EAAS,IAGtB,MAAO,CACLpQ,KAAMkQ,EAAW,CAACF,EAAM,IAAM,GAC9BM,OAAQN,EAAM,IAAMA,EAAM,QAAKzO,EAC/BgP,KAAMP,EAAM,IAAMX,GAClBS,KAAME,EAAM,IAAMA,EAAM,QAAKzO,EAC7BiP,IAAMN,OAAsB3O,EAAXyO,EAAM,GAE3B,CAhDQS,CAAgBX,IAoDxB,SAAkCA,GAChC,IAAME,EAAQU,GAA6BrJ,KAAKyI,GAEhD,IAAKE,EACH,OAGF,MAAO,CACLhQ,KAAM,GACNsQ,OAAQN,EAAM,IAAMA,EAAM,QAAKzO,EAC/BgP,KAAMlB,GACNS,KAAME,EAAM,IAAMA,EAAM,QAAKzO,EAC7BiP,IAAKR,EAAM,GAEf,CAlEiCW,CAAyBb,IAuE1D,SAAsBA,GACpB,IAAME,EAAQY,GAAcvJ,KAAKyI,GACjC,IAAKE,EACH,OAGF,MAAO,CACLhQ,KAAM,GACNsQ,OAAQN,EAAM,IAAMA,EAAM,QAAKzO,EAC/BgP,KAAMP,EAAM,IAAMX,GAClBS,MAAOE,EAAM,GACbQ,IAAKR,EAAM,GAEf,CApFmEa,CAAaf,IA0FhF,SAAwBA,GACtB,IAAME,EAAQc,GAAczJ,KAAKyI,GACjC,IAAKE,EACH,OAGF,IAAMG,EAASH,EAAM,IAAMA,EAAM,GAAGpL,QAAQ,YAAc,EACpDwL,EAAWW,GAAc1J,KAAK2I,EAAM,IAEtCG,GAAUC,IAEZJ,EAAM,GAAKI,EAAS,GACpBJ,EAAM,GAAKI,EAAS,GACpBJ,EAAM,QAAKzO,GAGb,MAAO,CACLvB,KAAMgQ,EAAM,GAAKA,EAAM,GAAGH,MAAM,KAAO,GACvCS,OAAQN,EAAM,IAAMA,EAAM,QAAKzO,EAC/BgP,KAAMP,EAAM,IAAMX,GAClBS,KAAME,EAAM,IAAMA,EAAM,QAAKzO,EAC7BiP,IAAKR,EAAM,GAEf,CAjHyFgB,CAAelB,GAC9FC,KACGA,EAAWQ,MAAQR,EAAWD,OACjCC,EAAWQ,KAAOlB,IAGpBG,EAAMrK,KAAK4K,GAEf,IAGK,CACLkB,QAASvB,GAAeH,EAAI,WAC5BrI,KAAMwI,GAAeH,EAAI,QACzBC,MAAK,EAET,CACA,IAAM0B,GAAU,yFACVC,GAAe,cACflB,GAAiB,IAAI7I,OAAO,4BAAqB8J,IAAO,OAAGC,GAAY,YAAIA,GAAY,cAAc,KAErGd,GAAiB,IAAIjJ,OAAO,mBAAY+J,IAAY,OAAGA,GAAY,QA6BzE,IAAMT,GAA+B,IAAItJ,OAAO,mBAAY8J,IAAO,OAAGC,GAAY,YAAIA,GAAY,WAAW,KAkB7G,IAAMP,GACJ,gHAiBF,IAAME,GACJ,4IACIC,GAAgB,gDA2BtB,SAASrB,GAAehL,EAAoByG,GAC1C,GAAyB,iBAAdzG,GAA2BA,GAAeyG,KAAYzG,EAAjE,CAGA,IAAMpB,EAASoB,EAAuCyG,GACtD,MAAwB,iBAAV7H,EAAqBA,OAAQ/B,C,CAC7C,CC/GO,ICpBH6P,GC8CAC,GF1BSC,GACJ,QADIA,GAEF,UAFEA,GAGH,SAHGA,GAMH,SANGA,GAOH,SAqBH,SAASC,GAAgB,G,IAC9BC,EAAU,aACVC,EAAa,gBACbC,EAAa,gBACbC,EAAW,cACXC,EAAc,iBACdxP,EAAM,SACNyP,EAAQ,WAER,OAAKL,SAAsCjQ,IAAvBiQ,EAAWP,SAA2BQ,aAAyBK,OAa5E,CACLH,YAAW,EACXvP,OAAM,EACNyP,SAAQ,EACRJ,cAAa,EACbR,QAASO,EAAWP,SAAW,gBAC/BzB,MAAOuC,GAAmBP,GAC1BE,cAAa,EACbtN,KAAMoN,EAAWtK,KACjB8K,OAAQC,GAAmBR,EAAiCrP,IArBrD,CACLuP,YAAW,EACXvP,OAAM,EACNyP,SAAQ,EACRJ,cAAa,EACbR,QAAS,UAAGW,EAAc,YAAIvO,EAAcoO,IAC5CjC,MAAO,gDACPkC,cAAa,EACbtN,KAAMoN,GAAcA,EAAWtK,KAerC,CAEO,SAAS6K,GAAmBvC,GACjC,IAAI0C,EAASC,GAAmB3C,GAQhC,OAPAA,EAAMA,MAAMrN,SAAQ,SAACiQ,GACnB,IAAM7B,EAAsB,MAAf6B,EAAM7B,KAAe,cAAgB6B,EAAM7B,KAClDvQ,EAAOoS,EAAMpS,MAAQoS,EAAMpS,KAAKqF,OAAS,EAAI,WAAI+M,EAAMpS,KAAK0J,KAAK,MAAK,KAAM,GAC5EoG,EAAOsC,EAAMtC,KAAO,WAAIsC,EAAMtC,MAAS,GACvCQ,EAAS8B,EAAMtC,MAAQsC,EAAM9B,OAAS,WAAI8B,EAAM9B,QAAW,GACjE4B,GAAU,iBAAU3B,GAAK,OAAGvQ,EAAI,cAAMoS,EAAM5B,KAAI,OAAGV,GAAI,OAAGQ,EAC5D,IACO4B,CACT,CAMO,SAASC,GAAmB3C,GACjC,MAAO,UAAGA,EAAMtI,MAAQ,QAAO,aAAKsI,EAAMyB,QAC5C,CASO,SAASoB,KAOd,IAEIC,EADE7S,EAAQ,IAAIqS,MAIlB,IAAKrS,EAAM+P,MACT,IACE,MAAM/P,C,CACN,MAAOoB,G,CAWX,OANAL,GAAc,WACZ,IAAMgR,EAAalC,GAAkB7P,GACrC+R,EAAWhC,MAAQgC,EAAWhC,MAAMxJ,MAfT,GAgB3BsM,EAAiBP,GAAmBP,EACtC,IAEOc,CACT,CAEO,SAASL,GAAmBxS,EAAuB8S,GAGxD,IAFA,IAAIC,EAAe/S,EACbuS,EAA0B,IACzBQ,aAAY,EAAZA,EAAcC,iBAAiBX,OAASE,EAAO3M,OAAS,IAAI,CACjE,IAAMmM,EAAalC,GAAkBkD,EAAaC,OAClDT,EAAO7M,KAAK,CACV8L,QAASuB,EAAaC,MAAMxB,QAC5B7O,OAAQmQ,EACRnO,KAAMoN,aAAU,EAAVA,EAAYtK,KAClBsI,MAAOgC,GAAcO,GAAmBP,KAE1CgB,EAAeA,EAAaC,K,CAE9B,OAAOT,EAAO3M,OAAS2M,OAASzQ,CAClC,CCnIO,SAASmR,GAA6BC,GAC3C,QAASvB,IAA+BA,GAA4BtI,IAAI6J,EAC1E,CAMO,SAASC,KACd,OAAOxB,IAA+B,IAAInM,GAC5C,CCvCO,SAAS4N,GAAarC,GAC3B,OAAOsC,GAAStC,EXiUT9J,EAAqBD,OAAOwI,WWjUO8D,IAC5C,CAcO,SAASC,GAAUxC,GACxB,OAAO9J,EAAqBoM,GAAStC,GACvC,CAeO,SAASsC,GAAStC,EAAayC,GACpC,GAoBF,WACE,QAAuB1R,IAAnB8P,GACF,OAAOA,GAET,IACE,IAAMb,EAAM,IAAI0C,IAAI,oBAEpB,OADA7B,GAA8B,qBAAbb,EAAIuC,I,CAErB,SACA1B,IAAiB,C,CAEnB,OAAOA,EACT,CAhCM8B,GACF,YAAgB5R,IAAT0R,EAAqB,IAAIC,IAAI1C,EAAKyC,GAAQ,IAAIC,IAAI1C,GAE3D,QAAajP,IAAT0R,IAAuB,IAAI/I,KAAKsG,GAClC,MAAM,IAAIsB,MAAM,wBAAiBtB,EAAG,MAEtC,IAAI4C,EAAM1K,SACJ2K,EAAgBD,EAAIE,cAAc,KACxC,QAAa/R,IAAT0R,EAAoB,CAEtB,IAAMM,GADNH,EAAM1K,SAAS8K,eAAeC,mBAAmB,KACzBH,cAAc,QACtCC,EAAYR,KAAOE,EACnBG,EAAIM,KAAKC,YAAYJ,GACrBH,EAAIQ,KAAKD,YAAYN,E,CAGvB,OADAA,EAAcN,KAAOvC,EACd6C,CACT,CCrDO,IACMQ,GAAkB,gBCQlBC,GAAY,CACvBC,KAAM,OACNC,IAAK,MACLC,cAAe,kBAGXC,GAAgB,CACpBH,KAAM,OACNC,IAAK,MACLC,cAAe,UAOV,SAASE,GACdC,EACAC,EACAC,GAEQ,MAAwCF,EAAiB,KAAzDG,OAAI,IAAG,EAAAV,GAAe,EAAEW,EAAgBJ,EAAiB,YAE3DK,EAAcF,EAAK1E,MAAM,KACzB6E,EAAYD,EAAYE,MACxB7N,EAAO,UAAGgN,GAAUO,GAAa,2BAAmBI,EAAY/K,KAAK,KAAI,YAAIgL,GAC7EE,EAAU,kBAAW9N,EAAI,mBAAWoN,GAAcG,IAClDQ,EAAWT,EAAkBS,UAAYhC,GAAauB,EAAkBS,UAE9E,MAAO,CACLC,MAAK,WACH,IAAIjT,EACF,mBACA,kBAAWkT,mBAAmB,CAAC,sBAAe,QAA8BC,OAAOV,GAAM5K,KAAK,OAC9F,sBAAe8K,GACf,iCAA0BO,mBAAmB,QAC7C,yBACA,yBAAkBvS,KAEC,QAAjB6R,IACFxS,GAAc,sBAAe2K,MAE/B,IAAMyI,EAAc,UAAGL,EAAO,YAAI/S,GAElC,OAAOgT,EAAW,UAAGA,EAAQ,sBAAcE,mBAAmBE,IAAiBA,CACjF,EACAC,eAAc,WACZ,OAAOL,EAAW,UAAGA,EAAQ,cAAeD,CAC9C,EACAP,aAAY,EAEhB,CCnCA,IAAMc,GAAuB,iBAEtB,SAASC,GAAS/S,EAAagT,GAIpC,IAAMC,EA5BsB,IA4BYjT,EAAIgD,OAAS,GAEjDgQ,EAAShQ,OAASiQ,GAAkBH,GAAqBjL,KAAKmL,KAChE3V,EAAQF,KAAK,UAAG6C,EAAG,+DAKrB,IAAMkT,EAAiBF,EAASvS,QAAQ,KAAM,KAE9C,MAAO,UAAGT,EAAG,YAAIkT,EACnB,CCpBO,SAASC,GAA8BpB,GAC5C,IAAME,EDlBD,SAAmBmB,GAChB,IAAAC,EAAsCD,EAAa,IAA9CE,EAAiCF,EAAa,QAArCG,EAAwBH,EAAa,QAA5BI,EAAeJ,EAAa,WACrDnB,EAAO,GAeb,OAbIoB,GACFpB,EAAKnP,KAAKiQ,GAAS,MAAOM,IAExBC,GACFrB,EAAKnP,KAAKiQ,GAAS,UAAWO,IAE5BC,GACFtB,EAAKnP,KAAKiQ,GAAS,UAAWQ,IAE5BC,GACFvB,EAAKnP,KAAKiQ,GAAS,aAAcS,IAG5BvB,CACT,CCAewB,CAAU1B,GAEjB2B,EAeR,SAAiC3B,EAAsCE,GACrE,MAAO,CACL0B,oBAAqB7B,GAAsBC,EAAmB,OAAQE,GACtE2B,mBAAoB9B,GAAsBC,EAAmB,MAAOE,GACpE4B,6BAA8B/B,GAAsBC,EAAmB,gBAAiBE,GAE5F,CArB2B6B,CAAwB/B,EAAmBE,GAC9D8B,EAAkB1Q,EAAaqQ,GAAkBnQ,KAAI,SAACyQ,GAAY,OAAAA,EAAQnB,gBAAR,IAElEoB,EAoBR,SACElC,EACAgC,EACA9B,GAEA,IAAKF,EAAkBmC,QACrB,OAGF,IAAMD,EAA0C,EAAO,CAAC,EAAGlC,EAAmB,CAC5EG,KAAMV,GACNW,YAAaJ,EAAkBmC,QAAQ/B,cAGnCgC,EAA0B,CAC9BR,oBAAqB7B,GAAsBmC,EAAsB,OAAQhC,GACzE2B,mBAAoB9B,GAAsBmC,EAAsB,MAAOhC,IAKzE,OAFA8B,EAAgBjR,KAAI,MAApBiR,EAAwB1Q,EAAa8Q,GAAyB5Q,KAAI,SAACyQ,GAAY,OAAAA,EAAQnB,gBAAR,KAExE,EAAO,CAAEuB,cAAerC,EAAkBmC,QAAQE,eAAiBD,EAC5E,CA1C+BE,CAA4BtC,EAAmBgC,EAAiB9B,GAE7F,OAAO,EACL,CACEqC,YAAa,SAACnG,GAAgB,OAAA4F,EAAgBnM,MAAK,SAAC2M,GAAmB,OAAgC,IAAhCpG,EAAI5L,QAAQgS,EAAZ,GAAzC,EAC9BL,QAASD,EACT/B,KAAMH,EAAkBG,MAAQV,IAElCkC,EAEJ,CC5BO,IAAMc,GAAsB,CACjCC,MAAO,QACPC,KAAM,OACNC,gBAAiB,mBAiEZ,SAASC,GAA8B7C,G,UAC5C,GAAKA,GAAsBA,EAAkBI,YAK7C,QAAqCjT,IAAjC6S,EAAkB8C,YAA6B1R,EAAa4O,EAAkB8C,YAKlF,QAA8C3V,IAA1C6S,EAAkB+C,qBAAsC3R,EAAa4O,EAAkB+C,qBAK3F,QACyD5V,IAAvD6S,EAAkBgD,kCACjB5R,EAAa4O,EAAkBgD,kCAFlC,CNnFK,IAAoCC,EM2FzC,KAAMjD,EAAkB3G,aAAgB2G,EAAkB5G,UAQ1D,ONnGyC6J,EMiGdjD,EAAkBkD,2BN/FxCxT,MAAM8E,QAAQyO,KAIdjG,KACHA,GAA8B,IAAInM,IAAIoS,IAGxCA,EACGE,QAAO,SAACC,GAAS,MAAgB,iBAATA,CAAP,IACjBrV,SAAQ,SAACqV,GACJ/S,EAAS+S,EAAM,MACjB9X,EAAQF,KAAK,qCAA8BgY,EAAI,MAEjDpG,GAA6BvG,IAAI2M,EACnC,KMkFK,EACL,CACEC,WACErD,EAAkBqD,YAAchN,EAAgB2J,EAAkBqD,WAAY,8BAChFC,cAAeC,GAAmBvD,GAClC8C,WAAwC,QAA5B,EAAA9C,EAAkB8C,kBAAU,QAAI,IAC5CC,oBAA0D,QAArC,EAAA/C,EAAkB+C,2BAAmB,QAAI,GAC9DC,iCAAoF,QAAlD,EAAAhD,EAAkBgD,wCAAgC,QAAI,EACxFzB,QAASvB,EAAkBuB,QAC3BiC,qBAAsBxD,EAAkBwD,mBAMxCC,gBAAiB,MAEjBC,0BAA2B,IAC3BC,0BAA2B,GAM3BC,aAAc,IAKdC,mBAAoB,GACpBC,kBAAmB,QAErB1C,GAA8BpB,IAvC9B1U,EAAQD,MAAM,yD,MALdC,EAAQD,MAAM,iFARdC,EAAQD,MAAM,mEALdC,EAAQD,MAAM,yDALdC,EAAQD,MAAM,6DAgElB,CAEO,SAASkY,GAAmBvD,GACjC,IAAMsD,EAA+B,CAAC,EAWtC,OATAnK,GAAkB6G,EAAkB5G,UAAY4G,EAAkB3G,WAElEiK,EAAcxJ,OAUhB,SAA6BkG,GAC3B,QAASA,EAAkB+D,0BAA4B/D,EAAkBgE,yBAC3E,CAZyBC,CAAoBjE,GAC3CsD,EAAc1J,YAAcoG,EAAkBgE,0BAE1ChE,EAAkBkE,+BACpBZ,EAAczJ,OXhFX,WACL,QAA4B1M,IAAxB+L,GAAmC,CAQrC,IALA,IAAMiL,EAAiB,uBAAgB/V,KAGjCgW,EAAe/R,OAAOwI,SAASC,SAASW,MAAM,KAChD4I,EAAkBD,EAAa7D,MAC5B6D,EAAanT,SAAWmI,GAAU+K,IACvCE,EAAkB,UAAGD,EAAa7D,MAAM,YAAI8D,GAC5ChL,GAAU8K,EANY,OAMqBxX,EAAY,CAAEkN,OAAQwK,IAEnErK,GAAamK,EAAgB,CAAEtK,OAAQwK,IACvCnL,GAAsBmL,C,CAExB,OAAOnL,EACT,CW+D2BoL,IAGlBhB,CACT,CC3JA,kBAIE,WAAoBiB,GAAA,KAAAA,mBAHZ,KAAAC,UAAsC,EAGqB,CAoBrE,OAlBE,YAAAC,UAAA,SAAUC,GAAV,WAKE,OAJKrY,KAAKmY,UAAUvT,QAAU5E,KAAKkY,mBACjClY,KAAKsY,kBAAoBtY,KAAKkY,yBAAsBpX,GAEtDd,KAAKmY,UAAUzT,KAAK2T,GACb,CACLE,YAAa,WACX,EAAKJ,UAAY,EAAKA,UAAUrB,QAAO,SAAC0B,GAAU,OAAAH,IAAMG,CAAN,KAC7C,EAAKL,UAAUvT,QAAU,EAAK0T,mBACjC,EAAKA,mBAET,EAEJ,EAEA,YAAAG,OAAA,SAAOC,GACL1Y,KAAKmY,UAAUzW,SAAQ,SAACiX,GAAa,OAAAA,EAASD,EAAT,GACvC,EACF,EAxBA,GA0BO,SAASE,K,IAAoB,sDAClC,IAAMC,EAAmB,IAAIC,IAAc,WACzC,IAAMC,EAAgCC,EAAY7T,KAAI,SAAC8T,GACrD,OAAAA,EAAWb,WAAU,SAACM,GAAS,OAAAG,EAAiBJ,OAAOC,EAAxB,GAA/B,IAEF,OAAO,WAAM,OAAAK,EAAcrX,SAAQ,SAACwX,GAAiB,OAAAA,EAAaX,aAAb,GAAxC,CACf,IAEA,OAAOM,CACT,CCrCO,IC0CHM,GD1CSC,GACN,MADMA,GAEI,gBCcXC,GAAqB,CACzB,0CACA,wCACA,mBACA,eAaIC,GAAqC,CPjCR,gBOmC7BC,GAKF,CAAEC,iBAAkB,EAAGC,eAAgB,EAAGC,kBAAkB,EAAOC,+BAA+B,GAI/F,SAASC,GAAeC,EAAoC7E,GACjE,IAAI8E,EACEb,EAAa,IAAIH,GAoCvB,OAlCAS,GAAuBG,iBAAmBpX,EAAY0S,EAAc0B,qBACpE6C,GAAuBI,8BACrBJ,GAAuBG,kBAAoBpX,EAAY0S,EAAc2B,kCAEvEwC,GAA+B,SAAC/R,IACzBpD,EAASsV,GAA0BtE,EAAclB,OAASyF,GAAuBG,kBACpFT,EAAWR,OAUf,SAA0BoB,EAAoCzS,GAC5D,OAAOgC,EACL,CACEzF,KAAM,YACNuJ,KAAMnB,IACNmJ,QAAS2E,EACT1E,QAAS,MACTxT,OAAQ,UACRoY,IAAK,CACHC,eAAgB,GAElBC,UAAW7S,EACX8S,sBAAuB9V,EAAU+N,YAEfrR,IAApBgZ,EAAgCA,IAAoB,CAAC,EAEzD,CA1BsBK,CAAiBN,EAAkBzS,GAEzD,EpBpDA1H,EoBqD4B0a,GAE5B,EAAOb,GAAwB,CAC7BC,iBAAkBxE,EAAcsC,0BAChCmC,eAAgB,IAqBX,CACLY,mBAAoB,SAACC,GACnBR,EAAkBQ,CACpB,EACArB,WAAU,EAEd,CA0CO,SAASmB,GAAkBha,GAChCma,GACE,EACE,CACE5W,KAAMyV,GACNoB,OAAQ,SAuBT,SAAqBpa,GAC1B,GAAIA,aAAaiR,MAAO,CACtB,IAAMN,EAAalC,GAAkBzO,GACrC,MAAO,CACLpB,MAAO,CACLyb,KAAM1J,EAAWtK,KACjBsI,MAAOuC,GAAmBoJ,GAAoB3J,KAEhDP,QAASO,EAAWP,Q,CAGxB,MAAO,CACLxR,MAAO,CACL+P,MAAO,4BAETyB,QAAS,mBAAY5N,EAAcxC,IAEvC,CAtCMua,CAAYva,IAGlB,CAWA,SAASma,GAAanT,GAChB+R,IAAgCI,GAAuBE,eAAiBF,GAAuBC,mBACjGD,GAAuBE,gBAAkB,EACzCN,GAA6B/R,GAEjC,CAqBO,SAASsT,GAAoB3J,GAIlC,OAHAA,EAAWhC,MAAQgC,EAAWhC,MAAM+H,QAClC,SAACnF,GAAU,OAACA,EAAM5B,KAAOsJ,GAAmB7P,MAAK,SAACoR,GAAoB,OAAAtV,EAAWqM,EAAM5B,IAAM6K,EAAvB,GAA3D,IAEN7J,CACT,CCtLO,SAAS8J,KACd,IAAMC,EA2BD,WACL,IAAIC,EACEC,EAA+BhV,OAarC,GAAIgV,EAAcC,KAAM,CACtB,IAAMC,EAAaF,EAAcC,KAAKE,WAStC,KAJAJ,EAAcC,EAAcE,EAAW,uBAInBF,EAAcF,iBAAkB,CAQlD,IACMM,EADkB,IAAIJ,EAAcF,iBAAiB,GAClBI,EAAW,qBAIpDH,EAAcK,GAAoBA,EAAiBL,W,EAIlDA,IACHA,EAAcC,EAAcF,kBAG9B,OAAOC,CACT,CA1E2BM,GAEnBpC,EAA+B,IAAIH,IAAiB,WACxD,GAAKgC,EAAL,CAGA,IAAMnC,EAAW,IAAImC,EAAiB,GAAQ,WAAM,OAAA7B,EAAWR,QAAX,KAOpD,OANAE,EAAS2C,QAAQrT,SAAU,CACzBsT,YAAY,EACZC,eAAe,EACfC,WAAW,EACXC,SAAS,IAEJ,WAAM,OAAA/C,EAASgD,YAAT,C,CACf,IAEA,OAAO1C,CACT,CCMO,IAAM2C,GAAwB,mBAE/BC,GAA0F,CAC9F,CAAC,WAAuB,SAACC,GAA0B,OAAAF,KAA0BE,CAA1B,GACnD,CAAC,MAAkB,SAACA,GAA0B,yBAAqBA,CAArB,GAC9C,CAAC,QAAoB,SAACA,GAA0B,gBAAYA,CAAZ,GAChD,CAAC,SAAqB,SAACA,GAA0B,iBAAaA,CAAb,GACjD,CAAC,MAAkB,SAACC,EAAWC,GAAiB,gBAAUvS,KAAKuS,EAAf,GAChD,CAAC,KAAiB,SAACD,EAAWC,GAAiB,eAASvS,KAAKuS,EAAd,GAC/C,C,QAEE,SAACF,EAAuBE,GACtB,OAAAhY,EAAS,CAAC,QAAS,MAAO,QAAS8X,IAAuE,OAArD,sCAAsClV,KAAKoV,EAAhG,GAEJ,CAAC,OAAmB,SAACD,EAAWC,GAAiB,OAA0C,OAA1C,2BAA2BpV,KAAKoV,EAAhC,GACjD,C,QAEE,SAACF,EAAuBE,GACtB,OAAAhY,EAAS,CAAC,QAAS,SAAU8X,IAAiD,OAA/B,gBAAgBlV,KAAKoV,EAApE,IAIC,SAASC,GAAoBvP,GAClC,IFqEgC8D,EAAiBtQ,EErE3C6P,EAAMrD,EAAOjG,KACnB,IV5CK,SAAoBsJ,GACzB,IACE,QAASsC,GAAStC,E,CAClB,SACA,OAAO,C,CAEX,CUsCOmM,CAAWnM,GAEd,OFkE8BS,EEnEZ,uCAAgC9D,EAAOjG,KAAI,KFoE/DpG,EAAsB1B,EAAeE,MAAO2R,EAAStQ,GACrDqa,GACE,EACE,CACE5W,KAAMyV,GACN5I,QAAO,EACPgK,OAAQ,SAEVta,IE3EK,QAGT,IADA,IAAM8b,EVhCD,SAAqBjM,GAC1B,IAAMoM,EAAW9J,GAAStC,GAAKoM,SAC/B,MAAuB,MAAhBA,EAAS,GAAaA,EAAW,WAAIA,EAC9C,CU6BeC,CAAYrM,GACI,MAAA8L,GAAA,eAAgB,CAAlC,WAAClY,EAAI,KACd,IAAI0Y,EADkB,MACX3P,EAAOoP,cAAeE,GAC/B,OAAOrY,C,CAGX,MAAO,OACT,CAEA,SAAS2Y,K,IAAW,sDAClB,IAAK,IAAI3X,EAAI,EAAGA,EAAI4X,EAAQ3X,OAAQD,GAAK,EACvC,GAAI4X,EAAQ5X,EAAI,GAAK4X,EAAQ5X,GAC3B,OAAO,EAGX,OAAO,CACT,CAiBO,SAAS6X,GACdC,GAEA,IAAMC,EAAaC,GAAaF,GAEhC,GAAKC,EAAL,CAIE,IAAAE,EAYEF,EAAU,UAXZG,EAWEH,EAAU,WAVZI,EAUEJ,EAAU,cATZK,EASEL,EAAU,YARZM,EAQEN,EAAU,kBAPZO,EAOEP,EAAU,gBANZQ,EAMER,EAAU,aALZS,EAKET,EAAU,sBAJZU,EAIEV,EAAU,WAHZW,EAGEX,EAAU,aAFZY,EAEEZ,EAAU,cAERa,EAAsC,CAC1CC,SAAUC,GAAab,EAAWU,EAHhCZ,EAAU,aAIZgB,WAAYD,GAAab,EAAWS,EAAcC,IAsBpD,OAlBIF,IAAeP,IACjBU,EAAQI,QAAUF,GAAab,EAAWM,EAAcE,GAGpDd,GAAWY,EAAcC,EAAuBC,KAClDG,EAAQK,IAAMH,GAAab,EAAWO,EAAuBC,KAK7DH,IAAoBJ,IACtBU,EAAQM,IAAMJ,GAAab,EAAWI,EAAmBC,IAGvDa,GAAerB,KACjBc,EAAQQ,SAAWN,GAAab,EAAWE,EAAeC,IAGrDQ,C,CACT,CAEO,SAASZ,GAAaF,GAK3B,GACGH,GACCG,EAAMG,UACNH,EAAMI,WACNJ,EAAMO,kBACNP,EAAMQ,gBACNR,EAAMS,aACNT,EAAMW,WACNX,EAAMY,aACNZ,EAAMa,cACNb,EAAMuB,aAVV,CAgBA,IAAKF,GAAerB,GAClB,OAAOA,EAGH,IAAAK,EAA+BL,EAAK,cAArBM,EAAgBN,EAAK,YAW1C,GARIK,EAAgBL,EAAMG,YACxBE,EAAgBL,EAAMG,WAEpBG,EAAcN,EAAMG,YACtBG,EAAcN,EAAMI,YAIjBP,GAAWG,EAAMG,UAAWE,EAAeC,EAAaN,EAAMI,YAInE,OAAO,EAAO,CAAC,EAAGJ,EAAO,CACvBM,YAAW,EACXD,cAAa,G,CAEjB,CAEA,SAASgB,GAAerB,GAEtB,OAAOA,EAAMI,aAAeJ,EAAMG,SACpC,CAEA,SAASa,GAAatX,EAAsBiG,EAAqBC,GAC/D,MAAO,CACLP,SAAUD,EAAiBM,GAAQC,EAAOC,IAC1CD,MAAOP,EAAiBM,GAAQhG,EAAQiG,IAE5C,CAEO,SAAS6R,GAAYxB,GAE1B,GAAIA,EAAMG,UAAYH,EAAMa,cAC1B,OAAOb,EAAMyB,eAGjB,CAEO,SAASC,GAAoBnJ,EAAiCjF,GACnE,OAAOA,IAAQiF,EAAckB,YAAYnG,EAC3C,CCrMO,ICDHqO,GCJAC,GFOG,SAASC,GAAmBrW,GACjC,IAAMyQ,EASD,SAAsCzQ,GAC3C,IAAMsW,EAActW,EAASuW,cAA+B,0BACtDC,EAAgBxW,EAASuW,cAA+B,4BAC9D,OAAOE,GAAwBH,GAAeA,EAAYI,QAASF,GAAiBA,EAAcE,QACpG,CAbeC,CAA6B3W,IAerC,SAAyCA,GAC9C,IAAM4W,EAyBD,SAA0B5W,GAI/B,IAAK,IAAItD,EAAI,EAAGA,EAAIsD,EAAS6W,WAAWla,OAAQD,GAAK,EAAG,CAEtD,GADMka,EAAUE,GAAwB9W,EAAS6W,WAAWna,IAE1D,OAAOka,C,CAQX,GAAI5W,EAASkL,KACX,IAASxO,EAAIsD,EAASkL,KAAK2L,WAAWla,OAAS,EAAGD,GAAK,EAAGA,GAAK,EAAG,CAChE,IACMka,EADAG,EAAO/W,EAASkL,KAAK2L,WAAWna,GAEtC,GADMka,EAAUE,GAAwBC,GAEtC,OAAOH,EAET,IAAKI,GAAWD,GACd,K,CAIR,CApDkBE,CAAiBjX,GACjC,IAAK4W,EACH,OAEF,OAAOH,GACLnY,EAAwBsY,EAAS,YACjCtY,EAAwBsY,EAAS,cAErC,CAxByDM,CAAgClX,GAEvF,GAAKyQ,KAAQA,EAAK0G,WAAa7T,IAL2B,MAS1D,OAAOmN,EAAK2G,OACd,CAmBO,SAASX,GACdW,EACAC,GAEA,IAAMF,EAAYE,GAAiBC,OAAOD,GAC1C,GAAKD,GAAYD,EAIjB,MAAO,CACLC,QAAO,EACPD,UAAS,EAEb,CA+BA,SAASL,GAAwBC,GAC/B,GAAIA,GAQN,SAAuBA,GACrB,MAAyB,aAAlBA,EAAKQ,QACd,CAVcC,CAAcT,GAAO,CAC/B,IAAMU,EAAQ,wBAAwB9Y,KAAKoY,EAAKtG,MAChD,GAAIgH,EACF,OAAOA,EAAM,E,CAGnB,CAMA,SAAST,GAAWD,GAClB,MAAyB,UAAlBA,EAAKQ,QACd,CGJA,SAASG,KACP,YAA8B7e,IAAvBkF,OAAOwF,aAA6B,eAAgBA,WAC7D,CAEO,SAASoU,GAA8BC,GAC5C,OACE7Z,OAAO8Z,0BACqChf,IAA5Cgf,oBAAoBC,qBACpBD,oBAAoBC,oBAAoB/b,SAAS6b,EAErD,CAEO,SAASG,GAA2BC,EAAsBjL,GAuD1D,IAA+ChN,EAlDpD,GAkDoDA,EAtDd,SAAC0E,GACrCwT,GAA4BD,EAAWjL,EAAe,CAACtI,GACzD,EAqDA5E,EAAgB,eAAe,WAC7B,IAAI4E,EAEEyT,EAAmB,CACvBN,UAAW,WACX/D,cAAeF,GACfyD,QAASf,GAAmBrW,WAE9B,GAAI2X,GAA8B,eAAiBpU,YAAY4U,iBAAiB,cAAcxb,OAAS,EAErG8H,EAAS,EADelB,YAAY4U,iBAAiB,cAAc,GACnCrc,SAAUoc,OACrC,CACL,IAAME,EAA4BC,KAClC5T,EAAS,EACP2T,EACA,CACEnC,gBAAiB,EACjBpS,SAAUuU,EAA0BrC,YACpCvX,KAAMT,OAAOwI,SAAS8D,KACtBsK,UAAW,GAEbuD,E,CAGJnY,EAAS0E,EACX,IA5EIiT,KAA4B,CAC9B,IAAM,EAAqBnU,YAAY+U,aAGvClf,WAAW,GAAQ,WAAM,OAAA6e,GAA4BD,EAAWjL,EAAe,EAAtD,I,CAG3B,GAAIhP,OAAO8Z,oBAAqB,CAC9B,IAAM,EAA6B,GAAQ,SAACU,GAC1C,OAAAN,GAA4BD,EAAWjL,EAAewL,EAAQD,aAA9D,IAEIE,EAAc,CAAC,WAAY,aAAc,WAAY,SACrDC,EAAsB,CAAC,2BAA4B,cAAe,gBAExE,IAIEA,EAAoBhf,SAAQ,SAACiC,GACV,IAAImc,oBAAoB,GAChCxE,QAAQ,CAAE3X,KAAI,EAAEgd,UAAU,GACrC,G,CACA,MAAOvgB,GAGPqgB,EAAY/b,KAAI,MAAhB+b,EAAoBC,E,CAGD,IAAIZ,oBAAoB,GAChCxE,QAAQ,CAAEsF,WAAYH,IAE/Bd,MAA8B,qBAAsBnU,aAEtDA,YAAYtE,iBAAiB,4BAA4B,WACvDsE,YAAYqV,sBACd,G,CAGCjB,GAA8B,eAyCrC,SAAkC5X,GAChC,SAAS8Y,IACP9Y,EACE,EAAOsY,KAAoC,CACzCT,UAAW,eAGjB,CAEA/X,EAAgB,YAAY,WAE1BzG,WAAW,EAAQyf,GACrB,GACF,CArDIC,EAAyB,SAACrU,GACxBwT,GAA4BD,EAAWjL,EAAe,CAACtI,GACzD,IAEGkT,GAA8B,gBAuDrC,SAAkC5X,GAChC,IAAMgZ,EAAiBzV,IACnB0V,GAAa,EAEHC,EAAyB5Z,EACrCtB,OACA,CAAC,QAAD,mDACA,SAACmb,GAEC,GAAKA,EAAIC,WAAT,CAOA,IAAM1U,EAA8B,CAClCmT,UAAW,cACXwB,gBAAiBrV,IACjB4Q,UAAWuE,EAAIhW,WAGA,gBAAbgW,EAAIxd,KACN2d,EAAkC5U,GAElC6U,EAAW7U,E,CAEf,GACA,CAAEhF,SAAS,EAAMD,SAAS,IAC3B,KAQD,SAAS6Z,EAAkC5U,GACzCpF,EACEtB,OACA,CAAC,YAAD,kBACA,SAACoB,GACoB,cAAfA,EAAMzD,MACR4d,EAAW7U,EAEf,GACA,CAAElF,MAAM,GAEZ,CAEA,SAAS+Z,EAAW7U,GAClB,IAAKuU,EAAY,CACfA,GAAa,EACbC,IAMA,IAAMM,EAAQ9U,EAAO2U,gBAAkB3U,EAAOkQ,UAC1C4E,GAAS,GAAKA,EAAQjW,IAAYyV,GACpChZ,EAAS0E,E,CAGf,CACF,CAvHI+U,EAAyB,SAAC/U,GACxBwT,GAA4BD,EAAWjL,EAAe,CAACtI,GACzD,GAEJ,CAyHA,SAAS4T,KACP,IAAM7O,EAA6C,CAAC,EAC9C/E,EAASlB,YAAYkB,OAC3B,IAAK,IAAM9K,KAAO8K,EAChB,GAAI1H,EAAS0H,EAAO9K,IAAkC,CACpD,IAAM8f,EAAY9f,EACZ+f,EAAgBjV,EAAOgV,GAC7BjQ,EAAOiQ,GAA+B,IAAlBC,EAAuB,EAAqBnV,GAAgBmV,E,CAGpF,OAAOlQ,CACT,CAEA,SAASyO,GACPD,EACAjL,EACAwL,GAEA,IAWMoB,EAXwBpB,EAAQ1J,QACpC,SAAC2F,GACC,MAAoB,aAApBA,EAAMoD,WACc,eAApBpD,EAAMoD,WACc,UAApBpD,EAAMoD,WACc,aAApBpD,EAAMoD,WACc,6BAApBpD,EAAMoD,WACc,gBAApBpD,EAAMoD,WACc,iBAApBpD,EAAMoD,SANN,IASuD/I,QACzD,SAAC2F,GAAU,OAQf,SAAgCA,GAC9B,MAA2B,eAApBA,EAAMoD,WAA8BpD,EAAMoF,cAAgB,CACnE,CAVgBC,CAAuBrF,KAYvC,SAA6BzH,EAAiCyH,GAC5D,MAA2B,aAApBA,EAAMoD,YAA6B1B,GAAoBnJ,EAAeyH,EAAMhW,KACrF,CAdkDsb,CAAoB/M,EAAeyH,EAAtE,IAGTmF,EAA6Bhd,QAC/Bqb,EAAUxH,OAAO,EAAkDmJ,EAEvE,CCnTO,SAASI,GACd3T,EACA4T,EACAC,GAEA,IAAIC,EAAa,EACbC,GAAiB,EAErB,MAAO,CACLC,eAAc,WAQZ,GAPmB,IAAfF,GACF9gB,YAAW,WACT8gB,EAAa,CACf,GAAG5hB,IAGL4hB,GAAc,IACIF,GAASG,EAEzB,OADAA,GAAiB,GACV,EAGT,GAAID,IAAeF,EAAQ,EAAG,CAC5BG,GAAiB,EACjB,IACEF,EAAe,CACb1R,QAAS,gCAAyBnC,EAAS,wBAAgB4T,GAC3DtgB,OAAQkP,GACRK,YAAajF,K,SAGfmW,GAAiB,C,EAIrB,OAAO,CACT,EAEJ,CCjBA,SAASzc,GAAI7D,EAAiBka,GAE5B,IADA,IAAIsG,EAAUxgB,EACM,MAAAka,EAAK5M,MAAM,KAAX,eAAiB,CAAhC,IAAMmT,EAAK,KACd,IAAKC,GAAwBF,EAASC,GACpC,OAEFD,EAAUA,EAAQC,E,CAEpB,OAAOD,CACT,CAEA,SAASha,GAAIxG,EAAiBka,EAAcnZ,GAG1C,IAFA,IAAIyf,EAAUxgB,EACR2gB,EAASzG,EAAK5M,MAAM,KACjBzK,EAAI,EAAGA,EAAI8d,EAAO7d,OAAQD,GAAK,EAAG,CACzC,IAAM4d,EAAQE,EAAO9d,GACrB,IAAK6d,GAAwBF,EAASC,GACpC,OAEE5d,IAAM8d,EAAO7d,OAAS,EACxB0d,EAAUA,EAAQC,GAElBD,EAAQC,GAAS1f,C,CAGvB,CAEA,SAAS2f,GAAwB1gB,EAAiBygB,GAChD,MAAyB,iBAAXzgB,GAAkC,OAAXA,GAAmB3C,OAAOC,UAAUC,eAAeC,KAAKwC,EAAQygB,EACvG,CCvDO,SAASG,KACd,ItBgBM7f,EsBhBA8f,EtBiBkB,iBADlB9f,EAASmD,OAAyB4c,+BAAiC7V,GAjB7B,iCAkBTlK,OAAQ/B,EsBhBrC+hB,EtBmBD,WACL,IAAMhgB,EAASmD,OAAyB8c,+BAAiC/V,GArB3B,gCAsB9C,MAAwB,iBAAVlK,EAAqBA,OAAQ/B,CAC7C,CsBtBmBiiB,GAEjB,GAAIJ,GAAUE,EACZ,MAAO,CACLG,QAASL,EACTM,UAAWJ,EACXK,SAAUtV,KAGhB,CLJO,SAASuV,KAOT,IACClK,EAJN,OAHKmF,KAOCnF,EAAa,IAAIH,IAA8B,WAC3C,IAAWsK,EAAoB5iB,EACrC,GAAQ,WACNyY,EAAWR,OAAO4K,KACpB,IACA,KACD,UAED,OAAOnc,EAAiBlB,OAAQ,SAAkBod,EAAiB,CAAE3b,SAAS,EAAMC,SAAS,IAAQE,IACvG,IAfEwW,GAiBKnF,GAfAmF,EACT,CAkBO,SAASiF,KACd,IAAMC,EAAStd,OAAOud,eACtB,OAAID,EACK,CACLE,MAAOjE,OAAO+D,EAAOE,MAAQF,EAAOG,OACpCC,OAAQnE,OAAO+D,EAAOI,OAASJ,EAAOG,QAInC,CACLD,MAAOjE,OAAOvZ,OAAO2d,YAAc,GACnCD,OAAQnE,OAAOvZ,OAAO4d,aAAe,GAEzC,CCvCO,SAASC,KACd,GAAK5R,GAA6B,YASlC,OAPKoM,KACHA,GAAWgF,KACKF,KAAyB/K,WAAU,SAAC0L,GAClDzF,GAAWyF,CACb,IAAGvL,aAGE,CACL8F,SAAQ,GAEZ,CKwBA,IAAM0F,GAAqC,CAEzC,WACA,gBACA,qBACA,gBACA,cACA,qBACA,gBAGIC,GAAsCD,GAAmCxP,OAAO,CAEpF,YAKK,SAAS0P,GACdjP,EACAiL,EACAiE,EACAC,EACAC,EACAC,EACAC,EACAC,G,MAEMC,IAAiB,MACrB,MAAsBxC,GAAuB,QAE3ChN,EAAcqC,0BACdkN,GAEF,SAAuBvC,GAAuB,SAE5ChN,EAAcqC,0BACdkN,G,GAIEE,EAAoB/B,KACpBgC,EC/ED,W,MACCC,EAAkD,QAA/B,EAAA3e,OAAwB4e,eAAO,eAAE3P,IAAI,WAE9D,GAA+B,iBAApB0P,EACT,MAAO,CACLE,kBAAmBF,EAGzB,CDuEwBG,GAEtB7E,EAAU7H,UAAU,IAElB,SAAC,G,IA0FHhR,EA1FKwV,EAAS,YAAEmI,EAAW,cAAEC,EAAa,gBAAEC,EAAkB,qBAAEC,EAAe,kBACrEC,EAAchB,EAAaiB,SAASxI,GACpCyI,EAAajB,EAAYkB,QAAQ1I,GAIjC2I,EAAUrB,EAAesB,mBAAwC,SAArBT,EAAYphB,KAA6BiZ,OAAY9b,GACvG,GAAIykB,GAAWJ,GAAeE,EAAY,CACxC,IAAMI,EAAgBR,GAAsBX,IACtCoB,EAAWrB,EAAesB,aAAa/I,GAkCvCgJ,EAAiBxc,EAhCQ,CAC7B2Q,IAAK,CACHC,eAAgB,EAChB6L,MzBjFH3jB,KAAKM,MAAM+I,IAAYI,GAAYD,KAAsBF,YAAYC,QyBkFlE8Z,QAAS,CACPO,KAAMP,EAAQO,MAEhBC,oBAAqBzX,KAAsB,WAA6BxN,GAE1EklB,YAAa,CACXC,GAAIjR,EAAcgB,eAEpB9I,KAAMnB,IACNmJ,QAASiQ,EAAYjQ,SAAWF,EAAcE,QAC9CC,QAASgQ,EAAYhQ,SAAWH,EAAcG,QAC9CxT,OAAQ,UACR4jB,QAAS,CACPU,GAAIV,EAAQU,GACZtiB,KAAM8gB,EAAoB,aAAyBC,EAAgB,UAAsB,QAE3FwB,KAAM,CACJD,GAAId,EAAYc,GAChBxf,KAAM0e,EAAY1e,KAClBsJ,IAAKsV,EAAWtV,IAChBoW,SAAUd,EAAWc,UAEvBC,QAqDRhf,EArDyC2d,GAuD2D,IAA7F,CAAC,QAAD,wBAAoE5gB,QAAQiD,EAAMzD,OAvDhC+hB,EAAW,CAAEO,GAAIP,QAAa5kB,GAC/EulB,WAAY5B,EACZ6B,QAAS5B,EACTzlB,QAAS4kB,MAGwDkB,GACnEa,EAAe1lB,QAAUkJ,EAAQqc,EAAcvlB,QAASglB,GAElD,eAAgBU,EAAeL,UACjCK,EAAeL,QAAyCgB,WAAad,EAAce,WAGlFnhB,EAAcogB,EAAcgB,QAC7Bb,EAAec,IAAmCjB,EAAcgB,MAc5E,SACErf,EACA4P,EACAgO,EACAR,G,MAEA,GAAIxN,EAAY,CACd,IAAMvF,EF1JH,SACL3P,EACA6kB,EACAC,GAEA,IAAMC,EAAQ1d,EAAUrH,GAClB2P,EAASmV,EAASC,GAYxB,OAXAF,EAAqBjlB,SAAQ,SAACsa,GAC5B,IAAM8K,EAAgBnhB,GAAI7D,EAAQka,GAC5B+K,EAAWphB,GAAIkhB,EAAO7K,GACtBgL,EAAepjB,EAAQkjB,GACvBG,EAAUrjB,EAAQmjB,GACpBE,IAAYD,EACd1e,GAAIxG,EAAQka,EAAM+K,GACQ,WAAjBC,GAA0C,cAAZC,GAAuC,SAAZA,GAClE3e,GAAIxG,EAAQka,EAAM,CAAC,EAEvB,IACOvK,CACT,CEuImByV,CACb9f,EACe,SAAfA,EAAMzD,KAA6BogB,GAAqCC,IACxE,SAAC5c,GAAU,OAAA4P,EAAW5P,EAAO4d,EAAlB,IAEb,IAAe,IAAXvT,GAAmC,SAAfrK,EAAMzD,KAC5B,OAAO,GAEM,IAAX8N,GACFxS,EAAQF,KAAK,8C,CAKjB,QADsD,QAA7B,EAAAylB,EAAkBpd,EAAMzD,aAAK,eAAE0e,iBAE1D,CAjCY8E,CAAWvB,EAAgB5Q,EAAcgC,WAAYgO,EAAeR,KAClEnf,EAAcugB,EAAe1lB,iBACxB0lB,EAAe1lB,QAExB+f,EAAUxH,OAAO,GAAwCmN,G,CAG/D,GAEJ,CEnJO,IAeHwB,GAAwC,GAErC,SAASC,KACVpf,SAASqf,YACXC,KAGM,IAuCUC,EASDC,EAhDHC,GAuCIF,EAvCkCD,GAwC7CrgB,EAAiBlB,OAAQ,SAAiB,SAACoB,GAC3CA,EAAMugB,WAGXH,GACF,KA7C2E,KAC7DI,GA+CGH,EA/C4BI,GAgDtC3gB,EAAiBlB,OAAQ,QAAgB,SAACoB,GAC1CA,EAAMugB,WAGXF,GACF,KArDmE,KACnE,MAAO,CACLK,iBAAgB,GAChBC,6BAA4B,GAC5BngB,KAAM,WACJwf,GAAoB,GACpBM,IACAE,GACF,EAEJ,CAEO,SAASL,KACd,KAAIH,GAAkBxiB,OAlC+B,MAkCrD,CAGA,IAAMojB,EAA0BZ,GAAkBA,GAAkBxiB,OAAS,GACvE6G,EAAMO,SACoBlL,IAA5BknB,QAAyElnB,IAAhCknB,EAAwB3b,KAGrE+a,GAAkB1iB,KAAK,CACrB0H,MAAOX,G,CAEX,CAEO,SAASoc,KACd,GAAiC,IAA7BT,GAAkBxiB,OAAtB,CAGA,IAAMojB,EAA0BZ,GAAkBA,GAAkBxiB,OAAS,GACvE6G,EAAMO,SACwBlL,IAAhCknB,EAAwB3b,MAG5B2b,EAAwB3b,IAAMZ,E,CAChC,CAoBA,SAASqc,GAAiBlL,GACxB,IAAK,IAAIjY,EAAIyiB,GAAkBxiB,OAAS,EAAGD,GAAK,EAAGA,IAAK,CACtD,IAAMsjB,EAAmBb,GAAkBziB,GAC3C,QAA6B7D,IAAzBmnB,EAAiB5b,KAAqBuQ,EAAYqL,EAAiB5b,IACrE,MAEF,GACEuQ,EAAYqL,EAAiB7b,aACHtL,IAAzBmnB,EAAiB5b,KAAqBuQ,EAAYqL,EAAiB5b,KAEpE,OAAO,C,CAGX,OAAO,CACT,CAEA,SAAS0b,GAA6BG,EAA8Bpc,GAKlE,IAJA,IAAMqc,EAAexc,GAAYuc,EAAgBpc,GAC3Csc,EAAkD,GAElDC,EAAgBnmB,KAAKomB,IAAI,EAAGlB,GAAkBxiB,OAnGK,KAoGhDD,EAAIyiB,GAAkBxiB,OAAS,EAAGD,GAAK0jB,EAAe1jB,IAAK,CAClE,IAAMsjB,EAAmBb,GAAkBziB,GAC3C,QAA6B7D,IAAzBmnB,EAAiB5b,KAAqB6b,EAAiBD,EAAiB5b,IAG1E,MAEF,KAAI8b,EAAeF,EAAiB7b,OAApC,CAKA,IAAMwQ,EAAYsL,EAAiBD,EAAiB7b,MAAQ8b,EAAiBD,EAAiB7b,MACxFmc,EAAgBpc,GAAQ+b,EAAgBtL,GAGxC4L,EAAcrc,GAAQyQ,OADD9b,IAAzBmnB,EAAiB5b,KAAqB8b,EAAeF,EAAiB5b,IAAM8b,EAAeF,EAAiB5b,KAE9G+b,EAA0BK,QAAQ,CAChCrc,MAAOP,EAAiB0c,GACxBzc,SAAUD,EAAiB2c,I,EAG/B,OAAOJ,CACT,CC3FA,ICPIM,GDOJ,2BACU,KAAAC,UAA0E,CAAC,CAuErF,QAlDE,YAAAlQ,OAAA,SAAOpK,EAA+BqK,GACpC,IAAMkQ,EAAiB5oB,KAAK2oB,UAAUta,GAClCua,GACFA,EAAelnB,SAAQ,SAACsG,GAAa,OAAAA,EAAS0Q,EAAT,GAEzC,EAkCA,YAAAN,UAAA,SAAU/J,EAA+BrG,GAAzC,WAKE,OAJKhI,KAAK2oB,UAAUta,KAClBrO,KAAK2oB,UAAUta,GAAa,IAE9BrO,KAAK2oB,UAAUta,GAAY3J,KAAKsD,GACzB,CACLuQ,YAAa,WACX,EAAKoQ,UAAUta,GAAa,EAAKsa,UAAUta,GAAYyI,QAAO,SAAC0B,GAAU,OAAAxQ,IAAawQ,CAAb,GAC3E,EAEJ,EACF,EAxEA,GEnCaqQ,GAAyB,MACzBC,GAA2B,ICElCC,GAAeC,IAgBrB,cAIE,WAAoB/b,GAApB,WAAoB,KAAAA,cAHZ,KAAAuT,QAA+C,GAIrDxgB,KAAKipB,yBAA2BC,aAAY,WAAM,SAAKC,kBAAL,GAXX5oB,IAYzC,CAiFF,OA3EE,YAAA6J,IAAA,SAAIlK,EAAkB0c,GAAtB,WACQH,EAAsC,CAC1Cvc,QAAO,EACP0c,UAAS,EACTwM,QAASL,GACT1e,OAAQ,WACN,IAAMgf,EAAQ,EAAK7I,QAAQrc,QAAQsY,GAC/B4M,GAAS,GACX,EAAK7I,QAAQzV,OAAOse,EAAO,EAE/B,EACAC,MAAO,SAACF,GACN3M,EAAM2M,QAAUA,CAClB,GAGF,OADAppB,KAAKwgB,QAAQiI,QAAQhM,GACdA,CACT,EAMA,YAAA5X,KAAA,SAAK+X,QAAA,IAAAA,MAAA,IACH,IAAoB,UAAA5c,KAAKwgB,QAAL,eAAc,CAA7B,IAAM/D,EAAK,KACd,GAAIA,EAAMG,WAAaA,EAAW,CAChC,GAAIA,GAAaH,EAAM2M,QACrB,OAAO3M,EAAMvc,QAEf,K,EAGN,EAMA,YAAAqpB,YAAA,SAAYH,GACV,IAAMI,EAAcxpB,KAAKwgB,QAAQ,GAC7BgJ,GAAeA,EAAYJ,UAAYL,IACzCS,EAAYF,MAAMF,EAEtB,EAMA,YAAAK,QAAA,SAAQ7M,GACN,YADM,IAAAA,MAAA,IACC5c,KAAKwgB,QACT1J,QAAO,SAAC2F,GAAU,OAAAA,EAAMG,WAAaA,GAAaA,GAAaH,EAAM2M,OAAnD,IAClBjkB,KAAI,SAACsX,GAAU,OAAAA,EAAMvc,OAAN,GACpB,EAKA,YAAAwpB,MAAA,WACE1pB,KAAKwgB,QAAU,EACjB,EAKA,YAAA5Y,KAAA,WACE+hB,cAAc3pB,KAAKipB,yBACrB,EAEQ,YAAAE,iBAAR,WAEE,IADA,IAAMS,EAAmB5d,IAAgBhM,KAAKiN,YACvCjN,KAAKwgB,QAAQ5b,OAAS,GAAK5E,KAAKwgB,QAAQxgB,KAAKwgB,QAAQ5b,OAAS,GAAGwkB,QAAUQ,GAChF5pB,KAAKwgB,QAAQtM,KAEjB,EACF,EAvFA,GClBO,SAAS2V,GACd/nB,EACAgoB,EACAC,GAIA,IAAMC,EAAWloB,EAAOgoB,GAEpBG,EAAkBF,EAAuBC,GAEvCE,EAAyB,WAC7B,GAA+B,mBAApBD,EAIX,OAAOA,EAAgB9pB,MAAMH,KAAMC,UACrC,EAGA,OAFA6B,EAAOgoB,GAAUI,EAEV,CACLtiB,KAAM,WACA9F,EAAOgoB,KAAYI,EACrBpoB,EAAOgoB,GAAUE,EAEjBC,EAAkBD,CAEtB,EAEJ,CAEO,SAASG,GACdroB,EACAgoB,EACA,G,IACEM,EAAM,SACNC,EAAK,QAMP,OAAOR,GACL/nB,EACAgoB,GACA,SAACE,GACC,kBACE,IACIvY,EADElS,EAAOU,UAiBb,OAdImqB,GACFrqB,EAAcqqB,EAAQpqB,KAA2CT,GAG3C,mBAAbyqB,IAETvY,EAASuY,EAAS7pB,MAAMH,KAAMT,IAG5B8qB,GACFtqB,EAAcsqB,EAAOrqB,KAA2CT,GAI3DkS,CACT,CAnBA,GAqBN,CHvCA,IIAI6Y,GJAEC,GAAc,IAAIniB,QAEjB,SAASoiB,KAOhB,IACQvR,EAJN,OAHKyP,KAOCzP,EAAa,IAAIH,IAAuB,WACpC,IAAM2R,EAA2BN,GAAgCO,eAAetrB,UAAW,OAAQ,CACzGgrB,OAAQO,KACR,KAEYC,EAA0BT,GAAgCO,eAAetrB,UAAW,OAAQ,CACxGgrB,OAAM,WACJS,GAAQvrB,KAAKU,KAAMiZ,EACrB,IACA,KAEY6R,EAA2BX,GAAgCO,eAAetrB,UAAW,QAAS,CAC1GgrB,OAAQW,KACR,KAEF,OAAO,WACLN,IACAG,IACAE,GACF,CACF,IA1BEpC,GA2BKzP,GAzBAyP,EACT,CA2BA,SAASiC,GAA8Bb,EAAgB/Z,GACrDwa,GAAYjiB,IAAItI,KAAM,CACpBgrB,MAAO,OACPlB,OAAM,EACN/Z,IAAKqC,GAAajD,OAAOY,KAE7B,CAEA,SAAS8a,GAA8B5R,GAAvC,WACQ/Y,EAAUqqB,GAAY5kB,IAAI3F,MAChC,GAAKE,EAAL,CAIA,IAAM+qB,EAAe/qB,EACrB+qB,EAAaD,MAAQ,QACrBC,EAAarO,UAAY5Q,IACzBif,EAAa/Z,YAAcjF,IAC3Bgf,EAAaC,WAAY,EACzBD,EAAaE,IAAMnrB,KAEnB,IAAIorB,GAAkB,EAERC,EAAwClB,GAAgCnqB,KAAM,qBAAsB,CAChHoqB,OAAM,WACApqB,KAAKkI,aAAewiB,eAAeY,MAKrCC,GAEJ,IACA,KAEIA,EAAQ,GAAQ,WAGpB,GAFA,EAAK1jB,oBAAoB,UAAW0jB,GACpCF,KACID,EAAJ,CAGAA,GAAkB,EAElB,IAAMI,EAAkBtrB,EACxBsrB,EAAgBR,MAAQ,WACxBQ,EAAgB1f,SAAWK,GAAQ8e,EAAa/Z,YAAY/F,UAAWY,KACvEyf,EAAgBhR,OAAS,EAAKA,OAC9BvB,EAAWR,OAAO5W,EAAa2pB,G,CACjC,IACAxrB,KAAKkH,iBAAiB,UAAWqkB,GACjCtS,EAAWR,OAAOwS,E,CACpB,CAEA,SAASF,KACP,IAAM7qB,EAAUqqB,GAAY5kB,IAAI3F,MAC5BE,IACFA,EAAQgrB,WAAY,EAExB,CI1FO,SAASO,KAOhB,IACQxS,EAJN,OAHKqR,KAOCrR,EAAa,IAAIH,IAAyB,WAC9C,GAAK9S,OAAO0lB,MAuBZ,OAnBiB7B,GACf7jB,OACA,SACA,SAAC2lB,GACC,gBAAUC,EAAOC,GACf,IAAIC,EAEE5rB,EAAUH,EAAciX,GAAY,KAAM,CAACiC,EAAY2S,EAAOC,IAQpE,OAPI3rB,GACF4rB,EAAkBH,EAAcrsB,KAAKU,KAAME,EAAQ0rB,MAAO1rB,EAAQ2rB,MAClE9rB,EAAcgsB,GAAW,KAAM,CAAC9S,EAAY6S,EAAiB5rB,KAE7D4rB,EAAkBH,EAAcrsB,KAAKU,KAAM4rB,EAAOC,GAG7CC,CACT,CAZA,IAaH,IAGH,IA/BExB,GAiCKrR,GA/BAqR,EACT,CAiCA,SAAStT,GAAWiC,EAAsC2S,EAAoBC,GAC5E,IAAM/B,EAAU+B,GAAQA,EAAK/B,QAA6B,iBAAV8B,GAAsBA,EAAM9B,QAAW,MACjF/Z,EAAMqC,GAA+B,iBAAVwZ,GAAsBA,EAAM7b,KAAS6b,GAGhE1rB,EAA6B,CACjC8qB,MAAO,QACPa,KAAI,EACJD,MAAK,EACL9B,OAAM,EACN5Y,YAPkBjF,IAQlB8D,IAAG,GAKL,OAFAkJ,EAAWR,OAAOvY,GAEXA,CACT,CAEA,SAAS6rB,GACP9S,EACA6S,EACAb,GAEA,IAAMe,EAAc,SAACC,GACnB,IAAM/rB,EAAU+qB,EAChB/qB,EAAQ8qB,MAAQ,WAChB9qB,EAAQ4L,SAAWK,GAAQjM,EAAQgR,YAAY/F,UAAWY,KAEtD,UAAWkgB,GAAYA,aAAoB5a,OAC7CnR,EAAQsa,OAAS,EACjBta,EAAQgrB,UAAYe,aAAoBC,cAAgBD,EAASE,OAASD,aAAaE,UACvFlsB,EAAQlB,MAAQitB,EAEhBhT,EAAWR,OAAOvY,IACT,WAAY+rB,IACrB/rB,EAAQ+rB,SAAWA,EACnB/rB,EAAQmsB,aAAeJ,EAAStoB,KAChCzD,EAAQsa,OAASyR,EAASzR,OAC1Bta,EAAQgrB,WAAY,EAEpBjS,EAAWR,OAAOvY,GAEtB,EACA4rB,EAAgBQ,KAAK,EAAQN,GAAc,EAAQA,GACrD,CC/EO,SAASO,GAAqBrsB,GACZ,IAAnBA,EAAQsa,QAAiBta,EAAQgrB,YACnChrB,EAAQmf,aAAUve,EAClBZ,EAAQssB,YAAS1rB,EACjBZ,EAAQusB,kBAAe3rB,EAE3B,CAwCA,SAAS4rB,GACP1X,EACA9U,EACAgkB,EACAyI,GA4BF,IAA4BtN,EAA0BmN,EAAyBC,OAXtD3rB,IAAhB8rB,MALT,SAAsB5X,EAAiC6X,GACrD,OAAOvjB,EAAU0L,EAAc8X,sBAAuBva,GAAUsa,GAClE,CAZgCE,CAAa/X,EAAe9U,EAAQ6P,MAAUmU,EAAesB,uBAI3FtlB,EAAQmf,QAAU,IAAI2N,GACtB9sB,EAAQssB,OAAS,IAAIQ,GACrB9sB,EAAQusB,cAAgBznB,EAASgQ,EAAciY,oBAAsB3qB,EAAY0S,EAAciY,mBAC/FN,GAmB0BtN,EAnBAnf,EAAQmf,QAmBkBmN,EAnBTtsB,EAAQssB,OAmB0BC,EAnBlBvsB,EAAQusB,aAoB5D,CACL,mBAAoB,MACpB,sBAAuBD,EAAOU,kBAC9B,8BAA+BT,EAAe,IAAM,IACpD,qBAAsBpN,EAAQ6N,qBAvBlC,CAUA,SAASN,KACP,OAAO5mB,OAAOmnB,QAAWnnB,OAAeonB,QAC1C,CAgBA,kBAGE,aAFQ,KAAAtiB,OAAqB,IAAIuiB,WAAW,GAG1CT,KAAYU,gBAAgBttB,KAAK8K,QACjC9K,KAAK8K,OAAO,GAAsB,IAAjB9K,KAAK8K,OAAO,EAC/B,CAgCF,OA9BE,YAAA1I,SAAA,SAASmrB,GACP,IAAIC,EAAOxtB,KAAKytB,UAAU,GACtBC,EAAM1tB,KAAKytB,UAAU,GACrB9jB,EAAM,GAEV,EAAG,CACD,IAAMgkB,EAAOH,EAAOD,EAAS,WAAaG,EAC1CF,EAAOtrB,KAAK0rB,MAAMJ,EAAOD,GACzBG,EAAMxrB,KAAK0rB,MAAMD,EAAMJ,GACvB5jB,GAAOgkB,EAAMJ,GAAOnrB,SAASmrB,GAAS5jB,C,OAC/B6jB,GAAQE,GAEjB,OAAO/jB,CACT,EAKA,YAAAujB,gBAAA,WACE,OAAOltB,KAAKoC,SAAS,GACvB,EAEQ,YAAAqrB,UAAR,SAAkBI,GAChB,OACwB,SAAtB7tB,KAAK8K,OAAO+iB,IACX7tB,KAAK8K,OAAO+iB,EAAS,IAAM,KAC3B7tB,KAAK8K,OAAO+iB,EAAS,IAAM,GAC5B7tB,KAAK8K,OAAO+iB,EAAS,EAEzB,EACF,EAtCA,GCzEIC,GAAmB,EAEhB,SAASC,GACd9N,EACAjL,EACAkP,GAEA,IAAM8J,EDdD,SAAqBhZ,EAAiCkP,GAC3D,MAAO,CACLqI,qBAAoB,GACpB0B,WAAY,SAAC/tB,GACX,OAAAwsB,GAA8B1X,EAAe9U,EAASgkB,GAAgB,SAACgK,G,MACrE,GAAIhuB,EAAQ0rB,iBAAiBuC,WAAwB,QAAZ,EAAAjuB,EAAQ2rB,YAAI,eAAEuC,SACrDluB,EAAQ0rB,MAAQ,IAAIuC,QAAQjuB,EAAQ0rB,OACpCzsB,OAAO+F,KAAKgpB,GAAgBxsB,SAAQ,SAACE,GACjC1B,EAAQ0rB,MAAkBwC,QAAQC,OAAOzsB,EAAKssB,EAAetsB,GACjE,QACK,CACL1B,EAAQ2rB,KAAOhqB,EAAa3B,EAAQ2rB,MACpC,IAAM,EAAsB,GACxB3rB,EAAQ2rB,KAAKuC,mBAAmBE,QAClCpuB,EAAQ2rB,KAAKuC,QAAQ1sB,SAAQ,SAACmB,EAAOjB,GACnC,EAAQ8C,KAAK,CAAC9C,EAAKiB,GACrB,IACSQ,MAAM8E,QAAQjI,EAAQ2rB,KAAKuC,SACpCluB,EAAQ2rB,KAAKuC,QAAQ1sB,SAAQ,SAAC6sB,GAC5B,EAAQ7pB,KAAK6pB,EACf,IACSruB,EAAQ2rB,KAAKuC,SACtBjvB,OAAO+F,KAAKhF,EAAQ2rB,KAAKuC,SAAS1sB,SAAQ,SAACE,GACzC,EAAQ8C,KAAK,CAAC9C,EAAM1B,EAAQ2rB,KAAMuC,QAAmCxsB,IACvE,IAEF1B,EAAQ2rB,KAAKuC,QAAU,EAAQ7Z,OAAOnP,EAAc8oB,G,CAExD,GAxBA,EAyBFM,SAAU,SAACtuB,EAASirB,GAClB,OAAAuB,GAA8B1X,EAAe9U,EAASgkB,GAAgB,SAACgK,GACrE/uB,OAAO+F,KAAKgpB,GAAgBxsB,SAAQ,SAAC+E,GACnC0kB,EAAIsD,iBAAiBhoB,EAAMynB,EAAeznB,GAC5C,GACF,GAJA,EAMN,CCtBiBioB,CAAY1Z,EAAekP,IAKrC,SAAkBjE,EAAsBjL,EAAiCgZ,GAC9E,IAAM9U,EAAesR,KAAoBpS,WAAU,SAACuW,GAClD,IAAMzuB,EAAUyuB,EAChB,GAAKxQ,GAAoBnJ,EAAe9U,EAAQ6P,KAIhD,OAAQ7P,EAAQ8qB,OACd,IAAK,QACHgD,EAAOQ,SAAStuB,EAASA,EAAQirB,KACjCjrB,EAAQ0uB,aAAeC,KAEvB5O,EAAUxH,OAAO,EAAoC,CACnDmW,aAAc1uB,EAAQ0uB,aACtB7e,IAAK7P,EAAQ6P,MAEf,MACF,IAAK,WACHie,EAAOzB,qBAAqBrsB,GAC5B+f,EAAUxH,OAAO,EAAsC,CACrD3M,SAAU5L,EAAQ4L,SAClBge,OAAQ5pB,EAAQ4pB,OAChB8E,aAAc1uB,EAAQ0uB,aACtBpC,OAAQtsB,EAAQssB,OAChBtb,YAAahR,EAAQgR,YACrBsJ,OAAQta,EAAQsa,OAChB6E,QAASnf,EAAQmf,QACjBoN,aAAcvsB,EAAQusB,aACtB9oB,KAAM,MACNoM,IAAK7P,EAAQ6P,IACbob,IAAKjrB,EAAQirB,MAIrB,GAGF,CAzCE2D,CAAS7O,EAAWjL,EAAegZ,GA2C9B,SAAoB/N,EAAsBjL,EAAiCgZ,GAChF,IAAM9U,EAAeuS,KAAsBrT,WAAU,SAACuW,GACpD,IAAMzuB,EAAUyuB,EAChB,GAAKxQ,GAAoBnJ,EAAe9U,EAAQ6P,KAIhD,OAAQ7P,EAAQ8qB,OACd,IAAK,QACHgD,EAAOC,WAAW/tB,GAClBA,EAAQ0uB,aAAeC,KAEvB5O,EAAUxH,OAAO,EAAoC,CACnDmW,aAAc1uB,EAAQ0uB,aACtB7e,IAAK7P,EAAQ6P,MAEf,MACF,IAAK,WACHie,EAAOzB,qBAAqBrsB,GAE5B+f,EAAUxH,OAAO,EAAsC,CACrD3M,SAAU5L,EAAQ4L,SAClBge,OAAQ5pB,EAAQ4pB,OAChB8E,aAAc1uB,EAAQ0uB,aACtBvC,aAAcnsB,EAAQmsB,aACtBG,OAAQtsB,EAAQssB,OAChBtb,YAAahR,EAAQgR,YACrBsJ,OAAQta,EAAQsa,OAChB6E,QAASnf,EAAQmf,QACjBoN,aAAcvsB,EAAQusB,aACtB9oB,KAAM,QACNoM,IAAK7P,EAAQ6P,IACbkc,SAAU/rB,EAAQ+rB,SAClBJ,KAAM3rB,EAAQ2rB,KACdD,MAAO1rB,EAAQ0rB,QAIvB,GAEF,CAlFEmD,CAAW9O,EAAWjL,EAAegZ,EACvC,CAmFA,SAASa,KACP,IAAMpd,EAASqc,GAEf,OADAA,IAAoB,EACbrc,CACT,CCxIO,SAASud,GAAiB/O,EAAsBjY,QAAA,IAAAA,MAAA,GACrD,IAAMinB,EAA2B,CAC/BC,WAAY,EACZC,cAAe,EACfC,cAAe,EACfC,YAAa,EACbC,iBAAkB,GAGdpW,EAAe+G,EAAU7H,UAAU,IAAwC,SAAChR,GAChF,OAAQA,EAAMzD,MACZ,IAAK,QACHsrB,EAAYC,YAAc,EAC1BlnB,EAASinB,GACT,MACF,IAAK,SACHA,EAAYI,aAAe,EACvBjoB,EAAMgf,OAAOmJ,cACfN,EAAYK,kBAAoBloB,EAAMgf,OAAOmJ,YAAY5rB,KAAKiB,QAEhEoD,EAASinB,GACT,MACF,IAAK,YACHA,EAAYE,eAAiB,EAC7BnnB,EAASinB,GACT,MACF,IAAK,WACHA,EAAYG,eAAiB,EAC7BpnB,EAASinB,GAGf,IAEA,MAAO,CACLrnB,KAAM,WACJsR,EAAaX,aACf,EACA0W,YAAW,EAEf,CCLO,SAASO,GACdvP,EACAwP,EACAza,EACA0a,EACAC,GAEA,IAAMC,EAqDD,SACL3P,EACAwP,EACAza,GAEA,IAAMiE,EAAa,IAAIH,IAA8B,WACnD,IACI+W,EADE9W,EAAgC,GAElC+W,EAAuB,EAE3B/W,EAAcrU,KACZ+qB,EAAsBrX,UAAU2X,GAChC9P,EAAU7H,UAAU,GAAkD,SAACoI,GACjEA,EAAQhX,MAAK,SAACiT,GAAU,MAAoB,aAApBA,EAAMoD,YAA6BmQ,GAAchb,EAAeyH,EAAMhW,KAAtE,KAC1BspB,GAEJ,IACA9P,EAAU7H,UAAU,GAAoC,SAAC6X,GACnDD,GAAchb,EAAeib,EAAWlgB,YAGlBjP,IAAtB+uB,IACFA,EAAoBI,EAAWrB,cAEjCkB,GAAwB,EACxBC,IACF,IACA9P,EAAU7H,UAAU,GAAsC,SAAC8X,GAEvDF,GAAchb,EAAekb,EAAQngB,WACfjP,IAAtB+uB,GAEAK,EAAQtB,aAAeiB,IAIzBC,GAAwB,EACxBC,IACF,KAGM,IAmBa/nB,EAnBPmoB,GAmBOnoB,EAnBoC+nB,EAoBpD5F,GAAgCnkB,OAAQ,OAAQ,CAAEokB,OAAQpiB,KApBa,KAE5E,OAAO,WACLmoB,IACApX,EAAcrX,SAAQ,SAAC0uB,GAAM,OAAAA,EAAE7X,aAAF,GAC/B,EAEA,SAASwX,IACP9W,EAAWR,OAAO,CAAE4X,OAAQP,EAAuB,GACrD,CACF,IAEA,OAAO7W,CACT,CA3GiCqX,CAA6BrQ,EAAWwP,EAAuBza,GAC9F,OAGK,SACL4a,EACAF,EACAC,GAEA,IAAIY,EACAC,GAAe,EAEbC,EAAsBpvB,WAC1B,GAAQ,WAAM,OAAAqvB,EAAS,CAAEC,aAAa,GAAxB,IA5D4B,KA+DtCC,EACJjB,GACAtuB,WACE,GAAQ,WAAM,OAAAqvB,EAAS,CAAEC,aAAa,EAAMtkB,IAAKN,KAAnC,IACd4jB,GAGEkB,EAA2BjB,EAAuBxX,WAAU,SAAC,G,IAAEiY,EAAM,SACzE9uB,aAAakvB,GACblvB,aAAagvB,GACb,IAAMO,EAAiB/kB,IAClBskB,IACHE,EAA2BlvB,WACzB,GAAQ,WAAM,OAAAqvB,EAAS,CAAEC,aAAa,EAAMtkB,IAAKykB,GAAnC,IA1EiB,KA8ErC,IAEMlpB,EAAO,WACX4oB,GAAe,EACfjvB,aAAakvB,GACblvB,aAAagvB,GACbhvB,aAAaqvB,GACbC,EAAyBtY,aAC3B,EAEA,SAASmY,EAAStpB,GACZopB,IAGJ5oB,IACA8nB,EAAwBtoB,GAC1B,CACA,MAAO,CAAEQ,KAAI,EACf,CAlDSmpB,CAAsBnB,EAAwBF,EAAyBC,EAChF,CA2GA,SAASK,GAAchb,EAAiC6X,GACtD,OAAOvjB,EAAU0L,EAAcgc,qBAAsBnE,EACvD,CC7JO,IAAMoE,GAA8B3wB,EASpC,SAAS4wB,GAAiBC,EAAmBC,GAClD,IAEIC,EAFEC,EAA0B,GAC5B9W,EAAS,EAIb,SAAS+W,EAAYC,GACnBA,EAAMC,eAAerZ,UAAUsZ,GAC/BJ,EAAe5sB,KAAK8sB,GACpBjwB,aAAa8vB,GACbA,EAAkChwB,WAAW,EAAQswB,GAnBdrxB,IAoBzC,CAEA,SAASoxB,IACQ,IAAXlX,GAAsD8W,EAAeM,OAAM,SAACJ,GAAU,OAAAA,EAAMK,WAAN,MACxFrX,EAAS,EACT4W,EAAWE,GAEf,CAEA,SAASK,IACPpwB,aAAa8vB,GACE,IAAX7W,IACFA,EAAS,EACTkX,IAEJ,CAEA,OAxBAH,EAAYJ,GAwBL,CACLW,UAAW,SAACN,GACV,OAAe,IAAXhX,IAKF8W,EAAe1sB,OAAS,IAmBNmtB,EAlBAT,EAAeA,EAAe1sB,OAAS,GAAGwC,MAkBvB4qB,EAlB8BR,EAAMpqB,QAoB7E2qB,EAAMvwB,SAAWwwB,EAAOxwB,SAMA2E,EALL4rB,EAKyBvZ,EALlBwZ,EAMrB9vB,KAAK+vB,KAAK/vB,KAAKgwB,IAAI/rB,EAAOgsB,QAAU3Z,EAAM2Z,QAAS,GAAKjwB,KAAKgwB,IAAI/rB,EAAOisB,QAAU5Z,EAAM4Z,QAAS,KAvE/D,MAkEvCL,EAAM5mB,UAAY6mB,EAAO7mB,WAAa8lB,MApBlCU,KACO,IAGTJ,EAAYC,IACL,IAWb,IAA0BO,EAAmBC,EAQjB7rB,EAAoBqS,CAlB5C,EACA5Q,KAAM,WACJ+pB,GACF,EAEJ,CC5DO,IAAMU,GAA6C,sBAEnD,SAASC,GAAyBpsB,EAAkBqsB,GAOzD,OACEC,GAAyCtsB,EAASmsB,KACjDE,GAA6BC,GAAyCtsB,EAASqsB,IAChFE,GAAsCvsB,EAASqsB,EAA2BG,KAC1ED,GAAsCvsB,EAASqsB,EAA2BI,KAC1E,EAEJ,CAEA,SAASH,GAAyCI,EAAwBC,GACxE,IAAIC,EAKJ,GA4NF,gBACuChyB,IAAjCiyB,KACFA,GAA+B,YAAaC,YAAY5zB,WAE1D,OAAO2zB,EACT,CAjOME,GACFH,EAAuBF,EAAcM,QAAQ,WAAIL,EAAqB,WAGtE,IADA,IAAI3sB,EAA0B0sB,EACvB1sB,GAAS,CACd,GAAIA,EAAQitB,aAAaN,GAAwB,CAC/CC,EAAuB5sB,EACvB,K,CAEFA,EAAUA,EAAQktB,a,CAItB,GAAKN,EAIL,OAAOO,GAASC,GADHR,EAAqBS,aAAaV,GACNW,QAC3C,CAOA,IAoLIC,GAcAV,GAlMEL,GAAqC,CAEzC,SAACxsB,EAASqsB,GAGR,GAgLJ,gBACsCzxB,IAAhC2yB,KACFA,GAA8B,WAAYC,iBAAiBt0B,WAE7D,OAAOq0B,EACT,CArLQE,IACF,GAAI,WAAYztB,GAAWA,EAAQ0tB,QAAU1tB,EAAQ0tB,OAAOhvB,OAAS,EACnE,OAAOivB,GAAkB3tB,EAAQ0tB,OAAO,GAAIrB,QAEzC,GAAIrsB,EAAQ+f,GAAI,CACrB,IAAM6N,EACJ5tB,EAAQ6tB,eACRlvB,EAAKqB,EAAQ6tB,cAAcC,iBAAiB,UAAU,SAACF,GAAU,OAAAA,EAAMG,UAAY/tB,EAAQ+f,EAA1B,IACnE,OAAO6N,GAASD,GAAkBC,EAAOvB,E,CAE7C,EAEA,SAACrsB,GACC,GAAyB,UAArBA,EAAQsZ,SAAsB,CAChC,IAAMoM,EAAQ1lB,EACRvC,EAAOioB,EAAM2H,aAAa,QAChC,GAAa,WAAT5vB,GAA8B,WAATA,GAA8B,UAATA,EAC5C,OAAOioB,EAAM/oB,K,CAGnB,EAEA,SAACqD,EAASqsB,GACR,GAAyB,WAArBrsB,EAAQsZ,UAA8C,UAArBtZ,EAAQsZ,UAAyD,WAAjCtZ,EAAQqtB,aAAa,QACxF,OAAOM,GAAkB3tB,EAASqsB,EAEtC,EACA,SAACrsB,GAAY,OAAAA,EAAQqtB,aAAa,aAArB,EAEb,SAACrtB,EAASqsB,GACR,IAAM2B,EAAsBhuB,EAAQqtB,aAAa,mBACjD,GAAIW,EACF,OAAOA,EACJ9kB,MAAM,OACNjK,KAAI,SAAC8gB,GAAO,OAoErB,SAAwBkO,EAAqBlO,GAG3C,OAAOkO,EAAWJ,cAAgBI,EAAWJ,cAAcK,eAAenO,GAAM,IAClF,CAxEqBmO,CAAeluB,EAAS+f,EAAxB,IACZnP,QAAO,SAACgd,GAAgC,OAAAjmB,QAAQimB,EAAR,IACxC3uB,KAAI,SAACe,GAAY,OAAA2tB,GAAkB3tB,EAASqsB,EAA3B,IACjBtpB,KAAK,IAEZ,EACA,SAAC/C,GAAY,OAAAA,EAAQqtB,aAAa,MAArB,EACb,SAACrtB,GAAY,OAAAA,EAAQqtB,aAAa,OAArB,EACb,SAACrtB,GAAY,OAAAA,EAAQqtB,aAAa,QAArB,EACb,SAACrtB,GAAY,OAAAA,EAAQqtB,aAAa,cAArB,EAEb,SAACrtB,EAASqsB,GACR,GAAI,YAAarsB,GAAWA,EAAQxF,QAAQkE,OAAS,EACnD,OAAOivB,GAAkB3tB,EAAQxF,QAAQ,GAAI6xB,EAEjD,GAGII,GAAqC,CACzC,SAACzsB,EAASqsB,GAA8B,OAAAsB,GAAkB3tB,EAASqsB,EAA3B,GAQ1C,SAASE,GACPG,EACAL,EACA8B,GAIA,IAFA,IAAInuB,EAA0B0sB,EAC1B0B,EAAmB,EAErBA,GAT4B,IAU5BpuB,GACqB,SAArBA,EAAQsZ,UACa,SAArBtZ,EAAQsZ,UACa,SAArBtZ,EAAQsZ,UACR,CACA,IAAuB,UAAA6U,EAAA,eAAY,CAA9B,IACG,GAAOE,EADI,MACKruB,EAASqsB,GAC/B,GAAoB,iBAAT,EAAmB,CAC5B,IAAMiC,EAAc,EAAKhB,OACzB,GAAIgB,EACF,OAAOnB,GAASC,GAAoBkB,G,EAM1C,GAAyB,SAArBtuB,EAAQsZ,SACV,MAEFtZ,EAAUA,EAAQktB,cAClBkB,GAAoB,C,CAExB,CAEA,SAAShB,GAAoBlD,GAC3B,OAAOA,EAAE/tB,QAAQ,OAAQ,IAC3B,CAEA,SAASgxB,GAASjD,GAChB,OAAOA,EAAExrB,OAAS,IAAM,UAAGiC,EAAaupB,EAAG,KAAI,UAAWA,CAC5D,CAQA,SAASyD,GAAkB3tB,EAAgCqsB,GACzD,IAAKrsB,EAAwBuuB,kBAA7B,CAIA,GAAI,cAAevuB,EAAS,CAC1B,IAAI,EAAOA,EAAQwuB,UAEbC,EAAyB,SAACC,GAE9B,IADA,IAAMrrB,EAAOrD,EAAQ8tB,iBAAwCY,GACpDvL,EAAQ,EAAGA,EAAQ9f,EAAK3E,OAAQykB,GAAS,EAAG,CACnD,IAAM,EAAU9f,EAAK8f,GACrB,GAAI,cAAe,EAAS,CAC1B,IAAMwL,EAAgB,EAAQH,UAC1BG,GAAiBA,EAAcrB,OAAO5uB,OAAS,IACjD,EAAO,EAAKvC,QAAQwyB,EAAe,I,EAI3C,EAeA,OCzMKhnB,QAAS5F,SAAiB6sB,eD+L7BH,EAAuB,iBAIzBA,EAAuB,WAAItC,GAA0C,MAEjEE,GACFoC,EAAuB,WAAIpC,EAAyB,MAG/C,C,CAGT,OAAOrsB,EAAQ6uB,W,CACjB,CEtMO,IA4HHC,GAoFAC,GAhNSC,GAAoB,CAC/B7C,GAEA,cACA,YACA,UACA,UACA,eACA,aACA,eAEA,iBACA,eACA,oBAGK,SAAS8C,GAAwBjvB,EAAkBkvB,GACxD,IAAIC,EA4GN,WACOL,KACHA,GAAgCE,GAAkB/vB,KAChD,SAACmwB,GAAc,gBAACpvB,GAAqB,OAAAqvB,GAAqBD,EAAWpvB,EAAhC,CAAtB,KAGnB,OAAO8uB,EACT,CAnH2BQ,GACrBJ,IACFC,EAAqB,CAAC,SAACnvB,GAAqB,OAAAqvB,GAAqBH,EAAqBlvB,EAA1C,GAAoDqO,OAC9F8gB,IAGJ,IAAMI,EAAmCJ,EAAmB9gB,OAAOmhB,IAC7DC,EAAwCN,EAAmB9gB,OAAO,CAACqhB,GAAkBC,KAC3F,MAAO,CACLC,SAAUC,GAAuB7vB,EAASuvB,EAAkCE,GAC5EK,kBAAmBD,GACjB7vB,EACAuvB,EACAE,EACA,CAAEM,sBAAsB,IAE1BC,8BAA+BH,GAC7B7vB,EACAuvB,EAAiClhB,OAAO,CAACqhB,GAAkBC,KAC3DF,GAEFQ,sBAAuBJ,GACrB7vB,EACAuvB,EAAiClhB,OAAO,CAACqhB,GAAkBC,KAC3DF,EACA,CAAEM,sBAAsB,IAG9B,CAIA,SAASG,GAAiBvzB,GASxB,MAAO,QAAQ4G,KAAK5G,EACtB,CAEA,SAASkzB,GACPnD,EACA6C,EACAE,EACA,GAKA,I,IALE,QAAF,MAAmC,CAAC,EAAC,GAAnCM,4BAAoB,IAAG,GAAK,EAE1BI,EAAwB,GACxBnwB,EAA0B0sB,EAEvB1sB,GAAgC,SAArBA,EAAQsZ,UAAqB,CAC7C,IAAM8W,EAAyBC,GAC7BrwB,EACAuvB,EACAe,GACAP,EAAuBI,OAAwBv1B,GAEjD,GAAIw1B,EACF,OAAOG,GAAgBH,EAAwBD,GASjDA,EAAwBI,GANYF,GAClCrwB,EACAyvB,EACAe,GACAT,EAAuBI,OAAwBv1B,IAGhB61B,GAAoBzwB,IAAY2vB,GAAmB3vB,GAClFmwB,GAGFnwB,EAAUA,EAAQktB,a,CAGpB,OAAOiD,CACT,CAEA,SAASX,GAAcxvB,GACrB,GAAIA,EAAQ+f,KAAOmQ,GAAiBlwB,EAAQ+f,IAC1C,MAAO,WAAIvc,EAAUxD,EAAQ+f,IAEjC,CAEA,SAAS2P,GAAiB1vB,GACxB,GAAwB,SAApBA,EAAQ0wB,SAGR1wB,EAAQ2wB,UAAUjyB,OAAS,EAC7B,IAAK,IAAID,EAAI,EAAGA,EAAIuB,EAAQ2wB,UAAUjyB,OAAQD,GAAK,EAAG,CACpD,IAAMmyB,EAAY5wB,EAAQ2wB,UAAUlyB,GACpC,IAAIyxB,GAAiBU,GAIrB,MAAO,UAAG5wB,EAAQ0wB,QAAO,YAAIltB,EAAUotB,G,CAG7C,CAEA,SAASjB,GAAmB3vB,GAC1B,OAAOA,EAAQ0wB,OACjB,CAYA,SAASrB,GAAqBwB,EAAuB7wB,GACnD,GAAIA,EAAQitB,aAAa4D,GACvB,MAAO,UAAG7wB,EAAQ0wB,QAAO,YAAIG,EAAa,aAAKrtB,EAAUxD,EAAQqtB,aAAawD,IAAgB,KAElG,CAEA,SAASJ,GAAoBzwB,GAM3B,IALA,IAGI8wB,EAFAC,EADW/wB,EAAQktB,cACF8D,kBACjBC,EAAe,EAGZF,KACDA,EAAQL,UAAY1wB,EAAQ0wB,UAC9BO,GAAgB,EACZF,IAAY/wB,IACd8wB,EAAeG,QAGIr2B,IAAjBk2B,GAA8BG,EAAe,KAMnDF,EAAUA,EAAQG,mBAGpB,OAAOD,EAAe,EAAI,UAAGjxB,EAAQ0wB,QAAO,wBAAgBI,EAAa,UAAMl2B,CACjF,CAEA,SAASy1B,GACPrwB,EACAmxB,EACAvyB,EACAwyB,GAEA,IAA6B,UAAAD,EAAA,eAAiB,CAAzC,IACGE,GAAkBC,EADD,MACgBtxB,GACjCuxB,EAAeF,GAAmBd,GAAgBc,EAAiBD,GACzE,GAAIG,GAAgB3yB,EAAUoB,EAASuxB,GACrC,OAAOF,C,CAGb,CAKA,SAASf,GAAyBtwB,EAAkB4vB,GAClD,OAAmE,IAA5D5vB,EAAQ6tB,cAAcC,iBAAiB8B,GAAUlxB,MAC1D,CAYA,SAAS8xB,GAA8BxwB,EAAkB4vB,GACvD,OAEgB,IADd5vB,EAAQktB,cAAeY,iBAUpB,WACL,QAAkClzB,IAA9Bm0B,GACF,IACEhtB,SAASuW,cAAc,UACvByW,IAA4B,C,CAC5B,SACAA,IAA4B,C,CAGhC,OAAOA,EACT,CApB4CyC,GAAyBjB,GAAgB,SAAUX,GAAYA,GACpGlxB,MAEP,CAEA,SAAS6xB,GAAgBkB,EAAgBC,GACvC,OAAOA,EAAQ,UAAGD,EAAM,YAAIC,GAAUD,CACxC,CCnIA,SAASE,KACP,IAAMC,EAAY9xB,OAAO+xB,eACzB,OAAQD,GAAaA,EAAUE,WACjC,CAEA,SAASC,GAAsB7wB,GAC7B,OAAOA,EAAM5F,kBAAkB02B,OACjC,CCpFO,SAASC,GAAmBC,EAAiBC,GAClD,GA2BK,SAAgBD,GACrB,GAAIA,EAAO5uB,MAAK,SAACgoB,GAAU,OAAAA,EAAM8G,kBAAkBR,SAAxB,IACzB,OAAO,EAET,IAAK,IAAInzB,EAAI,EAAGA,EAAIyzB,EAAOxzB,OAAS,EAA8CD,GAAK,EACrF,GACEyzB,EAAOzzB,EApCkC,EAoCW,GAAGyC,MAAM+D,UAAYitB,EAAOzzB,GAAGyC,MAAM+D,WACzF7K,EAEA,OAAO,EAGX,OAAO,CACT,CAxCMi4B,CAAOH,GAQT,OAPAC,EAAUG,eAAe,cACrBJ,EAAO5uB,KAAKivB,KACdJ,EAAUG,eAAe,cAEvBH,EAAUK,UACZL,EAAUG,eAAe,eAEpB,CAAED,QAAQ,GAGnB,IAAMI,EAAsBP,EAAO5uB,MAAK,SAACgoB,GAAU,OAAAA,EAAM8G,kBAAkBR,SAAxB,IAanD,OAZAM,EAAO12B,SAAQ,SAAC8vB,GACVA,EAAMkH,UACRlH,EAAMgH,eAAe,eAGrBC,GAAOjH,KAENmH,GAEDnH,EAAMgH,eAAe,aAEzB,IACO,CAAED,QAAQ,EACnB,CA8BO,SAASE,GAAOjH,GACrB,OAAIA,EAAMoH,kBAAmBpH,EAAM8G,kBAAkB1M,Q/C8WxB1lB,E+C3WNsrB,EAAMpqB,MAAM5F,O/C2WgEs0B,E+CzXnG,gL/C0XI5vB,EAAQQ,QACHR,EAAQQ,QAAQovB,GAGrB5vB,EAAQ2yB,mBACH3yB,EAAQ2yB,kBAAkB/C,KAN9B,IAAwB5vB,EAAsE4vB,C+C1WrG,CCHO,SAASgD,GACd7Y,EACAwP,EACAza,GAEA,IAEI+jB,EAFEC,EAAgC,IAAIC,GAPC,KAQrCxH,EAAiB,IAAI3Y,GAG3BmH,EAAU7H,UAAU,GAAoC,WACtD4gB,EAAQtP,OACV,IAEAzJ,EAAU7H,UAAU,EAAkC8gB,GACtDjZ,EAAU7H,UAAU,EAA+B8gB,GAE3C,IFtEuC,EAE3CC,EAEAC,EAJ6CC,EAAeC,EAC5DX,EAEAY,EAGEC,EEgEQC,GFtEiC,EEsEgC,CAC7EJ,cAAe,SAACK,GAAqB,OA6CzC,SACE1kB,EACAgkB,EACAU,GAEA,GAAK1kB,EAAc2kB,oBAAqBX,EAAQn0B,OAAhD,CAMA,IAAM+0B,EAuER,SAAgCxyB,EAA4BguB,GAC1D,IAAI5zB,EACAq4B,EAEJ,GAAI5nB,GAA6B,YAAa,CAC5C,IAAM6nB,EAAO1yB,EAAM5F,OAAOu4B,wBAC1Bv4B,EAAS,EACP,CACEgiB,MAAOthB,KAAKM,MAAMs3B,EAAKtW,OACvBE,OAAQxhB,KAAKM,MAAMs3B,EAAKpW,SAE1ByR,GAAwB/tB,EAAM5F,OAAQ4zB,IAExCyE,EAAW,CAETG,EAAG93B,KAAKM,MAAM4E,EAAM+qB,QAAU2H,EAAKG,MACnCC,EAAGh4B,KAAKM,MAAM4E,EAAMgrB,QAAU0H,EAAKK,K,CAIvC,MAAO,CACLx2B,KAAM,QACNnC,OAAM,EACNq4B,SAAQ,EACRpzB,KAAM6rB,GAAyBlrB,EAAM5F,OAAQ4zB,GAEjD,CAjG0BgF,CAAuBV,EAAkB1kB,EAAcogB,qBAC/E,GAAKpgB,EAAc2kB,mBAAsBC,EAAgBnzB,KAMzD,OAAOmzB,C,CACT,CAhEyCS,CAAmBrlB,EAAegkB,EAASU,EAA3C,EACrCJ,QAAS,SAACM,EAAiBU,EAAYhC,GACrC,OAgEN,SACEtjB,EACAiL,EACAwP,EACAuJ,EACAvH,EACA8I,EACAX,EACAU,EACAhC,GAEA,IAAM9G,EAAQgJ,GAASva,EAAW+Y,EAASV,EAAiBsB,EAAiBU,GAEzEtlB,EAAc2kB,mBAChBY,EAAwB/I,GAGlB,IAAMiJ,EAA4BjL,GACxCvP,EACAwP,EACAza,GACA,SAAC0lB,GACKA,EAAqB/J,aAAe+J,EAAqBruB,IAAMmlB,EAAMtgB,YAAY/F,UAEnFqmB,EAAMmJ,WAENnJ,EAAM5pB,KAAK8yB,EAAqB/J,YAAc+J,EAAqBruB,SAAMvL,GAIpEkU,EAAc2kB,oBACZe,EAAqB/J,YAKxBa,EAAMoJ,WAFNpJ,EAAMmJ,WAMd,GA9HqC,KAgItC,KAEKE,EAAwB5a,EAAU7H,UAAU,GAA+B,SAAC,G,IAAE0iB,EAAS,YAC3FtJ,EAAM5pB,KAAKkzB,EAAU3vB,UACvB,IAEM4vB,EAAmBtJ,EAAerZ,WAAU,WAChDoZ,EAAM5pB,MACR,IAEA4pB,EAAMC,eAAerZ,WAAU,WAC7ByiB,EAAsBtiB,cACtBkiB,IACAM,EAAiBxiB,aACnB,GACF,CAzHMyiB,CACEhmB,EACAiL,EACAwP,EACAuJ,EACAvH,EACA8I,EACAX,EACAU,EACAhC,EATF,GFzE6Ce,EAAa,gBAAEC,EAAO,UACnEX,GAAsB,EAEtBY,GAAkB,EAGhBC,EAAY,CAChBtyB,EACElB,OAAM,eAEN,SAACoB,GACCuxB,GAAsB,EACtBQ,EAA8BtB,KAC1BI,GAAsB7wB,KACxBgyB,EAAeC,EAAcjyB,GAEjC,GACA,CAAEK,SAAS,IAGbP,EACElB,OAAM,mBAEN,WACOmzB,GAAgCtB,OACnCc,GAAsB,EAE1B,GACA,CAAElxB,SAAS,IAGbP,EACElB,OAAM,SAEN,SAACs0B,GACC,GAAIrC,GAAsBqC,IAAelB,EAAc,CAErD,IAAM,EAAe,CACnBtB,UAAWa,EACX/M,MAAO2N,GAEJA,GACHl4B,WACE,GAAQ,WACN,EAAauqB,MAAQ2N,CACvB,KAIJD,EAAQF,EAAckB,GAAY,WAAM,YACxClB,OAAet4B,C,CAEnB,GACA,CAAE2G,SAAS,IAGbP,EACElB,OAAM,SAEN,WACEuzB,GAAkB,CACpB,GACA,CAAE9xB,SAAS,KAIR,CACLG,KAAM,WACJ4xB,EAAU93B,SAAQ,SAAC2F,GAAa,OAAAA,EAASO,MAAT,GAClC,IEeA,KAOF,MAAO,CACLA,KAAM,WACJsxB,IACAzH,EAAehZ,SACfghB,GACF,EACApV,eAXqC,CACrCsB,aAAc,SAAC/I,GACb,OAAA5H,EAAc2kB,kBAAoBX,EAAQvP,QAAQ7M,GAAaoc,EAAQn0B,KAAK+X,EAA5E,IAYJ,SAAS2d,EAAwB/I,GAC/B,IAAKuH,IAAsBA,EAAkBjH,UAAUN,GAAQ,CAC7D,IAAM,EAAYA,EAAM3K,QACxBkS,EAAoB7H,GAAiBM,GAAO,SAAC4G,IA6N5C,SAAwBA,EAAiBC,GAC3BF,GAAmBC,EAAQC,GAAU,QAEtDD,EAAO12B,SAAQ,SAAC8vB,GAAU,OAAAA,EAAMmJ,SAAN,IAC1BtC,EAAUzwB,KAAKmE,KACfssB,EAAUuC,SAASxC,EAAOjzB,KAAI,SAACqsB,GAAU,OAAAA,EAAMpqB,KAAN,OAEzCixB,EAAUsC,UACVvC,EAAO12B,SAAQ,SAAC8vB,GAAU,OAAAA,EAAMoJ,UAAN,IAE9B,CAtOQK,CAAe7C,EAAQ,EACzB,G,CAEJ,CAEA,SAASc,IACHH,GACFA,EAAkBnxB,MAEtB,CACF,CA2HA,SAAS4yB,GACPva,EACA+Y,EACAV,EACAsB,EACAU,GAEA,IAKIY,EALEjV,EAAKlkB,IACLmP,EAAcjF,IACdkvB,EAAenC,EAAQ5uB,IAAI6b,EAAI/U,EAAYhG,UAC3CkwB,EAA0BpM,GAAiB/O,GAC7CzF,EAAS,EAEP6gB,EAAsC,GACtC5J,EAAiB,IAAI3Y,GAE3B,SAASlR,EAAK0zB,GACG,IAAX9gB,IAIJA,EAAS,GADT0gB,EAAkBI,GAGhBH,EAAa7R,MAAM9c,GAAgB0uB,IAEnCC,EAAa9wB,SAEf+wB,EAAwBxzB,OACxB6pB,EAAehZ,SACjB,CAEA,MAAO,CACLrR,MAAOkzB,EACP1yB,KAAI,EACJ6pB,eAAc,EAEViH,eACF,OAAO0C,EAAwBnM,YAAYC,WAAa,CAC1D,EACI0J,sBACF,YAA2B93B,IAApBo6B,CACT,EACA5C,gBAAe,EACfE,eAAgB,SAAC+C,GACfF,EAAiB32B,KAAK62B,EACxB,EACArqB,YAAW,EAEX2gB,UAAW,WAAM,OAAW,IAAXrX,GAA6C,IAAXA,CAAlC,EAEjBqM,MAAO,WAAM,OAAA2T,GAASva,EAAW+Y,EAASV,EAAiBsB,EAAiBU,EAA/D,EAEbM,SAAU,SAACY,GAET,GADA5zB,IACe,IAAX4S,EAAJ,CAIM,MAA+C4gB,EAAwBnM,YAArEG,EAAa,gBAAEF,EAAU,aAAEC,EAAa,gBAC1CsM,EAA2B,EAC/B,CACE93B,KAAM,QACNmI,SAAUovB,GAAmB/uB,GAAQ+E,EAAY/F,UAAW+vB,GAC5DhqB,YAAW,EACX+U,GAAE,EACFoV,iBAAgB,EAChBK,OAAQ,CACNtM,cAAa,EACbF,WAAU,EACVC,cAAa,GAEf5nB,OAAQi0B,UAAa,CAAClB,GACtBlzB,MAAOkzB,GAETV,GAEF3Z,EAAUxH,OAAO,EAA0CgjB,GAC3DjhB,EAAS,C,CACX,EAEAmgB,QAAS,WACP/yB,IACA4S,EAAS,CACX,EAEJ,CCtRA,SAASmhB,GACPvV,EACAwV,GAEA,IAAMC,EAAuBC,GAAa1V,GACtC,CACEA,OAAQ,CACNH,GAAIG,EAAOH,GACX8V,aAAclwB,EAAiBua,EAAOta,UACtCyjB,YAAa,CACX5rB,KAAMyiB,EAAOiV,kBAEfr8B,MAAO,CACLg9B,MAAO5V,EAAOsV,OAAOxM,YAEvB+M,UAAW,CACTD,MAAO5V,EAAOsV,OAAOvM,eAEvB+M,SAAU,CACRF,MAAO5V,EAAOsV,OAAOtM,gBAGzBrV,IAAK,CACHqM,OAAQ,CACN5kB,OAAQ4kB,EAAO5kB,OACfq4B,SAAUzT,EAAOyT,iBAIvB/4B,EACEokB,EAAmB4W,GAAa1V,QAA2BtlB,EAAjBslB,EAAOlmB,QACjDi8B,EAAiC/yB,EACrC,CACEgd,OAAQ,CACNH,GAAIlkB,IACJP,OAAQ,CACNiF,KAAM2f,EAAO3f,MAEf9C,KAAMyiB,EAAOziB,MAEfuJ,KAAMkZ,EAAOlV,YAAY/F,UACzBxH,KAAM,UAERk4B,GAEIO,EAAeR,EAAmB9T,iBAAiB1B,EAAOlV,YAAYhG,UAI5E,YAHqBpK,IAAjBs7B,IACFD,EAAYjW,KAAO,CAAEmW,cAAeD,IAE/B,CACLlX,gBAAe,EACfH,YAAaoX,EACbvf,UAAWwJ,EAAOlV,YAAYhG,SAC9B8Z,cAAe8W,GAAa1V,GAAU,CAAEhf,MAAOgf,EAAOhf,MAAOG,OAAQ6e,EAAO7e,QAAW,CAAC,EAE5F,CAEA,SAASu0B,GAAa1V,GACpB,MAAuB,WAAhBA,EAAOziB,IAChB,CC5GA,IAAM24B,GACJ,0GAkCK,SAASC,GAA8Bv0B,GACpC,IAAMw0B,EAchB,SAA2Bx0B,GACzB,OAAOmiB,GAAgCnkB,OAAQ,UAAW,CACxDokB,OAAA,SAAkB5Z,EAAyBT,EAAc0sB,EAAiBC,EAAmBC,GAC3F,IAAI5tB,EAEJ,GAAI4tB,EACF5tB,EAAQF,GAAkB8tB,GAC1B30B,EAAS+G,EAAO4tB,OACX,CACL,IAMI,EANE,EAAW,CACf5sB,IAAG,EACHF,OAAQ6sB,EACRrtB,KAAMotB,GAIJG,EAAMpsB,EACV,GAAkC,oBAA9B,CAAC,EAAEpO,SAAS9C,KAAKkR,GAAgC,CACnD,IAAMqsB,EAASP,GAAe11B,KAAKg2B,GAC/BC,IACF,EAAOA,EAAO,GACdD,EAAMC,EAAO,G,CAUjB70B,EANA+G,EAAQ,CACNtI,KAAI,EACJ+J,QAAwB,iBAARosB,EAAmBA,OAAM97B,EACzCiO,MAAO,CAAC,IAGMyB,E,CAEpB,GAEJ,CAjD6CssB,CAAkB90B,GAAS,KACxD+0B,EAqDhB,SAAsC/0B,GACpC,OAAOmiB,GAAgCnkB,OAAQ,uBAAwB,CACrEokB,OAAA,SAAOhqB,GACL,IAAM48B,EAAS58B,EAAE48B,QAAU,eACrBjuB,EAAQF,GAAkBmuB,GAChCh1B,EAAS+G,EAAOiuB,EAClB,GAEJ,CA7D0DC,CAA6Bj1B,GAAS,KAE9F,MAAO,CACLJ,KAAM,WACJ40B,IACAO,GACF,EAEJ,CCpCA,IAAMG,GAA8E,CAAC,EAE9E,SAASC,GAAsBC,GACpC,IAAMC,EAAqBD,EAAKj4B,KAAI,SAACjG,GAInC,OAHKg+B,GAAwBh+B,KAC3Bg+B,GAAwBh+B,GAS9B,SAAiCA,GAC/B,IAAM+Z,EAAa,IAAIH,IAAuB,WAC5C,IAAMwkB,EAAqB99B,QAAQN,GAWnC,OATAM,QAAQN,GAAO,W,IAAC,sDACdo+B,EAAmBn9B,MAAMX,QAAS+9B,GAClC,IAAMtsB,EAAgBW,KAEtB7R,GAAc,WACZkZ,EAAWR,OAAO+kB,GAAgBD,EAAQr+B,EAAK+R,GACjD,GACF,EAEO,WACLzR,QAAQN,GAAOo+B,CACjB,CACF,IAEA,OAAOrkB,CACT,CA5BqCwkB,CAAwBv+B,IAElDg+B,GAAwBh+B,EACjC,IAEA,OAAO0Z,GAAA,WAAgB,EAAgBykB,EACzC,CAwBA,SAASG,GAAgBD,EAAmBr+B,EAAqB+R,GAE/D,IACIlC,EADAyB,EAAU+sB,EAAOp4B,KAAI,SAACu4B,GAAU,OAiBtC,SAAiCA,GAC/B,GAAqB,iBAAVA,EACT,OAAOA,EAET,GAAIA,aAAiBrsB,MACnB,OAAOK,GAAmB7C,GAAkB6uB,IAE9C,OAAO96B,EAAc86B,EAAO,EAC9B,CAzBsCC,CAAwBD,EAAxB,IAAgCz0B,KAAK,KAGzE,GAAI/J,IAAQP,EAAeK,MAAO,CAChC,IAAM4+B,EAAkB/4B,EAAK04B,GAAQ,SAACG,GAAmC,OAAAA,aAAiBrsB,KAAjB,IACzEtC,EAAQ6uB,EAAkBtsB,GAAmBzC,GAAkB+uB,SAAoB98B,EACnF0P,EAAU,yBAAkBA,E,CAG9B,MAAO,CACLtR,IAAG,EACHsR,QAAO,EACPzB,MAAK,EACLkC,cAAa,EAEjB,CC5DO,ICHH4sB,GACA,GDESC,GACG,eADHA,GAGG,gBAYT,SAASC,GAAqBX,GACnC,IAyCMnkB,EAzCAD,EAA4C,GAE9ChV,EAASo5B,EAAMU,KACjB9kB,EAAYtU,KAsCRuU,EAAa,IAAIH,IAAsB,WAC3C,IAAMklB,EAAqB,GAAQ,SAAC52B,GAClC6R,EAAWR,OAmBjB,SAAwCrR,GACtC,IAAMzD,EAAOm6B,GACPttB,EAAU,WAAIpJ,EAAM62B,WAAU,yBAAiB72B,EAAM82B,mBAAkB,eAC7E,MAAO,CACLv6B,KAAMm6B,GACNK,QAAS/2B,EAAM82B,mBACf1tB,QAAS,UAAG7M,EAAI,aAAK6M,GACrBzB,MAAOqvB,GACLh3B,EAAM82B,mBACN92B,EAAMi3B,eACF,UAAG7tB,EAAO,2BAAmB3J,EAAaO,EAAMi3B,eAAgB,IAAK,OAAM,KAC3E,YACJj3B,EAAMk3B,WACNl3B,EAAMm3B,WACNn3B,EAAMo3B,cAGZ,CApCwBC,CAA+Br3B,GACnD,IAIA,OAFiBF,EAAiBe,SAAU,0BAAqC+1B,GAAmB,IAGtG,KA3CA,IAAMU,EAActB,EAAKtmB,QAAO,SAAC5X,GAA0C,OAAAA,IAAQ4+B,EAAR,IAK3E,OAJIY,EAAY95B,QACdoU,EAAYtU,KAMhB,SAAgCg6B,GAC9B,IAAMzlB,EAAa,IAAIH,IAAsB,WAC3C,GAAM9S,OAAyB24B,kBAA/B,CAIA,IAAMC,EAAgB,GAAQ,SAACC,GAC7B,OAAAA,EAAQn9B,SAAQ,SAACo9B,GAgCvB,IAAkC,EAAEn7B,EAAMwP,EA/BlC8F,EAAWR,QA+BiB9U,GAAF,EA/BiBm7B,GA+BX,KAAE3rB,EAAI,OACrC,CACLxP,KAAI,EACJw6B,QAAShrB,EAAK8S,GACdzV,QAAS,UAAG7M,EAAI,aAAKwP,EAAK3C,SAC1BzB,MAAOqvB,GAAWjrB,EAAK8S,GAAI9S,EAAK3C,QAAS2C,EAAKmrB,WAAYnrB,EAAKorB,WAAYprB,EAAKqrB,gBAnC9E,GAFA,IAKI7lB,EAAW,IAAK3S,OAAyB24B,kBAAmBC,EAAe,CAC/EG,MAAOL,EACP/d,UAAU,IAIZ,OADAhI,EAAS2C,UACF,WACL3C,EAASgD,YACX,C,CACF,IAEA,OAAO1C,CACT,CA9BqB+lB,CAAuBN,IAGnC9lB,GAAA,WAAgB,EAAeI,EACxC,CAqEA,SAASolB,GACP33B,EACA+J,EACA8tB,EACAC,EACAC,GAEA,OACEF,GACAhtB,GAAmB,CACjB7K,KAAI,EACJ+J,QAAO,EACPzB,MAAO,CACL,CACEe,KAAM,IACNC,IAAKuuB,EACLjvB,KAAMkvB,EACN1uB,OAAQ2uB,KAKlB,CEnGO,SAASS,GAAqBhf,EAAsB2b,GACzD,IAAMsD,EAAkB,IAAIpmB,GAQ5B,OChCK,SAA2BomB,GAChC,IAAMhmB,EAAeikB,GAAsB,CAACx+B,EAAeK,QAAQoZ,WAAU,SAAC+mB,GAC5E,OAAAD,EAAgBzmB,OAAO,CACrBvH,YAAajF,IACbuE,QAAS2uB,EAAa3uB,QACtBzB,MAAOowB,EAAapwB,MACpBpN,OAAQkP,GACRO,SAAU,UACVH,cAAekuB,EAAaluB,eAN9B,GAeJ,CDSEmuB,CAAkBF,GEvBb,SAA2BA,GACzB3C,IAA8B,SAACxrB,EAAYC,GAChDkuB,EAAgBzmB,OACd3H,GAAgB,CACdC,WAAU,EACVC,cAAa,EACbE,YAAajF,IACbkF,eAAgB,WAChBxP,OAAQkP,GACRO,SAAU,cAGhB,GACF,CFWEiuB,CAAkBH,GG3Bb,SAA0BA,GAC/B,IAAMhmB,EAAe6kB,GAAqB,CAACD,GAA4BA,KAA6B1lB,WAClG,SAACmM,GACC,OAAA2a,EAAgBzmB,OAAO,CACrBvH,YAAajF,IACbuE,QAAS+T,EAAY/T,QACrBzB,MAAOwV,EAAYxV,MACnBpL,KAAM4gB,EAAY4Z,QAClBx8B,OAAQkP,GACRO,SAAU,aANZ,GAeN,CHUEkuB,CAAiBJ,GAEjBA,EAAgB9mB,WAAU,SAACpZ,GAAU,OAAAihB,EAAUxH,OAAO,GAAwC,CAAEzZ,MAAK,GAAhE,IAKhC,SAAgCihB,EAAsB2b,GAc3D,OAbA3b,EAAU7H,UAAU,IAAwC,SAAC,G,IAAEpZ,EAAK,QAAEkmB,EAAe,kBAAED,EAAkB,qBACvGhF,EAAUxH,OAAO,GAEf,EACE,CACEyM,gBAAe,EACfD,mBAAkB,GAgC5B,SACEjmB,EACA48B,GAEA,IAAM7W,EAAgC,CACpC7X,KAAMlO,EAAMkS,YAAY/F,UACxBnM,MAAO,CACLinB,GAAIlkB,IACJyO,QAASxR,EAAMwR,QACf7O,OAAQ3C,EAAM2C,OACdoN,MAAO/P,EAAM+P,MACbwwB,eAAgBvgC,EAAMiS,cACtBtN,KAAM3E,EAAM2E,KACZyN,SAAUpS,EAAMoS,SAChBG,OAAQvS,EAAMuS,OACdiuB,YAAa,WAEf77B,KAAM,SAEFy4B,EAAeR,EAAmB9T,iBAAiB9oB,EAAMkS,YAAYhG,eACtDpK,IAAjBs7B,IACFrX,EAAYmB,KAAO,CAAEmW,cAAeD,IAGtC,MAAO,CACLrX,YAAW,EACXnI,UAAW5d,EAAMkS,YAAYhG,SAC7B8Z,cAAe,CACbhmB,MAAOA,EAAMgS,eAGnB,CA7DQyuB,CAAazgC,EAAO48B,IAG1B,IAEO,CACL8D,SAAU,SACR,EACAza,G,IADEjmB,EAAK,QAAEiS,EAAa,gBAAEC,EAAW,cAAWgU,EAAe,UAIvDya,EAAW7uB,GAAgB,CAC/BC,WAFiB/R,aAAiBqS,MAAQxC,GAAkB7P,QAAS8B,EAGrEkQ,cAAehS,EACfiS,cAAa,EACbC,YAAW,EACXC,eAAgB,WAChBxP,OAAQkP,GACRO,SAAU,YAGZ6O,EAAUxH,OAAO,GAAwC,CACvDyM,gBAAe,EACfD,mBAAkB,EAClBjmB,MAAO2gC,GAEX,EAEJ,CAxCSC,CAAuB3f,EAAW2b,EAC3C,CIXO,SAASiE,GAAmB3P,GACjC,GAAK1kB,aAAiB,qBAAsBA,YAA5C,CAGA,IAAMs0B,EAAkBt0B,YAAYu0B,iBAAiB7P,EAAQngB,IAAK,YAElE,GAAK+vB,EAAgBl7B,QAAY,WAAYk7B,EAAgB,GAA7D,CAIA,IAsB+BE,EAtBzBC,EAAaH,EAChB36B,KAAI,SAACsX,GAAU,OAAAA,EAAM1Y,QAAN,IACf+S,OAAO6F,IACP7F,QAAO,SAAC2F,GACP,OA0Ba/P,EAzBX+P,EAyB2BrQ,EAxB3B8jB,EAAQhf,YAAYhG,SAwB4BmB,EAvBhD+c,GAAQ,CAAExM,UAAWsT,EAAQhf,YAAYhG,SAAUY,SAAUokB,EAAQpkB,WAwBrEo0B,EAAc,EACbxzB,EAAOkQ,WAAaxQ,EAAQ8zB,GAAe9W,GAAQ1c,IAAWf,GAAYU,EAAK6zB,GAFxF,IAAmBxzB,EAAgBN,EAAqBC,EAChD6zB,CA3BF,IAOJ,OAA0B,IAAtBD,EAAWr7B,OACNq7B,EAAW,GAGM,IAAtBA,EAAWr7B,QAQRwkB,IADwB4W,EAPwBC,GAQnB,KAAOD,EAAqB,GAAGpjB,UAP1DqjB,EAAW,QADpB,C,EAKF,CAMA,SAAS7W,GAAQ1c,GACf,OAAOf,GAAYe,EAAOkQ,UAAWlQ,EAAOZ,SAC9C,CC9BO,SAASq0B,GACdlgB,EACAjL,EACAkP,GAEAjE,EAAU7H,UAAU,GAAsC,SAAC8X,GACzDjQ,EAAUxH,OAAO,GAerB,SACEyX,EACAlb,EACAkP,GAEA,IAAMvgB,EAAwB,QAAjBusB,EAAQvsB,KAA2B,MAAmB,QAE7Dy8B,EAAiBP,GAAmB3P,GACpChf,EAAckvB,EAAiBn1B,EAAiBm1B,EAAexjB,WAAasT,EAAQhf,YACpFmvB,EAA+BD,EAAiBE,GAA+BF,QAAkBt/B,EAEjGy/B,EAiFR,SAAmCrQ,EAA+Blb,GAEhE,KADsBkb,EAAQzD,cAAgByD,EAAQ7Q,SAAW6Q,EAAQ1D,QAEvE,OAEF,MAAO,CACLzS,IAAK,CACHymB,QAAStQ,EAAQ1D,OAAQU,kBACzBuT,SAAUvQ,EAAQ7Q,QAAS6N,kBAC3BwT,SAAUC,GAAW3rB,IAG3B,CA7FsB4rB,CAA0B1Q,EAASlb,GACjD6rB,EAAeC,GAAoB5c,EAAgBhT,GAEnD6vB,EAAgB33B,EACpB,CACE8D,KAAMgE,EAAY/F,UAClB+wB,SAAU,CACRjW,GAAIlkB,IACJ4B,KAAI,EACJmI,SAAUD,EAAiBqkB,EAAQpkB,UACnCge,OAAQoG,EAAQpG,OAChBkX,YAAa9Q,EAAQ1V,OACrBzK,IAAKmgB,EAAQngB,KAEfpM,KAAM,YAER48B,EACAF,EACAQ,GAEF,MAAO,CACLjkB,UAAW1L,EAAYhG,SACvB6Z,YAAagc,EACb/b,cAAe,CACbic,iBAAkBb,GAAmDA,EACrEjV,IAAK+E,EAAQ/E,IACbc,SAAUiE,EAAQjE,SAClBiV,aAAchR,EAAQtE,MACtBuV,YAAajR,EAAQrE,KACrB7sB,MAAOkxB,EAAQlxB,OAGrB,CA1DiEoiC,CAAelR,EAASlb,EAAekP,GACtG,IAEAjE,EAAU7H,UAAU,GAAkD,SAACoI,GACrE,IAAoB,UAAAA,EAAA,eAAS,CAAxB,IAAM/D,EAAK,KACU,aAApBA,EAAMoD,YtC6BkB,oBADJnT,EsC5B6B+P,GtC6B3CX,eAA+D,UAAzBpP,EAAOoP,gBsC5BrDmE,EAAUxH,OAAO,GAEf4oB,GAAqB5kB,EAAOzH,EAAekP,G,CtCyB9C,IAAuBxX,CsCrB5B,GACF,CA+CA,SAAS20B,GACP5kB,EACAzH,EACAkP,GAEA,IAAMvgB,EAAOsY,GAAoBQ,GAC3B6kB,EAAehB,GAA+B7jB,GAC9CvL,EAAcjG,EAAiBwR,EAAMG,WAErC2jB,EAoDR,SAAiC9jB,EAAqCzH,GAEpE,IADsByH,EAAM4C,QAE1B,OAEF,MAAO,CACLtF,IAAK,CACH0mB,SAAUhkB,EAAM4C,QAChBqhB,SAAUC,GAAW3rB,IAG3B,CA/DsBusB,CAAwB9kB,EAAOzH,GAC7C6rB,EAAeC,GAAoB5c,EAAgBhT,GAEnD6vB,EAAgB33B,EACpB,CACE8D,KAAMgE,EAAY/F,UAClB+wB,SAAU,CACRjW,GAAIlkB,IACJ4B,KAAI,EACJoM,IAAK0M,EAAMhW,MAEb9C,KAAM,YAER48B,EACAe,EACAT,GAEF,MAAO,CACLjkB,UAAW1L,EAAYhG,SACvB6Z,YAAagc,EACb/b,cAAe,CACbic,iBAAmDxkB,GAGzD,CAEA,SAAS6jB,GAA+B5zB,GACtC,MAAO,CACLwvB,SAAU,EACR,CACEpwB,UtC9D2C2Q,EsC8DE/P,EtC7D3CZ,EAAqC2Q,EAAK,SAAhCG,EAA2BH,EAAK,UAArBuB,EAAgBvB,EAAK,YAIzC5Q,EADQ,IAAbC,GAAkB8Q,EAAYoB,EACR7R,GAAQyQ,EAAWoB,GAGrBlS,IsCuDlB01B,KAAMvjB,GAAYvR,IAEpB8P,GAAkC9P,KtCjEjC,IAA4C+P,EACzC3Q,EAAU8Q,EAAWoB,CsCmE/B,CAqCA,SAAS2iB,GAAW3rB,GAClB,OAAOhQ,EAASgQ,EAAciY,mBAAqBjY,EAAciY,kBAAoB,SAAMnsB,CAC7F,CAEA,SAASggC,GAAoB5c,EAAmCud,GAC9D,IAAMlc,EAAUrB,EAAesB,mBAAmBic,EAAcv2B,UAChE,MAAO,CACL6O,IAAK,CACH2nB,WAAYnc,IAAYA,EAAQoc,iBAGtC,CN1LO,SAASC,GAAiBz6B,GAwB/B,YAxB+B,IAAAA,MAAA,QAC1B02B,KAC8B,WAA7B51B,SAAS45B,gBACXhE,GAA4B,CAC1B1yB,UAAW,IAGb0yB,GAA4B,CAC1B1yB,UAAW6d,KAEH,GAAkB1hB,EAC1BH,EACA,CAAC,WAAD,qBACA,SAACC,GACoB,aAAfA,EAAMzD,MAAoD,WAA7BsE,SAAS45B,kBACxChE,GAA2B1yB,UAAY/D,EAAM+D,UAC7C,KAEJ,GACA,CAAE1D,SAAS,IACZ,OAIEo2B,EACT,CORO,IAAMiE,GAAuB,IAc7B,SAASC,GAAwB9hB,EAAsBjY,GAC5D,IAAMg6B,EAAmB,CAAC,EAC1B,SAASC,EAAWC,GAClB,EAAOF,EAASE,GAChBl6B,EAASg6B,EACX,CAEQ,IAAMG,EA0BT,SAAgCliB,EAAsBjY,GAmB3D,MAAO,CAAEJ,KAlBqBqY,EAAU7H,UAAU,GAAkD,SAACoI,GACnG,IAAoB,UAAAA,EAAA,eAAS,CAAxB,IAAM/D,EAAK,KACU,eAApBA,EAAMoD,WACR7X,EAAS,CACPo6B,YAAa3lB,EAAM2lB,YACnBC,iBAAkB5lB,EAAM6lB,yBACxBC,eAAgB9lB,EAAM8lB,eACtBC,UAAW/lB,EAAMoF,aAKjB4gB,UAAWhmB,EAAMa,eAAiB,GAAKb,EAAMa,eAAiBtR,IAAgByQ,EAAMa,mBAAgBxc,G,CAI5G,IAAE,YAGJ,CA9C2C4hC,CAAuBziB,EAAWgiB,GAAW,KACxEU,EA+CT,SAAyC1iB,EAAsBjY,GACpE,IAAM46B,EAAchB,KAcpB,MAAO,CAAEh6B,KAbqBqY,EAAU7H,UAAU,GAAkD,SAACoI,GACnG,IAAMqiB,EAAWh+B,EACf2b,GACA,SAAC/D,GACC,MAAoB,UAApBA,EAAMoD,WACS,2BAAfpD,EAAMhW,MACNgW,EAAMG,UAAYgmB,EAAYz3B,WAC9BsR,EAAMG,UAAYklB,EAHlB,IAKAe,GACF76B,EAAS66B,EAASjmB,UAEtB,IAAE,YAEJ,CA/DoCkmB,CAAgC7iB,GAAW,SAAC8iB,GAC5E,OAAAd,EAAW,CAAEc,qBAAoB,GAAjC,IACD,KACaC,EAoET,SACL/iB,EACA9Y,EACAa,GAEA,IAAM46B,EAAchB,KAKhBqB,EAA4Bja,IAClBka,EAAsB57B,EAClCH,EACA,CAAC,cAAD,YACA,SAACC,GACC67B,EAA4B77B,EAAM+D,SACpC,GACA,CAAE1D,SAAS,EAAMD,MAAM,IACxB,KAEoB27B,EAAyBljB,EAAU7H,UAAU,GAEhE,SAACoI,GACC,IAAM4iB,E5DoGL,SACL7+B,EACAO,GAEA,IAAK,IAAIH,EAAIJ,EAAMK,OAAS,EAAGD,GAAK,EAAGA,GAAK,EAAG,CAC7C,IAAMF,EAAOF,EAAMI,GACnB,GAAIG,EAAUL,EAAME,EAAGJ,GACrB,OAAOE,C,CAIb,C4D/GuB4+B,CACf7iB,GACA,SAAC/D,GACC,MAAoB,6BAApBA,EAAMoD,WACNpD,EAAMG,UAAYqmB,GAClBxmB,EAAMG,UAAYgmB,EAAYz3B,WAC9BsR,EAAMG,UAAYklB,EAHlB,IAKAsB,GACFp7B,EAASo7B,EAASxmB,UAEtB,IACD,YAED,MAAO,CACLhV,KAAM,WACJs7B,IACAC,GACF,EAEJ,CA/GoCG,CAAkCrjB,EAAWja,QAAQ,SAACu9B,GACtFtB,EAAW,CACTsB,uBAAsB,GAE1B,IAAE,KACYC,EAoHT,SACLvjB,EACAjY,GAEA,IAAM46B,EAAchB,KAmBpB,MAAO,CACLh6B,KAlB4BqY,EAAU7H,UAAU,GAAkD,SAACoI,GACnG,IAAMijB,EAAkB5+B,EACtB2b,GACA,SAAC/D,GACC,MAAoB,gBAApBA,EAAMoD,WAA+BpD,EAAMG,UAAYgmB,EAAYz3B,SAAnE,IAEJ,GAAIs4B,EAAiB,CACnB,IAAMC,EAAkBv3B,GAAQs3B,EAAgB7mB,UAAW6mB,EAAgBpiB,iBAC3ErZ,EAAS,CAGP07B,gBAAiBA,GAAmB,EAAIA,EAAmB,EAC3DC,eAAgBF,EAAgB7mB,W,CAGtC,IAAE,YAKJ,CA9IoCgnB,CAAuB3jB,GAAW,SAAC,GACnEgiB,EAAW,CACTyB,gBAFkF,kBAGlFC,eAHkG,kBAKtG,IAAE,KAEF,MAAO,CACL/7B,KAAM,WACJu6B,IACAQ,IACAK,IACAQ,GACF,EAEJ,CClDO,SAASK,GACd5jB,EACAwP,EACAza,EACA8uB,EACAC,EACAC,GAEA,IA0BIC,EA1BEC,EAA2B,CAC/BjV,YAAa,CACXC,WAAY,EACZC,cAAe,EACfC,cAAe,EACfC,YAAa,EACbC,iBAAkB,IAGR6U,EAA4BnV,GAAiB/O,GAAW,SAACmkB,GACrEF,EAAYjV,YAAcmV,EAC1BN,GACF,IAAE,KAEI,EAiCR,SACE7jB,EACAwP,EACAza,EACAqvB,EACAL,EACAh8B,GAEA,IAAIs8B,EAAqC,iBAAbD,EACxBE,GAAkC,EAChCC,EAAoC,GAE1C,SAASC,KACFF,IAAoCD,GAAyBE,EAAsB5/B,OAAS,GAC/FoD,EAAS9F,KAAKomB,IAAG,MAARpmB,KAAYsiC,GAEzB,CAYA,MAAO,CACL58B,KAXe4nB,GAAoBvP,EAAWwP,EAAuBza,GAAe,SAAC5N,GACjFm9B,IACFA,GAAkC,EAC9Bn9B,EAAMupB,aACR6T,EAAsB9/B,KAAKyH,GAAQ63B,EAAU74B,UAAW/D,EAAMiF,MAEhEo4B,IAEJ,IAAE,KAIAC,aAAc,SAAClC,GACT8B,IACFA,GAAwB,EACxBE,EAAsB9/B,KAAK89B,GAC3BiC,IAEJ,EAEJ,CAvE0DE,CACtD1kB,EACAwP,EACAza,EACA+uB,EACAC,GACA,SAACY,GACCV,EAAYW,YAAcD,EAC1Bd,GACF,IATYgB,EAAuB,OAAEJ,EAAY,eAsBnD,OAkHO9kB,GAA8B,iBA1HnCskB,EAAYa,sBAAwB,EAC1Bd,EA2Ed,SAAoChkB,EAAsBjY,GACxD,IAAIg9B,EAAc,EACZh/B,EAkBR,WACE,IACI4W,EACAwM,EAFAvmB,EAAQ,EAGZ,MAAO,CACLoiC,OAAQ,SAACxoB,QAES3b,IAAd8b,GACAH,EAAMG,UAAYwM,GAAW9oB,GAC7Bmc,EAAMG,UAAYA,GAAa,KAE/BA,EAAYwM,EAAU3M,EAAMG,UAC5B/Z,EAAQ4Z,EAAM5Z,QAEdA,GAAS4Z,EAAM5Z,MACfumB,EAAU3M,EAAMG,UAEpB,EACA/Z,MAAO,WAAM,OAAAA,CAAA,EAEjB,CAtCiBqiC,GAaf,MAAO,CACLt9B,KAb4BqY,EAAU7H,UAAU,GAAkD,SAACoI,GACnG,IAAoB,UAAAA,EAAA,eAAS,CAAxB,IAAM/D,EAAK,KACU,iBAApBA,EAAMoD,WAAiCpD,EAAM0oB,iBAC/Cn/B,EAAOi/B,OAAOxoB,GACVzW,EAAOnD,QAAUmiC,IACnBA,EAAch/B,EAAOnD,QACrBmF,EAASxF,EAAMwiC,EAAa,K,CAIpC,IAAE,YAKJ,CA7FkCI,CAA2BnlB,GAAW,SAAC8kB,GACnEb,EAAYa,sBAAwBA,EACpCjB,GACF,IAAE,MAEFG,EAAkB,EAEb,CACLr8B,KAAM,WACJu8B,IACAW,IACAb,GACF,EACAS,aAAY,EACZR,YAAW,EAEf,CCJO,SAASmB,GACd72B,EACAyR,EACAwP,EACAza,EACAswB,EACAC,EACAC,GAEM,IAKFC,EALE,EAUN,SAA0B/kC,GACxB,IAAMglC,EAAcC,GAClB1lB,EACAwP,EACAza,EACAxG,EAAQ,eAERtC,KACAxL,GAEMkH,EAASm6B,GAAwB9hB,GAAW,SAAC+hB,GACnD0D,EAAYE,cAAc5D,GAC1B0D,EAAYG,gBACd,IAAE,KACF,MAAO,CAAEH,YAAW,EAAE99B,KAAI,EAC5B,CAzBuDk+B,CAAiBN,GAA1DO,EAAuB,OACjCC,EAD8C,cAGpCC,EAoCd,WACEhmB,EAAU7H,UAAU,GAAoC,WAEtD4tB,EAAY35B,MAEZ25B,EAAcE,OAAgBplC,EAAW,CACvC2F,KAAMu/B,EAAYv/B,KAClByO,QAAS8wB,EAAY9wB,QACrBC,QAAS6wB,EAAY7wB,SAEzB,IAGA8K,EAAU7H,UAAU,GAAkC,WACpD4tB,EAAY35B,MACZ25B,EAAYG,eACd,IAGA,IAAMC,EAAoBpgC,OAAOkjB,YAC/B,GAAQ,WACN8c,EAAYG,eACd,IA9EqC,KAkFvC,MAAO,CACLv+B,KAAM,WACJ+hB,cAAcyc,EAChB,EAEJ,CAnEoCC,GAAoB,KAwBxD,SAASH,EAAgBh1B,EAA2Bo1B,GAClD,OAAOX,GACL1lB,EACAwP,EACAza,EACAxG,EAAQ,eAER0C,EACAo1B,EAEJ,CA8CA,OA7EIf,IACFE,EAiEF,SAAmCH,GACjC,OAAOA,EAAyBltB,WAAU,SAAC,G,IA2IjBmuB,EAA2BC,EAQjCC,EAChBC,EApJyCC,EAAW,cAAEC,EAAW,cACnE,GA0ImDJ,EA1IbI,GA0IdL,EA1ICI,GA4IXxqB,WAAaqqB,EAAcrqB,WAMvBsqB,EALHD,EAAcC,KAM3BC,EAAkBD,EAAKI,OAAO,IAC3B5+B,SAASmsB,eAAesS,IAN7BI,GAAgBN,EAAcC,QAAUK,GAAgBP,EAAgBE,OA1ItE,OAHAT,EAAY35B,MACZ25B,EAAYG,qBACZH,EAAcE,IAGlB,GACF,CA1E+Ba,CAA0BzB,IA4ElD,CACL0B,UAAW,SAACvgC,EAAcwgC,QAAA,IAAAA,MAAiCl7B,KACzDi6B,EAAYgB,UAAUvgC,EAAMwgC,GAC5BjB,EAAYH,gBACd,EACAqB,UAAW,SAACxmC,EAAuBwQ,GACjC80B,EAAY35B,IAAI6E,GAChB80B,EAAYG,gBACZH,EAAcE,EAAgBh1B,EAAaxQ,EAC7C,EACAkH,KAAM,WACJ69B,WAA4BltB,cAC5BwtB,IACAE,IACAD,EAAY35B,KACd,EAEJ,CAEA,SAASs5B,GACP1lB,EACAwP,EACAza,EACAmyB,EACApD,EACA7yB,EACAo1B,QADA,IAAAp1B,MAA2BjF,KAI3B,IAII6uB,EAGAr0B,EACAyO,EACAC,EATE8Q,EAAKlkB,IACPigC,EAAmB,CAAC,EAClBoF,EAAmC,CAAC,EACtCC,EAAkB,EAEhB74B,EAAW3M,EAAaslC,GAK1Bb,IACF7/B,EAAO6/B,EAAY7/B,KACnByO,EAAUoxB,EAAYpxB,QACtBC,EAAUmxB,EAAYnxB,SAGxB8K,EAAUxH,OAAO,EAAiC,CAAEwN,GAAE,EAAExf,KAAI,EAAEyK,YAAW,EAAEgE,QAAO,EAAEC,QAAO,IAGrF,MAAsE3U,EAC1E,EAAQ8mC,GAtJ+B,IAwJvC,CACEvmC,SAAS,IAJM+iC,EAAkB,YAAUyD,EAAwB,SAQjE,EAIF1D,GAAiB5jB,EAAWwP,EAAuBza,EAAe8uB,EAAoBC,EAAa7yB,GAHrGwzB,EAAY,eACN8C,EAAuB,OAC7BtD,EAAW,cAMb,SAASoD,IACPD,GAAmB,EACnB,IAAMI,OAA2B3mC,IAAdg6B,EAA0B/uB,IAAiB+uB,EAAU3vB,UACxE8U,EAAUxH,OAAO,EAEf,EACE,CACE2uB,cAAa,EACbC,gBAAe,EACfphB,GAAE,EACFxf,KAAI,EACJyO,QAAO,EACPC,QAAO,EACP4uB,YAAW,EACXv1B,SAAQ,EACR0C,YAAW,EACX8wB,QAAO,EACPl2B,SAAUK,GAAQ+E,EAAY/F,UAAWs8B,GACzCC,cAAwB5mC,IAAdg6B,GAEZoJ,GAGN,CAEA,OA3BAoD,IA2BO,CACL7gC,KAAI,EACJyO,QAAO,EACPC,QAAO,EACP0wB,eAAgB/B,EAChBz3B,IAAG,SAACs7B,QAAA,IAAAA,MAAS17B,KACX6uB,EAAY6M,EACZ1nB,EAAUxH,OAAO,EAA+B,CAAEqiB,UAAS,IAC3D0M,GACF,EACArB,cAAa,WAEXoB,IACAD,GACF,EACA1B,cAAA,SAAc1D,GACZF,EAAUE,OACmBphC,IAAzBohC,EAAWM,WACbkC,EAAaxC,EAAWM,UAE5B,EACAwE,UAAA,SAAUvgC,EAAcwgC,GACtB,IAAM57B,E1DxLL,SAA+B47B,GACpC,OAAOA,EJjFe,OIkFxB,C0DsL2BW,CAAsBX,GAAQA,EAAO96B,GAAQ+E,EAAY/F,UAAW87B,GACzFG,EAQN,SAAwB3gC,GACtB,IAAMohC,EAAYphC,EAAKpE,QAAQ,qBAAsB,KACjDwlC,IAAcphC,GAChBxH,EAAQF,KAAK,+BAAwB0H,EAAI,2BAAmBohC,IAE9D,OAAOA,CACT,CAdoBC,CAAerhC,IAAS4E,CACxC,EAEJ,CA0BA,SAASy7B,GAAgBL,GACvB,IAAMpd,EAAQod,EAAKtiC,QAAQ,KAC3B,OAAOklB,EAAQ,EAAIod,EAAOA,EAAKlhC,MAAM,EAAG8jB,EAC1C,CCnSO,SAAS0e,GACd9nB,EACAjL,EACAxG,EACAihB,EACA6V,EACA1J,EACAoM,EACAxC,GASA,OAPAvlB,EAAU7H,UAAU,GAAiC,SAAC8N,GACpD,OAAAjG,EAAUxH,OAAO,GAiBrB,SACEyN,EACA0V,EACAoM,GAEA,IAAMC,EAAcD,EAAYE,eAAehiB,EAAKD,IAC9CkiB,EAA6B,CACjCpuB,IAAK,CACHquB,iBAAkBliB,EAAKmhB,gBACvBgB,aAAcJ,GAEhB/6B,KAAMgZ,EAAKhV,YAAY/F,UACvBxH,KAAM,OACNuiB,KAAM,CACJE,OAAQ,CACN4V,MAAO9V,EAAK+I,YAAYI,aAE1BE,YAAa,CACXyM,MAAO9V,EAAK+I,YAAYK,kBAE1BgZ,wBAAyBpiB,EAAK6e,sBAC9BrnB,WAAY7R,EAAiBqa,EAAK8b,QAAQS,WAC1C8F,aAAc18B,EAAiBqa,EAAK8b,QAAQI,aAC5CoG,mBAAoB38B,EAAiBqa,EAAK8b,QAAQK,kBAClDoG,gBAAiB58B,EAAiBqa,EAAK8b,QAAQO,gBAC/CvjC,MAAO,CACLg9B,MAAO9V,EAAK+I,YAAYC,YAE1BwZ,uBAAwB78B,EAAiBqa,EAAK8b,QAAQe,sBACtD4F,kBAAmB98B,EAAiBqa,EAAK8b,QAAQ0B,iBACjDkF,iBAAkB/8B,EAAiBqa,EAAK8b,QAAQ2B,gBAChDkF,UAAW3iB,EAAKwhB,SAChBjhC,KAAMyf,EAAKzf,KACXqiC,yBAA0Bj9B,EAAiBqa,EAAK8b,QAAQuB,wBACxDwF,WAAYl9B,EAAiBqa,EAAK8b,QAAQQ,WAC1CzG,aAAciN,GAAwBn9B,EAAiBqa,EAAK2e,cAC5DoE,aAAc/iB,EAAK6d,YACnB9H,UAAW,CACTD,MAAO9V,EAAK+I,YAAYE,eAE1B+M,SAAU,CACRF,MAAO9V,EAAK+I,YAAYG,eAE1B8Z,WAAYr9B,EAAiBqa,EAAKpa,UAClCq9B,sBAAuBvN,EAAmB7T,6BAA6B7B,EAAKhV,YAAYhG,SAAUgb,EAAKpa,WAEzGyZ,QAAS,CACPgB,aAAY0hB,QAAqBnnC,IAGhCuE,EAAc6gB,EAAKkhB,iBACtBe,EAAUjiB,KAAKkjB,e/DwLZ,SAAyBtnC,EAA8BhC,GAE5D,IADA,IAAMupC,EAAkC,CAAC,EACvB,MAAAlqC,OAAO+F,KAAKpD,GAAZ,eAAqB,CAAlC,IAAMF,EAAG,KACZynC,EAAUznC,GAAO9B,EAAGgC,EAAOF,G,CAE7B,OAAOynC,CACT,C+D9LoCC,CAC9BpjB,EAAKkhB,cACLv7B,IAGJ,MAAO,CACLkZ,YAAaojB,EACbvrB,UAAWsJ,EAAKhV,YAAYhG,SAC5B8Z,cAAe,CACbxW,SAAU0X,EAAK1X,UAGrB,CA9EM+6B,CAAkBrjB,EAAM0V,EAAoBoM,GAF9C,IAMK3C,GACL72B,EACAyR,EACAwP,EACAza,EACAswB,GACCtwB,EAAcw0B,mBACfhE,EAEJ,CAmEA,SAASwD,GAAwBl9B,GAC/B,OAAO9G,EAAS8G,IAAaA,EAAW,OAAIhL,EAAYgL,CAC1D,CCnGA,IAgBI29B,GAhBEC,GAAuB,0BACvBC,GAA0B,IAEnBC,GAAsB,QAY7BC,GAAmC,GAGlC,SAASC,GAAqBC,EAAwBC,G,MAI3D,QAJ2D,IAAAA,MAAA,GACtDP,KACHA,GAAoBM,GAElBA,IAAeN,GAInB,GAAIO,GAnBoC,IAoBtCC,SADF,CAIA,IAAIC,EACAC,EAAiBC,KACrB,GAAIC,KAAuB,CAEzB,GAAIF,EAAeG,KAEjB,YADAC,GAAWR,EAAYC,GASzB,GALAE,EAAc,IACdC,EAAeG,KAAOJ,EACtBM,GAAWL,EAAgBJ,EAAWrpC,UAEtCypC,EAAiBC,MACEE,OAASJ,EAE1B,YADAK,GAAWR,EAAYC,E,CAI3B,IAAIS,EAAmBV,EAAWW,QAAQP,GAC1C,GAAIE,OAEFF,EAAiBC,MACEE,OAASJ,EAC1BK,GAAWR,EAAYC,OAJ3B,CAWA,GAHIS,GACFE,GAAeF,EAAkBV,EAAWrpC,SAE1C2pC,QAGII,IAAoBG,GAAeH,IAAoB,CAG3D,IADAN,EAAiBC,MACEE,OAASJ,EAE1B,YADAK,GAAWR,EAAYC,UAGlBG,EAAeG,KACtBE,GAAWL,EAAgBJ,EAAWrpC,SACtC+pC,EAAmBN,C,CAKP,QAAhB,EAAAJ,EAAW1f,aAAK,gBAAGogB,GAAoBN,GACvCF,I,OAxDEJ,GAAmBnlC,KAAKqlC,EAyD5B,CAMA,SAASM,KACP,QpB3FUrkC,OAAe6kC,QAAU,iBAAiBphC,KAAKzD,OAAO8kC,UAAUC,UoB4F5E,CAEA,SAASR,GAAWR,EAAwBiB,GAC1C3pC,WACE,GAAQ,WACNyoC,GAAqBC,EAAYiB,EAAyB,EAC5D,IAxF4B,GA2FhC,CAEA,SAASf,KACPR,QAAoB3oC,EACpB,IAAMmqC,EAAiBpB,GAAmBqB,QACtCD,GACFnB,GAAqBmB,EAEzB,CAEO,SAASN,GAAeplB,EAAuB7kB,GAChDkqC,GAAerlB,GA6CrB,SAAsB7kB,GACpBsM,GAAU48B,GAAqB,GAAI,EAAGlpC,EACxC,CA9CIyqC,CAAazqC,IAGf6kB,EAAQ6lB,OAASj8B,OAAO5D,IAAYud,IACpC0hB,GAAWjlB,EAAS7kB,GACtB,CAEA,SAAS8pC,GAAWjlB,EAAuB7kB,GACzCsM,GAAU48B,GAGL,SAAyBrkB,GAC9B,OAAO,EACUA,GACdpgB,KAAI,SAAC,G,IAACvD,EAAG,KAAEiB,EAAK,KAAM,gBAAGjB,EAAG,YAAIiB,EAAV,IACtBoG,KAAK0gC,GACV,CARiC0B,CAAgB9lB,GAAUuD,GAA0BpoB,EACrF,CASO,SAAS0pC,KACd,IAAMkB,EAAgBv+B,GAAU68B,IAC1BrkB,EAAwB,CAAC,EAU/B,OAGF,SAA8B+lB,GAC5B,YACoBxqC,IAAlBwqC,KACqD,IAApDA,EAAcnnC,QAAQwlC,KAAmCD,GAAqBjgC,KAAK6hC,GAExF,CAjBMC,CAAqBD,IACvBA,EAAcl8B,MAAMu6B,IAAyBjoC,SAAQ,SAAC+a,GACpD,IAAM/V,EAAUgjC,GAAqB9iC,KAAK6V,GAC1C,GAAgB,OAAZ/V,EAAkB,CACX,IAAA9E,EAAc8E,EAAO,GAAhB7D,EAAS6D,EAAO,GAC9B6e,EAAQ3jB,GAAOiB,C,CAEnB,IAEK0iB,CACT,CASA,SAASqlB,GAAerlB,GACtB,OAAO,EAAoBA,EAC7B,CC/HO,SAASimB,GACd9qC,EACA+qC,EACAC,GAEA,IAAMC,EAAkB,IAAI7yB,GACtB8yB,EAAmB,IAAI9yB,GAEvB+yB,EAAwB3iB,YAAY,GAiC1C,WACE4gB,GAAqB,CACnBppC,QAAO,EACPgqC,QAAS,SAACoB,GAAkB,OAAEC,EAAgBD,QAAsBhrC,EAAL,CAAC,CAApC,EAC5BupB,MAAO2hB,GAEX,I5D7EiC1rC,K4DuC7B2rC,EAkFJ,WACE,IAAM1mB,EAAU6kB,KAChB,GAAI2B,EAAgBxmB,GAClB,OAAOA,EAET,MAAO,CAAC,CACV,CAxFiC2mB,GAwCjC,SAASF,EAAmBF,GAW1B,OAVKC,EAAgBD,KACnBA,EAAgB,CAAC,GAEfK,OAwBN,SAAkCL,GAChC,OAAOG,EAAahmB,KAAO6lB,EAAc7lB,IAAMgmB,EAAaR,KAAgBK,EAAcL,EAC5F,CAzBQW,CAAyBN,GAG3BG,EAAeH,GAyBnBG,EAAe,CAAC,EAChBL,EAAiBnzB,WAvBVqzB,CACT,CAYA,SAASK,IACP,YAAoCrrC,IAA7BmrC,EAAaR,EACtB,CAwBA,SAASM,EAAgBxmB,GAGvB,YACuBzkB,IAApBykB,EAAQ8mB,SAAyB9gC,IAAYgU,OAAOgG,EAAQ8mB,SAAWxjB,WACpD/nB,IAAnBykB,EAAQ6lB,QAAwB7/B,IAAYgU,OAAOgG,EAAQ6lB,QAEhE,CAEA,MAAO,CACLkB,qBAAsB,EAAe,GAlGvC,WACE,IAAIC,EACJzC,GAAqB,CACnBppC,QAAO,EACPgqC,QAAS,SAACoB,GACR,IAAMU,EAAsBR,EAAmBF,GAE/C,OADAS,EA8CN,SAA6BT,GACrB,MAA8BJ,EAAoBI,EAAcL,IAA9DgB,EAAY,eAAEF,EAAS,YAC/BT,EAAcL,GAAcgB,EACxBF,IAAcT,EAAc7lB,KAC9B6lB,EAAc7lB,GAAK,IACnB6lB,EAAcO,QAAUl9B,OAAO5D,MAEjC,OAAOghC,CACT,CAtDkBG,CAAoBF,GACzBA,CACT,EACAniB,MAAO,SAACyhB,GACFS,IAAcJ,KAiExB,SAAsBL,GACpBG,EAAeH,EACfH,EAAgBlzB,QAClB,CAnEQk0B,CAAab,GAEfG,EAAeH,CACjB,GAEJ,I5DzDiCxrC,K4D2I0Da,UACzFyrC,cAjFF,WACE9C,GAAqB,CACnBppC,QAAO,EACPgqC,QAAS,SAACoB,GAAkB,OAACK,IAAsBH,EAAmBF,QAAiBhrC,CAA3D,GAEhC,EA6EE+rC,WAAY,WAAM,OAAAZ,CAAA,EAClBN,gBAAe,EACfC,iBAAgB,EAChBhkC,KAAM,WACJ+hB,cAAckiB,EAChB,EAEJ,CChIO,IAEHiB,GAAmC,GAEhC,SAASC,GACdrsC,EACA+qC,EACAC,ICbK,SAAgChrC,GACrC,IAAM4qC,EAAgBv+B,GAAU68B,IAC1BoD,EAAejgC,GAdgB,OAe/BkgC,EAAalgC,GAdc,SAe3BmgC,EAAcngC,GAdc,SAelC,IAAKu+B,EAAe,CAClB,IAAM/lB,EAAwB,CAAC,EAC3BynB,IACFznB,EAAQU,GAAK+mB,GAEXE,GAAe,SAASzjC,KAAKyjC,KAC/B3nB,EAAwB,KAAI2nB,GAE1BD,GAAc,UAAUxjC,KAAKwjC,KAC/B1nB,EAAuB,IAAI0nB,GAE7BtC,GAAeplB,EAAS7kB,E,CAE5B,CDHEysC,CAAuBzsC,GACvB,IAAM0sC,EAAe5B,GAAkB9qC,EAAS+qC,EAAYC,GAC5DoB,GAAcpoC,MAAK,WAAM,OAAA0oC,EAAaxlC,MAAb,IAEzB,IAoCQA,EApCFylC,EAAwB,IAAIpU,GAZEpQ,OA4BpC,SAASykB,IACP,MAAO,CACLrnB,GAAImnB,EAAaP,aAAa5mB,GAC9BwmB,aAAcW,EAAaP,aAAapB,GAE5C,CAEA,OAtBAqB,GAAcpoC,MAAK,WAAM,OAAA2oC,EAAsBzlC,MAAtB,IAEzBwlC,EAAazB,gBAAgBvzB,WAAU,WACrCi1B,EAAsBjjC,IAAIkjC,IAAuBthC,IACnD,IACAohC,EAAaxB,iBAAiBxzB,WAAU,WACtCi1B,EAAsB9jB,YAAYvd,IACpC,IAEAohC,EAAad,uBACbe,EAAsBjjC,IAAIkjC,IAAuBphC,KAAehB,UAyBxDtD,EAAS,EACf5B,OACA,CAAC,QAAD,kCAzBY,WAAM,OAAAonC,EAAad,sBAAb,GA2BlB,CAAE7kC,SAAS,EAAMC,SAAS,IAC3B,KACDolC,GAAcpoC,KAAKkD,GAGrB,SAAyBglC,GACvB,IAAMW,EAA2B,GAAQ,WACN,YAA7BtlC,SAAS45B,iBACX+K,GAEJ,IAEQhlC,EAAS,EAAuBK,SAAU,mBAAmCslC,GAAyB,KAC9GT,GAAcpoC,KAAKkD,GAEnB,IAAM4lC,EAA0BtkB,YAAYqkB,EApER,KAqEpCT,GAAcpoC,MAAK,WACjBilB,cAAc6jB,EAChB,GACF,CA7CEC,EAAgB,WAAM,OAAAL,EAAaR,eAAb,IASf,CACLc,kBAAmB,SAAC9wB,GAAc,OAAAywB,EAAsBxoC,KAAK+X,EAA3B,EAClC+uB,gBAAiByB,EAAazB,gBAC9BC,iBAAkBwB,EAAaxB,iBAEnC,CE9BO,SAAS+B,GAAuB34B,EAAiCiL,GACtE,IAAMiE,EAAiB6oB,GAAoB/3B,EAAciC,cA7B5B,OA6B4D,SAAC22B,GACxF,OAsDJ,SAA6B54B,EAAiC44B,GAC5D,IAAInB,EAQFA,EAQJ,SAA4BA,GAC1B,MACmB,MAAjBA,GACiB,MAAjBA,GACiB,MAAjBA,CAEJ,CArBMoB,CAAmBD,GACNA,EACLtrC,EAAY0S,EAAcyB,YAE1BnU,EAAY0S,EAAc84B,yBAGrB,IAFA,IAFA,IAMjB,MAAO,CACLrB,aAAY,EACZF,UAAWwB,GAActB,GAE7B,CArEIf,CAAoB12B,EAAe44B,EAAnC,IAWF,OARA1pB,EAAe0nB,iBAAiBxzB,WAAU,WACxC6H,EAAUxH,OAAO,EACnB,IAEAyL,EAAeynB,gBAAgBvzB,WAAU,WACvC6H,EAAUxH,OAAO,EACnB,IAEO,CACL+M,mBAAoB,SAAC5I,GACnB,IAAM2I,EAAUrB,EAAewpB,kBAAkB9wB,GACjD,GAAK2I,GAAYwoB,GAAcxoB,EAAQknB,cAAvC,CAGA,IAAM3mB,EACqB,MAAzBP,EAAQknB,aACJ,EACA,EACN,MAAO,CACLxmB,GAAIV,EAAQU,GACZH,KAAI,EACJkoB,qBAA+B,IAATloB,EACtBmoB,qBACmCntC,IAAjCkU,EAAck5B,eACVl5B,EAAck5B,eACdl5B,EAAcm5B,kBAA6B,IAATroB,EACxC6b,qBACmC7gC,IAAjCkU,EAAco5B,eACVp5B,EAAco5B,eACdp5B,EAAcm5B,kBAA6B,IAATroB,E,CAE5C,EAEJ,CA2CA,SAASioB,GAAcM,GACrB,MACqB,MAAnBA,GACmB,MAAnBA,CAEJ,CChHA,IAAMC,GAA6B,mBAEnC,cAME,WACUpe,EACA1Y,EACAJ,EACAK,EACAF,EACAg3B,QAAA,IAAAA,MAAA,GALA,KAAAre,UACA,KAAA1Y,qBACA,KAAAJ,kBACA,KAAAK,oBACA,KAAAF,eACA,KAAAg3B,uBAXF,KAAAC,eAA2B,GAC3B,KAAAC,aAA0C,CAAC,EAC3C,KAAAC,iBAAmB,EACnB,KAAAC,oBAAsB,EAU5B3uC,KAAK4uC,mBACL5uC,KAAK6uC,mBACP,CAkJF,OAhJE,YAAAzkC,IAAA,SAAIoG,GACFxQ,KAAK8uC,YAAYt+B,EACnB,EAEA,YAAAu+B,OAAA,SAAOv+B,EAAkB5O,GACvB5B,KAAK8uC,YAAYt+B,EAAS5O,EAC5B,EAEA,YAAAotC,MAAA,SAAMC,GACJ,QADI,IAAAA,MAASjvC,KAAKkwB,QAAQ9hB,MACO,IAA7BpO,KAAK2uC,oBAA2B,CAClC,IAAMO,EAAWlvC,KAAKwuC,eAAej6B,OAAOtP,EAAajF,KAAKyuC,eACxDU,EAAanvC,KAAK0uC,iBAExB1uC,KAAKwuC,eAAiB,GACtBxuC,KAAKyuC,aAAe,CAAC,EACrBzuC,KAAK0uC,iBAAmB,EACxB1uC,KAAK2uC,oBAAsB,EAE3BM,EAAO,CAAEv2B,KAAMw2B,EAASjmC,KAAK,MAAOkmC,WAAU,G,CAElD,EAEA,YAAAC,YAAA,WACEpvC,KAAKgvC,MAAMhvC,KAAKkwB,QAAQmf,WAC1B,EAEA,YAAAC,kBAAA,SAAkBrrC,GAEhB,OAAKqqC,GAA2B7kC,KAAKxF,QAIVnD,IAAvBkF,OAAOupC,aACF,IAAIA,aAAcC,OAAOvrC,GAAWW,OAGtC,IAAI6qC,KAAK,CAACxrC,IAAYu9B,KAPpBv9B,EAAUW,MAQrB,EAEQ,YAAAkqC,YAAR,SAAoBt+B,EAAkB5O,GAC9B,MAA0C5B,KAAK0qC,QAAQl6B,GAArDk/B,EAAgB,mBAAEC,EAAiB,oBACvCA,GAAqB3vC,KAAKyX,kBAC5BxY,EAAQF,KACN,kFAA2EiB,KAAKyX,kBAAiB,SAIjGzX,KAAK4vC,cAAchuC,IACrB5B,KAAKqK,OAAOzI,GAEV5B,KAAK6vC,0BAA0BF,IACjC3vC,KAAKgvC,QAGPhvC,KAAK0E,KAAKgrC,EAAkBC,EAAmB/tC,GAC3C5B,KAAK8vC,UACP9vC,KAAKgvC,QAET,EAEQ,YAAAtE,QAAR,SAAgBl6B,GACd,IAAMk/B,EAAmB9sC,EAAc4N,GAEvC,MAAO,CAAEk/B,iBAAgB,EAAEC,kBADD3vC,KAAKsvC,kBAAkBI,GAEnD,EAEQ,YAAAhrC,KAAR,SAAagrC,EAA0BC,EAA2B/tC,GAC5D5B,KAAK2uC,oBAAsB,IAE7B3uC,KAAK0uC,kBAAoB,QAEf5tC,IAARc,EACF5B,KAAKyuC,aAAa7sC,GAAO8tC,EAEzB1vC,KAAKwuC,eAAe9pC,KAAKgrC,GAE3B1vC,KAAK0uC,kBAAoBiB,EACzB3vC,KAAK2uC,qBAAuB,CAC9B,EAEQ,YAAAtkC,OAAR,SAAezI,GACb,IAAMmuC,EAAiB/vC,KAAKyuC,aAAa7sC,UAClC5B,KAAKyuC,aAAa7sC,GACzB,IAAM+tC,EAAoB3vC,KAAKsvC,kBAAkBS,GACjD/vC,KAAK0uC,kBAAoBiB,EACzB3vC,KAAK2uC,qBAAuB,EACxB3uC,KAAK2uC,oBAAsB,IAC7B3uC,KAAK0uC,kBAAoB,EAE7B,EAEQ,YAAAkB,cAAR,SAAsBhuC,GACpB,YAAed,IAARc,QAAgDd,IAA3Bd,KAAKyuC,aAAa7sC,EAChD,EAEQ,YAAAiuC,0BAAR,SAAkCF,GAEhC,OAAO3vC,KAAK0uC,iBAAmBiB,EAAoB,GAAK3vC,KAAKoX,eAC/D,EAEQ,YAAA04B,OAAR,WACE,OAAO9vC,KAAK2uC,sBAAwB3uC,KAAKwX,oBAAsBxX,KAAK0uC,kBAAoB1uC,KAAKoX,eAC/F,EAEQ,YAAAy3B,kBAAR,sBACExtC,WACE,GAAQ,WACN,EAAK2tC,QACL,EAAKH,mBACP,IACA7uC,KAAKuX,aAET,EAEQ,YAAAq3B,iBAAR,sBAKM9D,UAAUkF,aAMZ9oC,EAAiBlB,OAAQ,eAAyBhG,KAAKuuC,sBAMvDrnC,EAAiBe,SAAU,oBAA6B,WACrB,WAA7BA,SAAS45B,iBACX,EAAKuN,aAET,IAMAloC,EAAiBlB,OAAQ,gBAAyB,WAAM,SAAKopC,aAAL,IAE5D,EACF,EAlKA,GCAaa,GAAwB,QAyB9B,SAASC,GACdC,EACAnlB,EACAolB,EACAx8B,EACA2Q,GAG4B,IAA1ByG,EAAMqlB,iBAC0B,IAAhCrlB,EAAMslB,eAAe9O,QACrBxW,EAAMulB,iBAAiBC,UAAUL,GAEjC/hC,GAAK+hC,EAASnlB,EAAOolB,EAAc,CACjCK,UAAW,WAAM,OAAAC,GAAoB,EAA2B1lB,EAAOolB,EAAcx8B,EAAc2Q,EAAlF,EACjBosB,UAAW,WACT3lB,EAAMslB,eAAeM,QAAQT,GAC7BU,GAAc7lB,EAAOolB,EAAcx8B,EAAc2Q,EACnD,IAGFyG,EAAMslB,eAAeM,QAAQT,EAEjC,CAEA,SAASU,GACP7lB,EACAolB,EACAx8B,EACA2Q,GAE8B,IAA1ByG,EAAMqlB,iBAGVhvC,WACE,GAAQ,WAEN+M,GADgB4c,EAAMslB,eAAeve,QACvB/G,EAAOolB,EAAc,CACjCK,UAAW,WACTzlB,EAAMslB,eAAeQ,UACrB9lB,EAAM+lB,mBA9DoBzwC,IA+D1BowC,GAAoB,EAA0B1lB,EAAOolB,EAAcx8B,EAAc2Q,EACnF,EACAosB,UAAW,WACT3lB,EAAM+lB,mBAAqB7uC,KAAK8uC,IAnEVzwC,IAmE2D,EAA3ByqB,EAAM+lB,oBAC5DF,GAAc7lB,EAAOolB,EAAcx8B,EAAc2Q,EACnD,GAEJ,IACAyG,EAAM+lB,mBAEV,CAEA,SAAS3iC,GACP+hC,EACAnlB,EACAolB,EACA,G,IAAEK,EAAS,YAAEE,EAAS,YAEtB3lB,EAAMulB,iBAAiBnmC,IAAI+lC,GAC3BC,EAAaD,GAAS,SAAClkB,GACrBjB,EAAMulB,iBAAiBlmC,OAAO8lC,IAmClC,SAA4BlkB,GAC1B,OAA2B,IAApBA,EAASzR,QAAoC,MAApByR,EAASzR,QAAsC,MAApByR,EAASzR,QAAkByR,EAASzR,QAAU,GAC3G,CApCSy2B,CAAmBhlB,IACtBjB,EAAMqlB,gBAAkB,EACxBI,MAGAzlB,EAAMqlB,gBACJrlB,EAAMulB,iBAAiBW,oBAAsB,EAAI,EAAmC,EACtFP,IAEJ,GACF,CAEA,SAASD,GACP1T,EACAhS,EACAolB,EACAx8B,EACA2Q,GAEe,IAAXyY,GAAwChS,EAAMslB,eAAeR,WAAa9kB,EAAMmmB,oBAClF5sB,EAAY,CACV/T,QAAS,sBAAeoD,EAAY,2CAAmCq8B,EAAqC,OAC5GtuC,OAAQkP,GACRK,YAAajF,MAEf+e,EAAMmmB,mBAAoB,GAE5B,IAAMC,EAAgBpmB,EAAMslB,eAE5B,IADAtlB,EAAMslB,eAAiBe,KAChBD,EAAc5P,OAAS,GAC5B0O,GAAsBkB,EAAcN,UAAY9lB,EAAOolB,EAAcx8B,EAAc2Q,EAEvF,CAgBA,SAAS8sB,KACP,IAAMC,EAAmB,GACzB,MAAO,CACLnC,WAAY,EACZyB,QAAA,SAAQT,GACFnwC,KAAK8vC,WAGTwB,EAAM5sC,KAAKyrC,GACXnwC,KAAKmvC,YAAcgB,EAAQhB,WAC7B,EACApd,MAAK,WACH,OAAOuf,EAAM,EACf,EACAR,QAAO,WACL,IAAMX,EAAUmB,EAAMpG,QAItB,OAHIiF,IACFnwC,KAAKmvC,YAAcgB,EAAQhB,YAEtBgB,CACT,EACA3O,KAAI,WACF,OAAO8P,EAAM1sC,MACf,EACAkrC,OAAM,WACJ,OAAO9vC,KAAKmvC,YAAcc,EAC5B,EAEJ,CCjJO,SAASsB,GACdC,EACAC,EACAltB,GAEA,IAAMmtB,EDuGC,CACLrB,gBAAiB,EACjBU,mBA7HgCzwC,IA8HhCiwC,iBAqCK,CACLW,oBAAqB,EACrBS,iBAAkB,EAClBnB,UAAA,SAAUL,GACR,OAC+B,IAA7BnwC,KAAKkxC,qBACJlxC,KAAK2xC,iBAAmBxB,EAAQhB,YA7KF,OA8K7BnvC,KAAKkxC,oBA7KqB,EA+KhC,EACA9mC,IAAA,SAAI+lC,GACFnwC,KAAKkxC,qBAAuB,EAC5BlxC,KAAK2xC,kBAAoBxB,EAAQhB,UACnC,EACA9kC,OAAA,SAAO8lC,GACLnwC,KAAKkxC,qBAAuB,EAC5BlxC,KAAK2xC,kBAAoBxB,EAAQhB,UACnC,GArDAmB,eAAgBe,KAChBF,mBAAmB,GC3GfS,EAAuB,SAACzB,EAAkB0B,GAC9C,OA2CG,SACLL,EACAC,EACA,EACAI,G,IADEn5B,EAAI,OAAEy2B,EAAU,aAGZp/B,EAAMyhC,EAAgBn9B,SAe9B,WAEE,IACE,OAAOrO,OAAOmoB,SAAW,cAAe,IAAIA,QAAQ,W,CACpD,SACA,OAAO,C,CAEX,EArB0B2jB,IAA0B3C,EAAasC,EAE7D/lB,MAAM3b,EAAK,CAAE+Z,OAAQ,OAAQ3W,KAAMuF,EAAMq5B,WAAW,IAAQzlB,KAC1D,GAAQ,SAACL,GAAuB,OAAA4lB,aAAU,EAAVA,EAAa,CAAEr3B,OAAQyR,EAASzR,QAAhC,IAChC,GAAQ,WAENw3B,GAAQjiC,EAAK2I,EAAMm5B,EACrB,KAGFG,GAAQjiC,EAAK2I,EAAMm5B,EAEvB,CA9DII,CAAuBT,EAAiBC,EAAYtB,EAAS0B,EAA7D,EAEF,MAAO,CACLzjC,KAAM,SAAC+hC,GACLD,GAAsBC,EAASuB,EAAYE,EAAsBJ,EAAgB59B,aAAc2Q,EACjG,EAKA8qB,WAAY,SAACc,IAMjB,SAA4BqB,EAAkCC,EAAoB,G,IAAE/4B,EAAI,OAAEy2B,EAAU,aAC5Fp/B,EAAMyhC,EAAgBn9B,QAE5B,GADuBy2B,UAAUkF,YAAcb,EAAasC,EAE1D,IAGE,GAFiB3G,UAAUkF,WAAWjgC,EAAK2I,GAGzC,M,CAEF,MAAOtY,IAUb,SAA2BA,GACpB8xC,KACHA,IAAyB,EACzB93B,GAAkBha,GAEtB,CAdM+xC,CAAkB/xC,E,CAItB4xC,GAAQjiC,EAAK2I,EACf,CArBM05B,CAAmBZ,EAAiBC,EAAYtB,EAClD,EAEJ,CAoBA,IAAI+B,IAAyB,EAuCtB,SAASF,GAAQjiC,EAAa2I,EAAuBm5B,GAC1D,IAAM3hB,EAAU,IAAIxF,eACd2nB,EAAY,GAAQ,WAGxBniB,EAAQroB,oBAAoB,UAAWwqC,GACvCR,WAAa,CAAEr3B,OAAQ0V,EAAQ1V,QACjC,IACA0V,EAAQoiB,KAAK,OAAQviC,GAAK,GAC1BmgB,EAAQhpB,iBAAiB,UAAWmrC,GACpCniB,EAAQ9hB,KAAKsK,EACf,CC9GO,SAAS65B,GACdv9B,EACAiL,EACAuyB,EACAjuB,GAEA,IAAMkuB,EAkBR,SACEz9B,EACAiL,EACAsE,GAEA,IAIImuB,EAJEC,EAAeC,EAAe59B,EAAcQ,oBAAoB,WACpE,OAAAyK,EAAUxH,OAAO,EAAjB,IAII3C,EAAUd,EAAcc,aACdhV,IAAZgV,IACF48B,EAAeE,EAAe98B,EAAQN,qBAGxC,SAASo9B,EAAepB,EAAkCqB,GACxD,OAAO,IAAIC,GACTvB,GAAkBC,EAAiBx8B,EAAcoC,gBAAiBmN,GAClEvP,EAAcwC,mBACdxC,EAAcoC,gBACdpC,EAAcyC,kBACdzC,EAAcuC,aACds7B,EAEJ,CAEA,SAASE,EAAyBviC,GAChC,OAAOpH,EAAQoH,EAAS,CAAEwV,YAAa,CAAEC,GAAInQ,EAASE,gBACxD,CAEA,MAAO,CACL5L,IAAK,SAACoG,EAAkBwiC,QAAA,IAAAA,OAAA,GACtBL,EAAavoC,IAAIoG,GACbkiC,GAAgBM,GAClBN,EAAatoC,IAAI2oC,EAAyBviC,GAE9C,EACAu+B,OAAQ,SAACv+B,EAAkB5O,GACzB+wC,EAAa5D,OAAOv+B,EAAS5O,GACzB8wC,GACFA,EAAa3D,OAAOgE,EAAyBviC,GAAU5O,EAE3D,EAEJ,CA9DgBqxC,CAAaj+B,EAAeiL,EAAWsE,GAErDtE,EAAU7H,UAAU,IAAwC,SAACwN,GAC/B,SAAxBA,EAAejiB,KACjB8uC,EAAM1D,OAAOnpB,EAAgBA,EAAeM,KAAKD,IAEjDwsB,EAAMroC,IAAIwb,EAEd,IAEA4sB,EAAyBp6B,WAAU,SAAChR,GAAU,OAAAqrC,EAAMroC,IAAIhD,ErD0FnD,SAAuC4N,GAC5C,MPnHiC,gBOmH1BA,EAAclB,IACvB,CqD5FiEo/B,CAA8Bl+B,GAA/C,GAChD,CCZO,SAASm+B,GAA+B3kC,GAC7C,IAAI+3B,EAAkB1kC,EAAa2M,GAC7ByK,EAAa,IAAIH,IAA2B,WACxC,IAuBUs6B,EACNC,EAGAC,EAGAC,EAWGC,EAzCDC,GAuBIL,EAvBiCM,EAwBvCL,EAA+BlpB,GAAgC6O,QAAS,YAAa,CACjG3O,MAAO+oB,IACP,KACYE,EAAkCnpB,GAAgC6O,QAAS,eAAgB,CACvG3O,MAAO+oB,IACP,KACYG,EAAmBrsC,EAAiBlB,OAAQ,WAAqBotC,GAAgB,KAExF,CACLxrC,KAAM,WACJyrC,IACAC,IACAC,GACF,IArCoE,KACtDI,GAwCCH,EAxC8BE,EAyCxCxsC,EAAiBlB,OAAQ,aAAuBwtC,IAzCS,KAC9D,OAAO,WACLC,IACAE,GACF,CACF,IAEA,SAASD,IACP,GAAInN,EAAgBj0B,OAAS9D,EAAS8D,KAAtC,CAGA,IAAMs0B,EAAc/kC,EAAa2M,GACjCyK,EAAWR,OAAO,CAChBmuB,YAAW,EACXD,YAAaJ,IAEfA,EAAkBK,C,CACpB,CAEA,OAAO3tB,CACT,CCTO,ICMyDrQ,GAAgBnC,GAAYvH,GACpF00C,GDPKC,GEsBN,SACLC,EACA9L,EACA,G,IAAE,QAAF,MAAsE,CAAC,EAAC,GAAtE+L,2CAAmC,IAAG,GAAI,EAExCC,GAAuB,EAErBC,EAAuB9pC,IACvB+pC,EAAqB/pC,IAEvBgqC,EAAmE,WAAM,EACzEC,EAA+B,WAAqC,EAEpEC,EAAiB,IAAIC,EACrBC,EAAiD,SAAC9tC,EAAMwgC,QAAA,IAAAA,MAAOl7B,KACjEsoC,EAAejqC,KAAI,WAAM,OAAAmqC,EAAkB9tC,EAAMwgC,EAAxB,GAC3B,EACIuN,EAAiD,SAAC9zC,EAASwQ,QAAA,IAAAA,MAAcjF,KAC3EooC,EAAejqC,KAAI,WAAM,OAAAoqC,EAAkB9zC,EAASwQ,EAA3B,GAC3B,EACIujC,EAAiD,SACnDruB,EACAX,QAAA,IAAAA,MAAA,CACEvlB,QAAS+zC,EAAqB1pC,aAC9Bkc,KAAMytB,EAAmB3pC,eAG3B8pC,EAAejqC,KAAI,WAAM,OAAAqqC,EAAkBruB,EAAQX,EAA1B,GAC3B,EACIivB,EAA+C,SACjDC,EACAlvB,QAAA,IAAAA,MAAA,CACEvlB,QAAS+zC,EAAqB1pC,aAC9Bkc,KAAMytB,EAAmB3pC,eAG3B8pC,EAAejqC,KAAI,WAAM,OAAAsqC,EAAiBC,EAAelvB,EAAhC,GAC3B,EA6CA,SAASmvB,EACPjhC,EACAqB,EACAwwB,GAEA,IAAMqP,EAAkBf,EACtBngC,EACAqB,GACA,WAAM,OACJyR,KAAMytB,EAAmB3pC,aACzBrK,QAAS+zC,EAAqB1pC,aAC9Bic,YAAWwhB,EAAY8M,oBAAuBh0C,EAH1C,GAKNknC,EACAxC,GAIWgP,EAKTK,EAAe,UAJNJ,EAITI,EAAe,UAHPH,EAGRG,EAAe,SAFNN,EAETM,EAAe,UADGV,EAClBU,EAAe,mBACnBR,EAAerpC,QAEfg9B,EAAY+M,WACVF,EAAgB50B,UAChBjL,EACA6/B,EAAgBtvB,QAChBsvB,EAAgB1wB,aAEpB,CAEA,ID/J+B6wB,EACzBC,EC8JA/N,EAGF,GAAQ,SAACxmC,GAEX8zC,EAD4C,iBAAZ9zC,EAAuBA,EAAU,CAAE+F,KAAM/F,GAE3E,IAEMw0C,GDvKyBF,ECuKI,CACjCnpB,KAAM,GAtFR,SAAiBlY,GAKf,IAAIogC,IAAuCnmC,KAA3C,CAIA,GAAIU,KACFqF,EA6LJ,SAAyEA,GACvE,OAAO,EAAO,CAAC,EAAGA,EAAmB,CACnCqC,cAAe,uCACfjC,YAAa,QACb0C,WAAY,KAEhB,CAnMwB0+B,CAAmCxhC,QAClD,IAqKT,SAA0BA,GACxB,OvE3NG,SAA8BjT,GACnC,GAAMiM,IAAuBG,GAC3B,OAAO,EAET,QAAwBhM,IAApBmH,SAASyF,QAA4C,OAApBzF,SAASyF,OAC5C,OAAO,EAET,IAGE,IAAMoK,EAAiB,yBAAkB/V,KACnCqzC,EAAkB,OACxBpoC,GAAU8K,EAAgBs9B,EAAiB90C,EAAYI,GACvD,IAAM20C,EAAuBtoC,GAAU+K,KAAoBs9B,EAE3D,OADAznC,GAAamK,EAAgBpX,GACtB20C,C,CACP,MAAOr2C,GAEP,OADAC,EAAQD,MAAMA,IACP,C,CAEX,CuEuMSs2C,CAAqBp+B,GAAmBvD,IA+BT,UAA7B3N,OAAOwI,SAASlI,WAzBrBrH,EAAQD,MAAM,qDACP,IANPC,EAAQF,KAAK,2DACN,EAQX,CAhLcw2C,CAAiB5hC,GAC3B,OAGF,GA8KF,SAAoBA,GAClB,OAAIqgC,IACGrgC,EAAkBwD,oBACrBlY,EAAQD,MAAM,mCAET,EAGX,CAtLOw2C,CAAW7hC,GAAhB,CAIA,IAAMqB,ECzCH,SACLrB,G,cAEA,GAAKA,EAAkBqC,cAKvB,QACgDlV,IAA9C6S,EAAkBm6B,yBACjB/oC,EAAa4O,EAAkBm6B,yBAFlC,CASA,IAAI2H,EAAuD,QAAnC,EAAA9hC,EAAkB8hC,yBAAiB,QAAI9hC,EAAkB+hC,iBAMjF,QAL0B50C,IAAtB20C,QAAiF30C,IAA9C6S,EAAkBm6B,0BACvD7uC,EAAQF,KAAK,0EACb02C,OAAoB30C,QAGIA,IAAtB20C,GAAoC1wC,EAAa0wC,GAKrD,QAA4C30C,IAAxC6S,EAAkBsZ,mBAAoCloB,EAAa4O,EAAkBsZ,mBAAzF,CAKA,QAAgDnsB,IAA5C6S,EAAkBmZ,sBAAqC,CACzD,IAAKzpB,MAAM8E,QAAQwL,EAAkBmZ,uBAEnC,YADA7tB,EAAQD,MAAM,8CAGhB,GAAuD,IAAnD2U,EAAkBmZ,sBAAsBloB,aAA8C9D,IAA9B6S,EAAkBuB,QAE5E,YADAjW,EAAQD,MAAM,wD,CAKlB,QAA+C8B,IAA3C6S,EAAkBqd,sBAAuC3tB,MAAM8E,QAAQwL,EAAkBqd,sBAA7F,CAKA,IAAM2kB,EAAoBn/B,GAA8B7C,GACxD,GAAKgiC,EAAL,CAIA,I7E+ImE7zC,EAAWe,E6E/IxE82B,IAAsBhmB,EAAkBgmB,kBAE9C,OAAO,EACL,CACE3jB,cAAerC,EAAkBqC,cACjCb,QAASxB,EAAkBwB,QAC3BigB,oBAAqBzhB,EAAkByhB,oBACvC0Y,wBAAuF,QAA9D,EAAyC,QAAzC,EAAAn6B,EAAkBm6B,+BAAuB,QAAI2H,SAAiB,QAAI,IAC3FtH,sBAAgErtC,IAA9C6S,EAAkBm6B,wBACpChhB,sBAA8D,QAAvC,EAAAnZ,EAAkBmZ,6BAAqB,QAAI,GAClEG,kBAAmBtZ,EAAkBsZ,kBACrC+D,qBAA4D,QAAtC,EAAArd,EAAkBqd,4BAAoB,QAAI,GAChE4kB,oBAAqBjiC,EAAkBiiC,mBAAqBjc,EAC5DA,kBAAiB,EACjB6P,qBAAsB71B,EAAkB61B,mBACxC4E,eAAgBz6B,EAAkBy6B,eAClCF,eAAgBv6B,EAAkBu6B,eAClC2H,qB7E8H+D/zC,E6E9H3BsU,G7E8HsCvT,E6E9HjB8Q,EAAkBkiC,oB7E+HxE12C,OAAO+F,KAAKpD,GAAQ0H,MAAK,SAAC5H,GAAQ,OAAAE,EAAOF,KAASiB,CAAhB,I6E9HjC8Q,EAAkBkiC,oBAClBz/B,GAAoBG,kBAE1Bo/B,E,OA9BA12C,EAAQD,MAAM,4C,MAhBdC,EAAQD,MAAM,iEALdC,EAAQD,MAAM,2D,MAZdC,EAAQD,MAAM,wEARdC,EAAQD,MAAM,mEAyElB,CDpC0B82C,CAAiCniC,GACvD,GAAKqB,EAAL,CAIA,GAAKA,EAAcw0B,mBAEZ,CAIL,IAAMuM,EAAkB1B,EACxBA,EAAiB,IAAIC,EAErBE,EAAoB,SAAC9zC,GACnBk0C,EAAWjhC,EAAmBqB,EAAetU,EAC/C,EACAq1C,EAAgB/qC,O,MAXhB4pC,EAAWjhC,EAAmBqB,GAahCo/B,EAA+B,WAAM,OAAAjrC,EAA6BwK,EAA7B,EAErCqgC,GAAuB,C,GACzB,IAgDEgC,oBAAqB,EAAQ/B,EAAqB7pC,KAClD6rC,yBAA0B,EAAQhC,EAAqBxpC,oBAGvDyrC,uBAAwB,EAAQjC,EAAqB5pC,QACrD8rC,4BAA6B,EAAQlC,EAAqBtpC,uBAG1DyrC,oBAAqB,EAAQnC,EAAqBtuC,KAClD0wC,iBAAkB,EAAQpC,EAAqB1pC,YAG/C+rC,oBAAqB,EAAQrC,EAAqB3rC,KAClDiuC,iBAAkB,EAAQtC,EAAqBzpC,YAE/CgsC,mBAAoB,EAAQvC,EAAqBrpC,cAEjD6rC,mBAAoB,GAAQ,SAAC75B,GAAuB,OAAAu3B,EAA2Bv3B,EAA3B,IACpD85B,qBAAsB,GAAQ,WAAM,OAAAtC,GAAA,IAEpCuC,UAAW,GAAQ,SAAClwC,EAAcvG,GAChCu0C,EAAkB,CAChBhuC,KAAI,EACJvG,QAASiJ,EAAUjJ,GACnBgR,YAAajF,IACbtI,KAAM,UAEV,IAEA+7B,SAAU,SAAC1gC,EAAgBkB,GACzB,IAAM+Q,EAAgBW,KACtB7R,GAAc,WACZ20C,EAAiB,CACf11C,MAAK,EACLiS,cAAa,EACb/Q,QAASiJ,EAAUjJ,GACnBgR,YAAajF,KAEjB,GACF,EAEA+6B,UAAW,GAAQ,SAACvgC,EAAcwgC,GAChCsN,EAAkB9tC,EAAMwgC,EAC1B,IAEA2P,QAAS,GAAQ,SAACC,GACO,iBAAZA,GAAyBA,EAGlC3C,EAAmB1pC,WAAWssC,EAAaD,IAF3C53C,EAAQD,MAAM,oBAAqB63C,EAIvC,IAEAE,QAAS,EAAQ7C,EAAmB3pC,YAEpCysC,gBAAiB,GAAQ,SAACp1C,EAAK8I,G,MACvBusC,EAAoBH,GAAY,KAAG,EAACl1C,GAAM8I,EAAQ,IAAI9I,GAC5DsyC,EAAmBzpC,mBAAmB7I,EAAKq1C,EAC7C,IAEAC,mBAAoB,EAAQhD,EAAmBvpC,uBAG/CwsC,WAAY,EAAQjD,EAAmBtpC,cACvCwsC,UAAW,EAAQlD,EAAmBtpC,cAEtCs8B,UAAS,EAETmQ,4BAA6B,EAAQrP,EAAY57B,OACjDkrC,2BAA4B,EAAQtP,EAAYpgC,OD/O5CqtC,EAAY,EAChB,CACE9/B,QAAS,MAKToiC,QAAA,SAAQvvC,GACNA,GACF,GAEFgtC,GAKF71C,OAAOuG,eAAeuvC,EAAW,YAAa,CAC5CtvC,IAAG,WACD,OAAO/F,CACT,EACA43C,YAAY,IAGPvC,GC0NP,OAAOC,EAEP,SAAS4B,EAAaD,GACpB,IAAMY,EAAoB,EAAOZ,EAAS,CAAC,GAU3C,MATI,OAAQY,IACVA,EAAkBxxB,GAAK9W,OAAOsoC,EAAkBxxB,KAE9C,SAAUwxB,IACZA,EAAkBhxC,KAAO0I,OAAOsoC,EAAkBhxC,OAEhD,UAAWgxC,IACbA,EAAkBC,MAAQvoC,OAAOsoC,EAAkBC,QAE9CD,CACT,CAoCF,CF/Q0BE,EIMnB,SACLhkC,EACAqB,EACAsP,EACA0jB,EACAxC,GAEA,IAAMvlB,EAAY,IAAI23B,GAEhB39B,EA8ER,SAA2BjF,GACzB,IAAMiF,EAAYL,GAAe,kBAAsB5E,GACvD,GAAI1G,KAAqB,CACvB,IAAM,EAASP,KACfkM,EAAUhB,WAAWb,WAAU,SAAChR,GAAU,SAAOgH,KAAK,qBAAsBhH,EAAlC,G,CAE5C,OAAO6S,CACT,CArFoB49B,CAAkB7iC,GACpCiF,EAAUI,oBAAmB,W,QAAM,OACjC2L,YAAa,CACXC,GAAIjR,EAAcgB,eAEpBuP,QAAS,CACPU,GAAgC,QAA5B,EAAAV,EAAQC,4BAAoB,eAAES,IAEpCC,KAAM,CACJD,GAA2B,QAAvB,EAAA9B,EAAaiB,kBAAU,eAAEa,IAE/BG,OAAQ,CACNH,GAAI5B,EAAesB,gB,IAIvB,IAAMpB,EAAc,SAACvlB,GACnBihB,EAAUxH,OAAO,GAAwC,CAAEzZ,MAAK,GAClE,EACKsP,KCxDA,SAA6B2R,GAClC,IAAMvR,EAASX,KAEfkS,EAAU7H,UAAU,IAAwC,SAACwN,GAC3DlX,EAAON,KAAK,MAAOwX,EACrB,GACF,CDqDIkyB,CAAoB73B,GAFpBsyB,GAAcv9B,EAAeiL,EAAWhG,EAAUhB,WAAYsL,GAKhE,IAAMgB,EAAWjX,KVSZ,WACL,IAAMiX,EAAsB,CAC1BU,GAAI,uCACJH,KAAM,EACNkoB,sBAAsB,EACtBC,iBAAiB,EACjBtM,iBAAiB,GAEnB,MAAO,CACLnc,mBAAoB,WAAM,OAAAD,CAAA,EAE9B,CUpB4FwyB,GAAnDpK,GAAuB34B,EAAeiL,GACvEwP,EAAwB5U,KACxByqB,EAA2B6N,GAA+B3kC,UAE1D,EA0DD,SACLyR,EACAjL,EACAxG,EACA0V,EACAohB,EACA7V,EACAnL,EACAC,GAEA,IAAMJ,EExHD,SAA2BlE,GAChC,IAAM+3B,EAAqB,IAAI/e,GAfUpQ,OAsCzC,OArBA5I,EAAU7H,UAAU,GAAiC,SAAC8N,GACpD8xB,EAAmB5tC,IAWrB,SAA0B8b,GACxB,MAAO,CACLhR,QAASgR,EAAKhR,QACdC,QAAS+Q,EAAK/Q,QACd8Q,GAAIC,EAAKD,GACTxf,KAAMyf,EAAKzf,KAEf,CAlByBwxC,CAAiB/xB,GAAOA,EAAKhV,YAAYhG,SAClE,IAEA+U,EAAU7H,UAAU,GAA+B,SAAC,G,IAAE0iB,EAAS,YAC7Dkd,EAAmBzuB,YAAYuR,EAAU5vB,SAC3C,IAEA+U,EAAU7H,UAAU,GAAoC,WACtD4/B,EAAmBtuB,OACrB,IAWO,CACLtE,SAAU,SAACxI,GAAc,OAAAo7B,EAAmBnzC,KAAK+X,EAAxB,EACzBhV,KAAM,WACJowC,EAAmBpwC,MACrB,EAEJ,CF0FuBswC,CAAkBj4B,GACjCmE,EGrHD,SACLnE,EACAqlB,EACA92B,GAEA,IAEI2pC,EAFEC,EAAoB,IAAInf,GAjBUpQ,OAqBxC5I,EAAU7H,UAAU,GAA+B,SAAC,G,IAAE0iB,EAAS,YAC7Dsd,EAAkB7uB,YAAYuR,EAAU5vB,SAC1C,IAEA+U,EAAU7H,UAAU,GAAiC,SAAC,G,IAAElH,EAAW,cAC3DmnC,EAAU7pC,EAAS8D,KACzB8lC,EAAkBhuC,IAChBkuC,EAAgB,CACdvoC,IAAKsoC,EACLlyB,SAAWgyB,GAAkBlwC,SAASke,WAExCjV,EAAYhG,UAEditC,EAAkBE,CACpB,IAEA,IAAM5S,EAA6BH,EAAyBltB,WAAU,SAAC,G,IAAEwuB,EAAW,cAC5EtkB,EAAU81B,EAAkBvzC,OAClC,GAAIyd,EAAS,CACX,IAAMi2B,EAAavsC,IACnBosC,EAAkB7uB,YAAYgvB,GAC9BH,EAAkBhuC,IAChBkuC,EAAgB,CACdvoC,IAAK62B,EAAYt0B,KACjB6T,SAAU7D,EAAQ6D,WAEpBoyB,E,CAGN,IAEA,SAASD,EAAgB,GACvB,MAAO,CACLvoC,IAF0B,MAG1BoW,SAHoC,WAKxC,CAEA,MAAO,CACLb,QAAS,SAAC1I,GAA6B,OAAAw7B,EAAkBvzC,KAAK+X,EAAvB,EACvChV,KAAM,WACJ69B,EAA2BltB,cAC3B6/B,EAAkBxwC,MACpB,EAEJ,CH+DsB4wC,CAAiBv4B,EAAWqlB,EAA0B92B,GACpEotB,EAAqBvU,KACrB,E7BxHD,SACLpH,EACAwP,EACAza,EACA4mB,GAEA3b,EAAU7H,UAAU,GAA0C,SAACgO,GAC7D,OAAAnG,EAAUxH,OAAO,GAA4CkjB,GAAcvV,EAAQwV,GAAnF,IAGF,IAAIvX,EAAiC,CAAEsB,aAAc,GAKrD,OAJI3Q,EAAc4gC,oBAChBvxB,EAAiByU,GAAkB7Y,EAAWwP,EAAuBza,GAAeqP,gBAG/E,CACLsyB,UAAW,SAACvwB,EAAsBnB,GAChChF,EAAUxH,OAAO,GAEf,EACE,CACEwM,mBAAkB,GAEpB0W,GAAcvV,EAAQwV,IAG5B,EACAvX,eAAc,EAElB,C6B2FwCo0B,CACpCx4B,EACAwP,EACAza,EACA4mB,GAJM+a,EAAS,YAAEtyB,EAAc,iBAkBjC,OAXAJ,GACEjP,EACAiL,EACAiE,EACAC,EACAC,EACAC,EACAC,EACAC,GAGK,CACLJ,aAAY,EACZyX,mBAAkB,EAClBxX,YAAW,EACXuyB,UAAS,EACTtyB,eAAc,EACdzc,KAAM,WACJuc,EAAavc,OACbg0B,EAAmBh0B,MACrB,EAEJ,CApGuF8wC,CACnFz4B,EACAjL,EACAxG,SACA+W,EACA+f,EACA7V,EACAnL,EACAC,GARMJ,EAAY,eAAEyX,EAAkB,qBAAExX,EAAW,cAAEC,EAAc,iBAAEsyB,EAAS,a3DwE3E,SAAmC3hC,GACpCuE,GAAuBI,+BACzBY,GAAa,CACX5W,KAAMyV,GACNpE,cAAa,GAGnB,C2DrEE2jC,CDgEK,SAAmC3jC,GACxC,IAAM4jC,E7DkBD,SAAgC5jC,GACrC,MAAO,CACL6jC,oBAAqB7jC,EAAcyB,WACnCqiC,sBAAuB9jC,EAAc0B,oBACrCqiC,oCAAqC/jC,EAAc2B,iCACnDqiC,kBAAmBhkC,EAAcgC,WACjCiiC,8BAA+BjkC,EAAc2C,0BAC7CuhC,0BAA2BlkC,EAAc0C,uBACzCyhC,eAAsCr4C,IAA3BkU,EAAcZ,WAA2BY,EAAcZ,cAAWtT,EAC7Es4C,qBAAsBpkC,EAAcmC,mBACpCkiC,gCAAiCrkC,EAAc6C,6BAEnD,C6D9BsCyhC,CAAuBtkC,GAE3D,OAAO,EACL,CACEukC,oBAAqBvkC,EAAcygC,kBACnC+D,mBAAoBxkC,EAAc0gC,iBAClC+D,2BAA4BzkC,EAAc84B,wBAC1C4L,kBAAmB1kC,EAAciY,kBACjC0sB,sBAAuB3kC,EAAcogB,oBACrCwkB,4BACEv2C,MAAM8E,QAAQ6M,EAAc8X,wBAA0B9X,EAAc8X,sBAAsBloB,OAAS,EACrGi1C,sBAAuB7kC,EAAc6gC,oBACrCiE,2BACEz2C,MAAM8E,QAAQ6M,EAAc8X,wBAA0B9X,EAAc8X,sBAAsBloB,OAAS,EACrGm1C,mBAAoB/kC,EAAc2kB,kBAClCqgB,qBAAsBhlC,EAAcw0B,mBACpCyQ,mBAAoBjlC,EAAc4gC,mBAEpCgD,EAEJ,CCrF4BsB,CAA0BvmC,II3E/C,SAAiCsM,EAAsBiE,GAC5DjE,EAAU7H,UAAU,GAAkD,SAACoI,GACrE,IAAoB,UAAAA,EAAA,eAAS,CAAxB,IAAM/D,EAAK,KACd,GAAwB,aAApBA,EAAMoD,UACR,MAEF,IAAM0F,EAAUrB,EAAesB,mBAAmB/I,EAAMG,WACxD,IAAK2I,IAAYA,EAAQ0oB,gBACvB,MAEF,IAAM/8B,EAAcjG,EAAiBwR,EAAMG,WACrCmI,EAAmC,CACvC7X,KAAMgE,EAAY/F,UAClB8wB,UAAW,CACThW,GAAIlkB,IACJ+J,SAAUD,EAAiB4Q,EAAM3Q,WAEnCnI,KAAM,YACNoW,IAAK,CACH2nB,WAAW,IAGfzhB,EAAUxH,OAAO,GAA4C,CAC3DsM,YAAW,EACXnI,UAAW1L,EAAYhG,SACvB8Z,cAAe,CAAEic,iBAAkBxkB,EAAM1Y,W,CAG/C,GACF,CJgDEo2C,CAAwBl6B,EAAWsF,GACnC4a,GAAwBlgB,EAAWjL,EAAeuQ,GAC5C,MAA2BwiB,GAC/B9nB,EACAjL,EACAxG,SACAihB,EACA6V,EACA1J,EACAoM,EACAxC,GARMwB,EAAS,YAAEE,EAAS,YAUpBxH,EAAaT,GAAqBhf,EAAW2b,GAAmB,SAExE7N,GAAuB9N,EAAWjL,EAAeuQ,GACjDvF,GAA2BC,EAAWjL,GAEtC,IAAMolC,EK7ED,SACLpkC,EACAkO,EACAC,EACAE,EACAD,GAEA,MAAO,CACLze,IAAK,SAACiX,GACJ,IAAMuI,EAAchB,EAAaiB,SAASxI,GACpCyI,EAAajB,EAAYkB,QAAQ1I,GACjC2I,EAAUrB,EAAesB,mBAAmB5I,GAClD,GAAI2I,GAAWJ,GAAeE,EAAY,CACxC,IAAMK,EAAWrB,EAAesB,aAAa/I,GAC7C,MAAO,CACLy9B,eAAgBrkC,EAChBskC,WAAY/0B,EAAQU,GACpBs0B,YAAa70B,EAAW,CAAEO,GAAIP,QAAa5kB,EAC3ColB,KAAM,CAAED,GAAId,EAAYc,GAAIxf,KAAM0e,EAAY1e,KAAM0f,SAAUd,EAAWc,SAAUpW,IAAKsV,EAAWtV,K,CAGzG,EAEJ,CLsD0ByqC,CACtBxlC,EAAcgB,cACduP,EACApB,EACAE,EACAD,GAGF,MAAO,CACLuyB,UAAS,EACTjX,SAAQ,EACRsH,UAAS,EACTE,UAAS,EACTjnB,UAAS,EACTkE,aAAY,EACZoB,QAAO,EACPkxB,mBAAoB2D,EAAgBz0C,IAExC,GJ3FqD,CACnDyG,MAAO,EACPxE,KAAM,EACNmtC,WAAY,EACZD,YAAa,WAAM,UACnB5M,eAAgB,WAAM,ICCwCt/B,GDKnDpD,ICL+EtG,GDKnC20C,GCJjDD,GAAgEhrC,GADQnC,GDKjC,UCH7CmC,GAAOnC,IAAQvH,GACX00C,IAA0BA,GAAuB6G,GACnD7G,GAAuB6G,EAAE/4C,SAAQ,SAAC5B,GAAO,OAAAkK,EAAgBlK,EAAI,mCAApBkK,EAAA,G","file":"datadog-rum-slim.js","sourcesContent":["/* eslint-disable no-console, local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = typeof ConsoleApiName[keyof typeof ConsoleApiName]\n\ninterface Display {\n  (api: ConsoleApiName, ...args: any[]): void\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\nexport const display: Display = (api, ...args) => {\n  if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {\n    api = ConsoleApiName.log\n  }\n  display[api](...args)\n}\n\ndisplay.debug = console.debug.bind(console)\ndisplay.log = console.log.bind(console)\ndisplay.info = console.info.bind(console)\ndisplay.warn = console.warn.bind(console)\ndisplay.error = console.error.bind(console)\n","import { ConsoleApiName, display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    displayIfDebugEnabled(ConsoleApiName.error, e)\n    if (onMonitorErrorCollected) {\n      try {\n        onMonitorErrorCollected(e)\n      } catch (e) {\n        displayIfDebugEnabled(ConsoleApiName.error, e)\n      }\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(api: ConsoleApiName, ...args: any[]) {\n  if (debugMode) {\n    display(api, '[MONITOR]', ...args)\n  }\n}\n","import { display } from './display'\nimport { monitor } from './monitor'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\nexport const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\nexport const enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n}\n\nexport const enum ResourceType {\n  DOCUMENT = 'document',\n  XHR = 'xhr',\n  BEACON = 'beacon',\n  FETCH = 'fetch',\n  CSS = 'css',\n  JS = 'js',\n  IMAGE = 'image',\n  FONT = 'font',\n  MEDIA = 'media',\n  OTHER = 'other',\n}\n\nexport const enum RequestType {\n  FETCH = ResourceType.FETCH,\n  XHR = ResourceType.XHR,\n}\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\ninterface Assignable {\n  [key: string]: any\n}\n\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W\nexport function assign(target: Assignable, ...toAssign: Assignable[]) {\n  toAssign.forEach((source: Assignable) => {\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  })\n  return target\n}\n\nexport function shallowClone<T>(object: T): T & Record<string, never> {\n  return assign({}, object)\n}\n\n/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\n/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(value: unknown, space?: string | number): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matters here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, getCyclicReplacer(), space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\ninterface ObjectWithToJsonMethod {\n  toJSON: unknown\n}\nfunction detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n\nexport function includes(candidate: string, search: string): boolean\nexport function includes<T>(candidate: T[], search: T): boolean\nexport function includes(candidate: string | unknown[], search: any) {\n  return candidate.indexOf(search) !== -1\n}\n\nexport function arrayFrom<T>(arrayLike: ArrayLike<T> | Set<T>): T[] {\n  if (Array.from) {\n    return Array.from(arrayLike)\n  }\n\n  const array = []\n\n  if (arrayLike instanceof Set) {\n    arrayLike.forEach((item) => array.push(item))\n  } else {\n    for (let i = 0; i < arrayLike.length; i++) {\n      array.push(arrayLike[i])\n    }\n  }\n\n  return array\n}\n\nexport function find<T, S extends T>(\n  array: ArrayLike<T>,\n  predicate: (item: T, index: number) => item is S\n): S | undefined\nexport function find<T>(array: ArrayLike<T>, predicate: (item: T, index: number) => boolean): T | undefined\nexport function find(\n  array: ArrayLike<unknown>,\n  predicate: (item: unknown, index: number) => boolean\n): unknown | undefined {\n  for (let i = 0; i < array.length; i += 1) {\n    const item = array[i]\n    if (predicate(item, i)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.keys(object).map((key) => object[key])\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function objectEntries(object: { [key: string]: unknown }): Array<[string, unknown]> {\n  return Object.keys(object).map((key) => [key, object[key]])\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n\nexport function startsWith(candidate: string, search: string) {\n  return candidate.slice(0, search.length) === search\n}\n\nexport function endsWith(candidate: string, search: string) {\n  return candidate.slice(-search.length) === search\n}\n\n/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\nexport function getGlobalObject<T>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n\nexport function getLocationOrigin() {\n  return getLinkElementOrigin(window.location)\n}\n\n/**\n * IE fallback\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin\n */\nexport function getLinkElementOrigin(element: Location | HTMLAnchorElement | URL) {\n  if (element.origin) {\n    return element.origin\n  }\n  const sanitizedHost = element.host.replace(/(:80|:443)$/, '')\n  return `${element.protocol}//${sanitizedHost}`\n}\n\nexport function findCommaSeparatedValue(rawString: string, name: string) {\n  const regex = new RegExp(`(?:^|;)\\\\s*${name}\\\\s*=\\\\s*([^;]+)`)\n  const matches = regex.exec(rawString)\n  return matches ? matches[1] : undefined\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) return candidate\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n\nexport interface EventEmitter {\n  addEventListener(\n    event: DOM_EVENT,\n    listener: (event: Event) => void,\n    options?: boolean | { capture?: boolean; passive?: boolean }\n  ): void\n  removeEventListener(\n    event: DOM_EVENT,\n    listener: (event: Event) => void,\n    options?: boolean | { capture?: boolean; passive?: boolean }\n  ): void\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\n/**\n * Add an event listener to an event emitter object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<E extends Event>(\n  emitter: EventEmitter,\n  event: DOM_EVENT,\n  listener: (event: E) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(emitter, [event], listener, options)\n}\n\n/**\n * Add event listeners to an event emitter object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<E extends Event>(\n  emitter: EventEmitter,\n  events: DOM_EVENT[],\n  listener: (event: E) => void,\n  { once, capture, passive }: { once?: boolean; capture?: boolean; passive?: boolean } = {}\n) {\n  const wrappedListener = monitor(\n    once\n      ? (event: Event) => {\n          stop()\n          listener(event as E)\n        }\n      : (listener as (event: Event) => void)\n  )\n\n  const options = passive ? { capture, passive } : capture\n  events.forEach((event) => emitter.addEventListener(event, wrappedListener, options))\n  const stop = () => events.forEach((event) => emitter.removeEventListener(event, wrappedListener, options))\n\n  return {\n    stop,\n  }\n}\n\nexport function elementMatches(element: Element & { msMatchesSelector?(selector: string): boolean }, selector: string) {\n  if (element.matches) {\n    return element.matches(selector)\n  }\n  // IE11 support\n  if (element.msMatchesSelector) {\n    return element.msMatchesSelector(selector)\n  }\n  return false\n}\n\nexport function runOnReadyState(expectedReadyState: 'complete' | 'interactive', callback: () => void) {\n  if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n    callback()\n  } else {\n    const eventName = expectedReadyState === 'complete' ? DOM_EVENT.LOAD : DOM_EVENT.DOM_CONTENT_LOADED\n    addEventListener(window, eventName, callback, { once: true })\n  }\n}\n\n/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n    TDestination extends undefined\n    ? TSource\n    : // case 3 - source is an array - see if it merges or overwrites\n    TSource extends any[]\n    ? TDestination extends any[]\n      ? TDestination & TSource\n      : TSource\n    : // case 4 - source is an object - see if it merges or overwrites\n    TSource extends object\n    ? TDestination extends object\n      ? TDestination extends any[]\n        ? TSource\n        : TDestination & TSource\n      : TSource\n    : // case 5 - cannot merge - return source\n      TSource\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  // Using a weakmap instead of a weakset to support IE11\n  const map: WeakMap<any, boolean> = new WeakMap()\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = map.has(value)\n      if (!has) {\n        map.set(value, true)\n      }\n      return has\n    },\n  }\n}\n\n/**\n * Returns a replacer function that can be used with JSON.stringify\n * to remove cyclic references.\n */\nfunction getCyclicReplacer(): (key: string, value: unknown) => unknown {\n  const circularReferenceChecker = createCircularReferenceChecker()\n  return (_key: string, value: unknown) => {\n    const type = getType(value)\n    if ((type === 'object' || type === 'array') && circularReferenceChecker.hasAlreadyBeenSeen(value)) {\n      return '<warning: cyclic reference not serialized>'\n    }\n    return value\n  }\n}\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged: Record<any, any> = getType(destination) === 'object' ? destination : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are dereferenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\nexport type TimeoutId = ReturnType<typeof setTimeout>\n\nexport function requestIdleCallback(callback: () => void, opts?: { timeout?: number }) {\n  // Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n  // browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n  // fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n  // browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes\n  // efficiently.\n  if (window.requestIdleCallback) {\n    const id = window.requestIdleCallback(monitor(callback), opts)\n    return () => window.cancelIdleCallback(id)\n  }\n  const id = window.requestAnimationFrame(monitor(callback))\n  return () => window.cancelAnimationFrame(id)\n}\n\nexport function removeDuplicates<T>(array: T[]) {\n  const set = new Set<T>()\n  array.forEach((item) => set.add(item))\n  return arrayFrom(set)\n}\n\nexport type MatchOption = string | RegExp | ((value: string) => boolean)\nexport function matchList(list: MatchOption[], value: string): boolean {\n  return list.some((item) => {\n    if (typeof item === 'function') {\n      try {\n        return item(value)\n      } catch (e) {\n        display.error(e)\n        return false\n      }\n    }\n    if (item instanceof RegExp) {\n      return item.test(value)\n    }\n    return item === value\n  })\n}\n\n// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js\nexport function cssEscape(str: string) {\n  if (window.CSS && window.CSS.escape) {\n    return window.CSS.escape(str)\n  }\n\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g, function (ch, asCodePoint) {\n    if (asCodePoint) {\n      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n      if (ch === '\\0') {\n        return '\\uFFFD'\n      }\n      // Control characters and (dependent upon position) numbers get escaped as code points\n      return `${ch.slice(0, -1)}\\\\${ch.charCodeAt(ch.length - 1).toString(16)} `\n    }\n    // Other potentially-special ASCII characters get backslash-escaped\n    return `\\\\${ch}`\n  })\n}\n","import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n","import { deepClone } from './utils'\n\nimport type { Context, ContextValue } from './context'\n\nexport function createContextManager() {\n  let context: Context = {}\n\n  return {\n    /** @deprecated use getContext instead */\n    get: () => context,\n\n    /** @deprecated use setContextProperty instead */\n    add: (key: string, value: any) => {\n      context[key] = value as ContextValue\n    },\n\n    /** @deprecated renamed to removeContextProperty */\n    remove: (key: string) => {\n      delete context[key]\n    },\n\n    /** @deprecated use setContext instead */\n    set: (newContext: object) => {\n      context = newContext as Context\n    },\n\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: Context) => {\n      context = deepClone(newContext)\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context[key] = deepClone(property)\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n    },\n\n    clearContext: () => {\n      context = {}\n    },\n  }\n}\n","const BUFFER_LIMIT = 500\n\nexport class BoundedBuffer {\n  private buffer: Array<() => void> = []\n\n  add(callback: () => void) {\n    const length = this.buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      this.buffer.splice(0, 1)\n    }\n  }\n\n  drain() {\n    this.buffer.forEach((callback) => callback())\n    this.buffer.length = 0\n  }\n}\n","import { isNumber, ONE_YEAR, round } from './utils'\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n\nexport function resetNavigationStart() {\n  navigationStart = undefined\n}\n","import { display } from '../tools/display'\nimport { findCommaSeparatedValue, generateUUID, ONE_SECOND } from '../tools/utils'\n\nexport const COOKIE_ACCESS_DELAY = ONE_SECOND\n\nexport type SetCookieOverride = (name: string, value: string, expireDelay: number) => void\nexport type GetCookieOverride = (name: string) => string | undefined\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  domain?: string,\n  setCookie?: SetCookieOverride\n  getCookie?: GetCookieOverride\n}\n\n\nlet getCookieOverride: GetCookieOverride, setCookieOverride: SetCookieOverride\nexport function setCookieHandling(getCookie: GetCookieOverride, setCookie: SetCookieOverride): void {\n  getCookieOverride = getCookie\n  setCookieOverride = setCookie\n}\n\nexport function setCookie(name: string, value: string, expireDelay: number, options?: CookieOptions) {\n  if (setCookieOverride) {\n    setCookieOverride(name, value, expireDelay);\n    return\n  }\n  const date = new Date()\n  date.setTime(date.getTime() + expireDelay)\n  const expires = `expires=${date.toUTCString()}`\n  const sameSite = options && options.crossSite ? 'none' : 'strict'\n  const domain = options && options.domain ? `;domain=${options.domain}` : ''\n  const secure = options && options.secure ? ';secure' : ''\n  document.cookie = `${name}=${value};${expires};path=/;samesite=${sameSite}${domain}${secure}`\n}\n\nexport function getCookie(name: string): string | undefined {\n  if (getCookieOverride) {\n    return getCookieOverride(name)\n  }\n  return findCommaSeparatedValue(document.cookie, name)\n}\n\nexport function deleteCookie(name: string, options?: CookieOptions) {\n  setCookie(name, '', 0, options)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (!!getCookieOverride && !!setCookieHandling) {\n    return true\n  }\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_SECOND, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n","import { getCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n","import { endsWith, getGlobalObject } from '../tools/utils'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E) {\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event }))\n    },\n  }\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || endsWith(currentHost, `.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n","import { startsWith } from '../../tools/utils'\nimport type { StackTrace, StackFrame } from './types'\n\nconst UNKNOWN_FUNCTION = '?'\n\n/**\n * Computes a stack trace for an exception.\n */\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && startsWith(stackProperty, exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n","import type { StackTrace } from '../domain/tracekit'\nimport { computeStackTrace } from '../domain/tracekit'\nimport { callMonitored } from './monitor'\nimport type { ClocksState } from './timeUtils'\nimport { jsonStringify, noop } from './utils'\n\nexport interface ErrorWithCause extends Error {\n  cause?: Error\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: string\n  type?: string\n  stack?: string\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  causes?: RawErrorCause[]\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = typeof ErrorSource[keyof typeof ErrorSource]\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n\n  handlingStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: string\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  startClocks,\n  nonErrorPrefix,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  if (!stackTrace || (stackTrace.message === undefined && !(originalError instanceof Error))) {\n    return {\n      startClocks,\n      source,\n      handling,\n      originalError,\n      message: `${nonErrorPrefix} ${jsonStringify(originalError)!}`,\n      stack: 'No stack, consider using an instance of Error',\n      handlingStack,\n      type: stackTrace && stackTrace.name,\n    }\n  }\n\n  return {\n    startClocks,\n    source,\n    handling,\n    originalError,\n    message: stackTrace.message || 'Empty message',\n    stack: toStackTraceString(stackTrace),\n    handlingStack,\n    type: stackTrace.name,\n    causes: flattenErrorCauses(originalError as ErrorWithCause, source),\n  }\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n\n/**\n Creates a stacktrace without SDK internal frames.\n \n Constraints:\n - Has to be called at the utmost position of the call stack.\n - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error()\n  let formattedStack: string\n\n  // IE needs to throw the error to fill in the stack trace\n  if (!error.stack) {\n    try {\n      throw error\n    } catch (e) {\n      noop()\n    }\n  }\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (currentError?.cause instanceof Error && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n */\nimport { includes } from '../../tools/utils'\nimport { display } from '../../tools/display'\n\nlet enabledExperimentalFeatures: Set<string> | undefined\n\nexport function updateExperimentalFeatures(enabledFeatures: string[] | undefined): void {\n  // Safely handle external data\n  if (!Array.isArray(enabledFeatures)) {\n    return\n  }\n\n  if (!enabledExperimentalFeatures) {\n    enabledExperimentalFeatures = new Set(enabledFeatures)\n  }\n\n  enabledFeatures\n    .filter((flag) => typeof flag === 'string')\n    .forEach((flag: string) => {\n      if (includes(flag, '-')) {\n        display.warn(`please use snake case for '${flag}'`)\n      }\n      enabledExperimentalFeatures!.add(flag)\n    })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: string): boolean {\n  return !!enabledExperimentalFeatures && enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures = new Set()\n}\n\nexport function getExperimentalFeatures(): Set<string> {\n  return enabledExperimentalFeatures || new Set()\n}\n","import { getLinkElementOrigin, getLocationOrigin } from './utils'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, getLocationOrigin()).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function haveSameOrigin(url1: string, url2: string) {\n  return getOrigin(url1) === getOrigin(url2)\n}\n\nexport function getOrigin(url: string) {\n  return getLinkElementOrigin(buildUrl(url))\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function getSearch(url: string) {\n  return buildUrl(url).search\n}\n\nexport function getHash(url: string) {\n  return buildUrl(url).hash\n}\n\nexport function buildUrl(url: string, base?: string) {\n  if (checkURLSupported()) {\n    return base !== undefined ? new URL(url, base) : new URL(url)\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nlet isURLSupported: boolean | undefined\nfunction checkURLSupported() {\n  if (isURLSupported !== undefined) {\n    return isURLSupported\n  }\n  try {\n    const url = new URL('http://test/path')\n    isURLSupported = url.href === 'http://test/path'\n    return isURLSupported\n  } catch {\n    isURLSupported = false\n  }\n  return isURLSupported\n}\n","export const INTAKE_SITE_STAGING = 'datad0g.com'\nexport const INTAKE_SITE_US1 = 'datadoghq.com'\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com'\n","import { timeStampNow } from '../../tools/timeUtils'\nimport { normalizeUrl } from '../../tools/urlPolyfill'\nimport { generateUUID } from '../../tools/utils'\nimport type { InitConfiguration } from './configuration'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport const ENDPOINTS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'session-replay',\n} as const\n\nconst INTAKE_TRACKS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'replay',\n}\n\nexport type EndpointType = keyof typeof ENDPOINTS\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType,\n  tags: string[]\n) {\n  const { site = INTAKE_SITE_US1, clientToken } = initConfiguration\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  const host = `${ENDPOINTS[endpointType]}.browser-intake-${domainParts.join('-')}.${extension!}`\n  const baseUrl = `https://${host}/api/v2/${INTAKE_TRACKS[endpointType]}`\n  const proxyUrl = initConfiguration.proxyUrl && normalizeUrl(initConfiguration.proxyUrl)\n\n  return {\n    build() {\n      let parameters =\n        'ddsource=browser' +\n        `&ddtags=${encodeURIComponent([`sdk_version:${__BUILD_ENV__SDK_VERSION__}`].concat(tags).join(','))}` +\n        `&dd-api-key=${clientToken}` +\n        `&dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}` +\n        '&dd-evp-origin=browser' +\n        `&dd-request-id=${generateUUID()}`\n\n      if (endpointType === 'rum') {\n        parameters += `&batch_time=${timeStampNow()}`\n      }\n      const endpointUrl = `${baseUrl}?${parameters}`\n\n      return proxyUrl ? `${proxyUrl}?ddforward=${encodeURIComponent(endpointUrl)}` : endpointUrl\n    },\n    buildIntakeUrl() {\n      return proxyUrl ? `${proxyUrl}?ddforward` : baseUrl\n    },\n    endpointType,\n  }\n}\n","import { display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nconst FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {\n    display.warn(`${key} value doesn't meet tag requirements and will be sanitized`)\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n","import { assign, objectValues } from '../../tools/utils'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  isIntakeUrl: (url: string) => boolean\n  replica?: ReplicaConfiguration\n  site: string\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const intakeEndpoints = objectValues(endpointBuilders).map((builder) => builder.buildIntakeUrl())\n\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeEndpoints, tags)\n\n  return assign(\n    {\n      isIntakeUrl: (url: string) => intakeEndpoints.some((intakeEndpoint) => url.indexOf(intakeEndpoint) === 0),\n      replica: replicaConfiguration,\n      site: initConfiguration.site || INTAKE_SITE_US1,\n    },\n    endpointBuilders\n  )\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'sessionReplay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  intakeEndpoints: string[],\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = assign({}, initConfiguration, {\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  })\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  intakeEndpoints.push(...objectValues(replicaEndpointBuilders).map((builder) => builder.buildIntakeUrl()))\n\n  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders)\n}\n","import { CookieOptions, GetCookieOverride, setCookieHandling, SetCookieOverride } from '../../browser/cookie'\nimport { getCurrentSite } from '../../browser/cookie'\nimport { catchUserErrors } from '../../tools/catchUserErrors'\nimport { display } from '../../tools/display'\nimport { assign, isPercentage, ONE_KIBI_BYTE, ONE_SECOND } from '../../tools/utils'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport { updateExperimentalFeatures } from './experimentalFeatures'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = typeof DefaultPrivacyLevel[keyof typeof DefaultPrivacyLevel]\n\nexport interface InitConfiguration {\n  // global options\n  clientToken: string\n  beforeSend?: GenericBeforeSendCallback | undefined\n  sampleRate?: number | undefined\n  telemetrySampleRate?: number | undefined\n  silentMultipleInit?: boolean | undefined\n\n  // transport options\n  proxyUrl?: string | undefined\n  site?: string | undefined\n\n  // tag and context options\n  service?: string | undefined\n  env?: string | undefined\n  version?: string | undefined\n\n  // cookie options\n  useCrossSiteSessionCookie?: boolean | undefined\n  useSecureSessionCookie?: boolean | undefined\n  trackSessionAcrossSubdomains?: boolean | undefined\n  getCookie?: GetCookieOverride\n  setCookie?: SetCookieOverride\n\n  // internal options\n  enableExperimentalFeatures?: string[] | undefined\n  replica?: ReplicaUserConfiguration | undefined\n  datacenter?: string\n  telemetryConfigurationSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\ninterface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  cookieOptions: CookieOptions\n  sampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: number\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  if (initConfiguration.sampleRate !== undefined && !isPercentage(initConfiguration.sampleRate)) {\n    display.error('Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.telemetrySampleRate !== undefined && !isPercentage(initConfiguration.telemetrySampleRate)) {\n    display.error('Telemetry Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryConfigurationSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryConfigurationSampleRate)\n  ) {\n    display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (!!initConfiguration.setCookie !== !!initConfiguration.getCookie) {\n    display.error('Both setCookie and getCookie must be set or undefined.')\n    return\n  }\n\n  // Set the experimental feature flags as early as possible, so we can use them in most places\n  updateExperimentalFeatures(initConfiguration.enableExperimentalFeatures)\n\n  return assign(\n    {\n      beforeSend:\n        initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n      cookieOptions: buildCookieOptions(initConfiguration),\n      sampleRate: initConfiguration.sampleRate ?? 100,\n      telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n      telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n      service: initConfiguration.service,\n      silentMultipleInit: !!initConfiguration.silentMultipleInit,\n\n      /**\n       * beacon payload max queue size implementation is 64kb\n       * ensure that we leave room for logs, rum and potential other users\n       */\n      batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n      eventRateLimiterThreshold: 3000,\n      maxTelemetryEventsPerPage: 15,\n\n      /**\n       * flush automatically, aim to be lower than ALB connection timeout\n       * to maximize connection reuse.\n       */\n      flushTimeout: 30 * ONE_SECOND,\n\n      /**\n       * Logs intake limit\n       */\n      batchMessagesLimit: 50,\n      messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    },\n    computeTransportConfiguration(initConfiguration)\n  )\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  setCookieHandling(initConfiguration.getCookie!, initConfiguration.setCookie!);\n  \n  cookieOptions.secure = mustUseSecureCookie(initConfiguration)\n  cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n\nfunction mustUseSecureCookie(initConfiguration: InitConfiguration) {\n  return !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie\n}\n\nexport function serializeConfiguration(configuration: InitConfiguration): Partial<RawTelemetryConfiguration> {\n  return {\n    session_sample_rate: configuration.sampleRate,\n    telemetry_sample_rate: configuration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: configuration.telemetryConfigurationSampleRate,\n    use_before_send: !!configuration.beforeSend,\n    use_cross_site_session_cookie: configuration.useCrossSiteSessionCookie,\n    use_secure_session_cookie: configuration.useSecureSessionCookie,\n    use_proxy: configuration.proxyUrl !== undefined ? !!configuration.proxyUrl : undefined,\n    silent_multiple_init: configuration.silentMultipleInit,\n    track_session_across_subdomains: configuration.trackSessionAcrossSubdomains,\n  }\n}\n","export interface Subscription {\n  unsubscribe: () => void\n}\n\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: () => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    if (!this.observers.length && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe() || undefined\n    }\n    this.observers.push(f)\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  const globalObservable = new Observable<T>(() => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n\n  return globalObservable\n}\n","import type { TelemetryEvent, TelemetryConfigurationEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  log: 'log',\n  configuration: 'configuration',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\n","import type { Context } from '../../tools/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { toStackTraceString } from '../../tools/error'\nimport { assign, combine, jsonStringify, performDraw, includes, startsWith, arrayFrom } from '../../tools/utils'\nimport type { Configuration } from '../configuration'\nimport { getExperimentalFeatures, INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration'\nimport type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type { RawTelemetryConfiguration, RawTelemetryEvent } from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (provider: () => Context) => void\n  observable: Observable<TelemetryEvent & Context>\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\nconst telemetryConfiguration: {\n  maxEventsPerPage: number\n  sentEventCount: number\n  telemetryEnabled: boolean\n  telemetryConfigurationEnabled: boolean\n} = { maxEventsPerPage: 0, sentEventCount: 0, telemetryEnabled: false, telemetryConfigurationEnabled: false }\n\nlet onRawTelemetryEventCollected: ((event: RawTelemetryEvent) => void) | undefined\n\nexport function startTelemetry(telemetryService: TelemetryService, configuration: Configuration): Telemetry {\n  let contextProvider: () => Context\n  const observable = new Observable<TelemetryEvent & Context>()\n\n  telemetryConfiguration.telemetryEnabled = performDraw(configuration.telemetrySampleRate)\n  telemetryConfiguration.telemetryConfigurationEnabled =\n    telemetryConfiguration.telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate)\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    if (!includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && telemetryConfiguration.telemetryEnabled) {\n      observable.notify(toTelemetryEvent(telemetryService, event))\n    }\n  }\n  startMonitorErrorCollection(addTelemetryError)\n\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: configuration.maxTelemetryEventsPerPage,\n    sentEventCount: 0,\n  })\n\n  function toTelemetryEvent(telemetryService: TelemetryService, event: RawTelemetryEvent): TelemetryEvent & Context {\n    return combine(\n      {\n        type: 'telemetry' as const,\n        date: timeStampNow(),\n        service: telemetryService,\n        version: __BUILD_ENV__SDK_VERSION__,\n        source: 'browser' as const,\n        _dd: {\n          format_version: 2 as const,\n        },\n        telemetry: event as any, // https://github.com/microsoft/TypeScript/issues/48457\n        experimental_features: arrayFrom(getExperimentalFeatures()),\n      },\n      contextProvider !== undefined ? contextProvider() : {}\n    )\n  }\n\n  return {\n    setContextProvider: (provider: () => Context) => {\n      contextProvider = provider\n    },\n    observable,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: Infinity,\n    sentEventCount: 0,\n  })\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\nexport function resetTelemetry() {\n  onRawTelemetryEventCollected = undefined\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        message,\n        status: StatusType.debug,\n      },\n      context\n    )\n  )\n}\n\nexport function addTelemetryError(e: unknown) {\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        status: StatusType.error,\n      },\n      formatError(e)\n    )\n  )\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  if (telemetryConfiguration.telemetryConfigurationEnabled) {\n    addTelemetry({\n      type: TelemetryType.configuration,\n      configuration,\n    })\n  }\n}\n\nfunction addTelemetry(event: RawTelemetryEvent) {\n  if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {\n    telemetryConfiguration.sentEventCount += 1\n    onRawTelemetryEventCollected(event)\n  }\n}\n\nexport function formatError(e: unknown) {\n  if (e instanceof Error) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: 'Not an instance of error',\n    },\n    message: `Uncaught ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => startsWith(frame.url!, allowedFrameUrl))\n  )\n  return stackTrace\n}\n","import { monitor, noop, Observable } from '@datadog/browser-core'\n\nexport function createDOMMutationObservable() {\n  const MutationObserver = getMutationObserverConstructor()\n\n  const observable: Observable<void> = new Observable<void>(() => {\n    if (!MutationObserver) {\n      return\n    }\n    const observer = new MutationObserver(monitor(() => observable.notify()))\n    observer.observe(document, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n    return () => observer.disconnect()\n  })\n\n  return observable\n}\n\ntype MutationObserverConstructor = new (callback: MutationCallback) => MutationObserver\nexport interface BrowserWindow extends Window {\n  MutationObserver?: MutationObserverConstructor\n  Zone?: {\n    __symbol__: (name: string) => string\n  }\n}\n\nexport function getMutationObserverConstructor(): MutationObserverConstructor | undefined {\n  let constructor: MutationObserverConstructor | undefined\n  const browserWindow: BrowserWindow = window\n\n  // Angular uses Zone.js to provide a context persisting across async tasks.  Zone.js replaces the\n  // global MutationObserver constructor with a patched version to support the context propagation.\n  // There is an ongoing issue[1][2] with this setup when using a MutationObserver within a Angular\n  // component: on some occasions, the callback is being called in an infinite loop, causing the\n  // page to freeze (even if the callback is completely empty).\n  //\n  // To work around this issue, we try to get the original MutationObserver constructor stored by\n  // Zone.js.\n  //\n  // [1] https://github.com/angular/angular/issues/26948\n  // [2] https://github.com/angular/angular/issues/31712\n  if (browserWindow.Zone) {\n    const zoneSymbol = browserWindow.Zone.__symbol__\n\n    // Zone.js 0.8.6+ is storing original class constructors into the browser 'window' object[3].\n    //\n    // [3] https://github.com/angular/angular/blob/6375fa79875c0fe7b815efc45940a6e6f5c9c9eb/packages/zone.js/lib/common/utils.ts#L288\n    constructor = browserWindow[zoneSymbol('MutationObserver') as any] as unknown as\n      | MutationObserverConstructor\n      | undefined\n\n    if (!constructor && browserWindow.MutationObserver) {\n      // Anterior Zone.js versions (used in Angular 2) does not expose the original MutationObserver\n      // in the 'window' object. Luckily, the patched MutationObserver class is storing an original\n      // instance in its properties[4]. Let's get the original MutationObserver constructor from\n      // there.\n      //\n      // [4] https://github.com/angular/zone.js/blob/v0.8.5/lib/common/utils.ts#L412\n\n      const patchedInstance = new browserWindow.MutationObserver(noop) as any\n      const originalInstance = patchedInstance[zoneSymbol('originalInstance')] as\n        | { constructor: MutationObserverConstructor }\n        | undefined\n\n      constructor = originalInstance && originalInstance.constructor\n    }\n  }\n\n  if (!constructor) {\n    constructor = browserWindow.MutationObserver\n  }\n\n  return constructor\n}\n","import type { RelativeTime, ServerDuration } from '@datadog/browser-core'\nimport {\n  assign,\n  addTelemetryDebug,\n  elapsed,\n  getPathName,\n  includes,\n  isValidUrl,\n  ResourceType,\n  toServerDuration,\n} from '@datadog/browser-core'\n\nimport type { RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\n\nimport type { PerformanceResourceDetailsElement } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\n\nexport interface PerformanceResourceDetails {\n  redirect?: PerformanceResourceDetailsElement\n  dns?: PerformanceResourceDetailsElement\n  connect?: PerformanceResourceDetailsElement\n  ssl?: PerformanceResourceDetailsElement\n  first_byte: PerformanceResourceDetailsElement\n  download: PerformanceResourceDetailsElement\n}\n\nexport const FAKE_INITIAL_DOCUMENT = 'initial_document'\n\nconst RESOURCE_TYPES: Array<[ResourceType, (initiatorType: string, path: string) => boolean]> = [\n  [ResourceType.DOCUMENT, (initiatorType: string) => FAKE_INITIAL_DOCUMENT === initiatorType],\n  [ResourceType.XHR, (initiatorType: string) => 'xmlhttprequest' === initiatorType],\n  [ResourceType.FETCH, (initiatorType: string) => 'fetch' === initiatorType],\n  [ResourceType.BEACON, (initiatorType: string) => 'beacon' === initiatorType],\n  [ResourceType.CSS, (_: string, path: string) => /\\.css$/i.test(path)],\n  [ResourceType.JS, (_: string, path: string) => /\\.js$/i.test(path)],\n  [\n    ResourceType.IMAGE,\n    (initiatorType: string, path: string) =>\n      includes(['image', 'img', 'icon'], initiatorType) || /\\.(gif|jpg|jpeg|tiff|png|svg|ico)$/i.exec(path) !== null,\n  ],\n  [ResourceType.FONT, (_: string, path: string) => /\\.(woff|eot|woff2|ttf)$/i.exec(path) !== null],\n  [\n    ResourceType.MEDIA,\n    (initiatorType: string, path: string) =>\n      includes(['audio', 'video'], initiatorType) || /\\.(mp3|mp4)$/i.exec(path) !== null,\n  ],\n]\n\nexport function computeResourceKind(timing: RumPerformanceResourceTiming) {\n  const url = timing.name\n  if (!isValidUrl(url)) {\n    addTelemetryDebug(`Failed to construct URL for \"${timing.name}\"`)\n    return ResourceType.OTHER\n  }\n  const path = getPathName(url)\n  for (const [type, isType] of RESOURCE_TYPES) {\n    if (isType(timing.initiatorType, path)) {\n      return type\n    }\n  }\n  return ResourceType.OTHER\n}\n\nfunction areInOrder(...numbers: number[]) {\n  for (let i = 1; i < numbers.length; i += 1) {\n    if (numbers[i - 1] > numbers[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function isRequestKind(timing: RumPerformanceResourceTiming) {\n  return timing.initiatorType === 'xmlhttprequest' || timing.initiatorType === 'fetch'\n}\n\nexport function computePerformanceResourceDuration(entry: RumPerformanceResourceTiming): ServerDuration {\n  const { duration, startTime, responseEnd } = entry\n\n  // Safari duration is always 0 on timings blocked by cross origin policies.\n  if (duration === 0 && startTime < responseEnd) {\n    return toServerDuration(elapsed(startTime, responseEnd))\n  }\n\n  return toServerDuration(duration)\n}\n\nexport function computePerformanceResourceDetails(\n  entry: RumPerformanceResourceTiming\n): PerformanceResourceDetails | undefined {\n  const validEntry = toValidEntry(entry)\n\n  if (!validEntry) {\n    return undefined\n  }\n  const {\n    startTime,\n    fetchStart,\n    redirectStart,\n    redirectEnd,\n    domainLookupStart,\n    domainLookupEnd,\n    connectStart,\n    secureConnectionStart,\n    connectEnd,\n    requestStart,\n    responseStart,\n    responseEnd,\n  } = validEntry\n\n  const details: PerformanceResourceDetails = {\n    download: formatTiming(startTime, responseStart, responseEnd),\n    first_byte: formatTiming(startTime, requestStart, responseStart),\n  }\n\n  // Make sure a connection occurred\n  if (connectEnd !== fetchStart) {\n    details.connect = formatTiming(startTime, connectStart, connectEnd)\n\n    // Make sure a secure connection occurred\n    if (areInOrder(connectStart, secureConnectionStart, connectEnd)) {\n      details.ssl = formatTiming(startTime, secureConnectionStart, connectEnd)\n    }\n  }\n\n  // Make sure a domain lookup occurred\n  if (domainLookupEnd !== fetchStart) {\n    details.dns = formatTiming(startTime, domainLookupStart, domainLookupEnd)\n  }\n\n  if (hasRedirection(entry)) {\n    details.redirect = formatTiming(startTime, redirectStart, redirectEnd)\n  }\n\n  return details\n}\n\nexport function toValidEntry(entry: RumPerformanceResourceTiming) {\n  // Ensure timings are in the right order. On top of filtering out potential invalid\n  // RumPerformanceResourceTiming, it will ignore entries from requests where timings cannot be\n  // collected, for example cross origin requests without a \"Timing-Allow-Origin\" header allowing\n  // it.\n  if (\n    !areInOrder(\n      entry.startTime,\n      entry.fetchStart,\n      entry.domainLookupStart,\n      entry.domainLookupEnd,\n      entry.connectStart,\n      entry.connectEnd,\n      entry.requestStart,\n      entry.responseStart,\n      entry.responseEnd\n    )\n  ) {\n    return undefined\n  }\n\n  if (!hasRedirection(entry)) {\n    return entry\n  }\n\n  let { redirectStart, redirectEnd } = entry\n  // Firefox doesn't provide redirect timings on cross origin requests.\n  // Provide a default for those.\n  if (redirectStart < entry.startTime) {\n    redirectStart = entry.startTime\n  }\n  if (redirectEnd < entry.startTime) {\n    redirectEnd = entry.fetchStart\n  }\n\n  // Make sure redirect timings are in order\n  if (!areInOrder(entry.startTime, redirectStart, redirectEnd, entry.fetchStart)) {\n    return undefined\n  }\n\n  return assign({}, entry, {\n    redirectEnd,\n    redirectStart,\n  })\n}\n\nfunction hasRedirection(entry: RumPerformanceResourceTiming) {\n  // The only time fetchStart is different than startTime is if a redirection occurred.\n  return entry.fetchStart !== entry.startTime\n}\n\nfunction formatTiming(origin: RelativeTime, start: RelativeTime, end: RelativeTime) {\n  return {\n    duration: toServerDuration(elapsed(start, end)),\n    start: toServerDuration(elapsed(origin, start)),\n  }\n}\n\nexport function computeSize(entry: RumPerformanceResourceTiming) {\n  // Make sure a request actually occurred\n  if (entry.startTime < entry.responseStart) {\n    return entry.decodedBodySize\n  }\n  return undefined\n}\n\nexport function isAllowedRequestUrl(configuration: RumConfiguration, url: string) {\n  return url && !configuration.isIntakeUrl(url)\n}\n","import type { TimeStamp } from '@datadog/browser-core'\nimport { dateNow, findCommaSeparatedValue, ONE_MINUTE } from '@datadog/browser-core'\n\ninterface DocumentTraceData {\n  traceId: string\n  traceTime: TimeStamp\n}\n\nexport const INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD = 2 * ONE_MINUTE\n\nexport function getDocumentTraceId(document: Document): string | undefined {\n  const data = getDocumentTraceDataFromMeta(document) || getDocumentTraceDataFromComment(document)\n\n  if (!data || data.traceTime <= dateNow() - INITIAL_DOCUMENT_OUTDATED_TRACE_ID_THRESHOLD) {\n    return undefined\n  }\n\n  return data.traceId\n}\n\nexport function getDocumentTraceDataFromMeta(document: Document): DocumentTraceData | undefined {\n  const traceIdMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-id]')\n  const traceTimeMeta = document.querySelector<HTMLMetaElement>('meta[name=dd-trace-time]')\n  return createDocumentTraceData(traceIdMeta && traceIdMeta.content, traceTimeMeta && traceTimeMeta.content)\n}\n\nexport function getDocumentTraceDataFromComment(document: Document): DocumentTraceData | undefined {\n  const comment = findTraceComment(document)\n  if (!comment) {\n    return undefined\n  }\n  return createDocumentTraceData(\n    findCommaSeparatedValue(comment, 'trace-id'),\n    findCommaSeparatedValue(comment, 'trace-time')\n  )\n}\n\nexport function createDocumentTraceData(\n  traceId: string | undefined | null,\n  rawTraceTime: string | undefined | null\n): DocumentTraceData | undefined {\n  const traceTime = rawTraceTime && (Number(rawTraceTime) as TimeStamp)\n  if (!traceId || !traceTime) {\n    return undefined\n  }\n\n  return {\n    traceId,\n    traceTime,\n  }\n}\n\nexport function findTraceComment(document: Document): string | undefined {\n  // 1. Try to find the comment as a direct child of the document\n  // Note: TSLint advises to use a 'for of', but TS doesn't allow to use 'for of' if the iterated\n  // value is not an array or string (here, a NodeList).\n  for (let i = 0; i < document.childNodes.length; i += 1) {\n    const comment = getTraceCommentFromNode(document.childNodes[i])\n    if (comment) {\n      return comment\n    }\n  }\n\n  // 2. If the comment is placed after the </html> tag, but have some space or new lines before or\n  // after, the DOM parser will lift it (and the surrounding text) at the end of the <body> tag.\n  // Try to look for the comment at the end of the <body> by by iterating over its child nodes in\n  // reverse order, stopping if we come across a non-text node.\n  if (document.body) {\n    for (let i = document.body.childNodes.length - 1; i >= 0; i -= 1) {\n      const node = document.body.childNodes[i]\n      const comment = getTraceCommentFromNode(node)\n      if (comment) {\n        return comment\n      }\n      if (!isTextNode(node)) {\n        break\n      }\n    }\n  }\n}\n\nfunction getTraceCommentFromNode(node: Node | null) {\n  if (node && isCommentNode(node)) {\n    const match = /^\\s*DATADOG;(.*?)\\s*$/.exec(node.data)\n    if (match) {\n      return match[1]\n    }\n  }\n}\n\nfunction isCommentNode(node: Node): node is Comment {\n  return node.nodeName === '#comment'\n}\n\nfunction isTextNode(node: Node): node is Text {\n  return node.nodeName === '#text'\n}\n","import { monitor, Observable, throttle, addEventListener, DOM_EVENT } from '@datadog/browser-core'\n\nexport interface ViewportDimension {\n  height: number\n  width: number\n}\n\nlet viewportObservable: Observable<ViewportDimension> | undefined\n\nexport function initViewportObservable() {\n  if (!viewportObservable) {\n    viewportObservable = createViewportObservable()\n  }\n  return viewportObservable\n}\n\nexport function createViewportObservable() {\n  const observable = new Observable<ViewportDimension>(() => {\n    const { throttled: updateDimension } = throttle(\n      monitor(() => {\n        observable.notify(getViewportDimension())\n      }),\n      200\n    )\n\n    return addEventListener(window, DOM_EVENT.RESIZE, updateDimension, { capture: true, passive: true }).stop\n  })\n\n  return observable\n}\n\n// excludes the width and height of any rendered classic scrollbar that is fixed to the visual viewport\nexport function getViewportDimension(): ViewportDimension {\n  const visual = window.visualViewport\n  if (visual) {\n    return {\n      width: Number(visual.width * visual.scale),\n      height: Number(visual.height * visual.scale),\n    }\n  }\n\n  return {\n    width: Number(window.innerWidth || 0),\n    height: Number(window.innerHeight || 0),\n  }\n}\n","import { isExperimentalFeatureEnabled } from '@datadog/browser-core'\nimport { getViewportDimension, initViewportObservable } from '../../browser/viewportObservable'\n\nlet viewport: { width: number; height: number } | undefined\nlet stopListeners: (() => void) | undefined\n\nexport function getDisplayContext() {\n  if (!isExperimentalFeatureEnabled('clickmap')) return\n\n  if (!viewport) {\n    viewport = getViewportDimension()\n    stopListeners = initViewportObservable().subscribe((viewportDimension) => {\n      viewport = viewportDimension\n    }).unsubscribe\n  }\n\n  return {\n    viewport,\n  }\n}\n\nexport function resetDisplayContext() {\n  if (stopListeners) stopListeners()\n  viewport = undefined\n}\n","import type { Duration, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  dateNow,\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  getRelativeTime,\n  isNumber,\n  monitor,\n  relativeNow,\n  runOnReadyState,\n} from '@datadog/browser-core'\n\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { FAKE_INITIAL_DOCUMENT, isAllowedRequestUrl } from '../domain/rumEventsCollection/resource/resourceUtils'\n\nimport { getDocumentTraceId } from '../domain/tracing/getDocumentTraceId'\nimport type { PerformanceEntryRepresentation } from '../domainContext.types'\n\nexport interface RumPerformanceResourceTiming {\n  entryType: 'resource'\n  initiatorType: string\n  name: string\n  startTime: RelativeTime\n  duration: Duration\n  fetchStart: RelativeTime\n  domainLookupStart: RelativeTime\n  domainLookupEnd: RelativeTime\n  connectStart: RelativeTime\n  secureConnectionStart: RelativeTime\n  connectEnd: RelativeTime\n  requestStart: RelativeTime\n  responseStart: RelativeTime\n  responseEnd: RelativeTime\n  redirectStart: RelativeTime\n  redirectEnd: RelativeTime\n  decodedBodySize: number\n  traceId?: string\n}\n\nexport interface RumPerformanceLongTaskTiming {\n  entryType: 'longtask'\n  startTime: RelativeTime\n  duration: Duration\n  toJSON(): PerformanceEntryRepresentation\n}\n\nexport interface RumPerformancePaintTiming {\n  entryType: 'paint'\n  name: 'first-paint' | 'first-contentful-paint'\n  startTime: RelativeTime\n}\n\nexport interface RumPerformanceNavigationTiming {\n  entryType: 'navigation'\n  domComplete: RelativeTime\n  domContentLoadedEventEnd: RelativeTime\n  domInteractive: RelativeTime\n  loadEventEnd: RelativeTime\n  responseStart: RelativeTime\n}\n\nexport interface RumLargestContentfulPaintTiming {\n  entryType: 'largest-contentful-paint'\n  startTime: RelativeTime\n  size: number\n}\n\nexport interface RumFirstInputTiming {\n  entryType: 'first-input'\n  startTime: RelativeTime\n  processingStart: RelativeTime\n}\n\nexport interface RumLayoutShiftTiming {\n  entryType: 'layout-shift'\n  startTime: RelativeTime\n  value: number\n  hadRecentInput: boolean\n}\n\nexport type RumPerformanceEntry =\n  | RumPerformanceResourceTiming\n  | RumPerformanceLongTaskTiming\n  | RumPerformancePaintTiming\n  | RumPerformanceNavigationTiming\n  | RumLargestContentfulPaintTiming\n  | RumFirstInputTiming\n  | RumLayoutShiftTiming\n\nfunction supportPerformanceObject() {\n  return window.performance !== undefined && 'getEntries' in performance\n}\n\nexport function supportPerformanceTimingEvent(entryType: string) {\n  return (\n    window.PerformanceObserver &&\n    PerformanceObserver.supportedEntryTypes !== undefined &&\n    PerformanceObserver.supportedEntryTypes.includes(entryType)\n  )\n}\n\nexport function startPerformanceCollection(lifeCycle: LifeCycle, configuration: RumConfiguration) {\n  retrieveInitialDocumentResourceTiming((timing) => {\n    handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n  })\n\n  if (supportPerformanceObject()) {\n    const performanceEntries = performance.getEntries()\n    // Because the performance entry list can be quite large\n    // delay the computation to prevent the SDK from blocking the main thread on init\n    setTimeout(monitor(() => handleRumPerformanceEntries(lifeCycle, configuration, performanceEntries)))\n  }\n\n  if (window.PerformanceObserver) {\n    const handlePerformanceEntryList = monitor((entries: PerformanceObserverEntryList) =>\n      handleRumPerformanceEntries(lifeCycle, configuration, entries.getEntries())\n    )\n    const mainEntries = ['resource', 'navigation', 'longtask', 'paint']\n    const experimentalEntries = ['largest-contentful-paint', 'first-input', 'layout-shift']\n\n    try {\n      // Experimental entries are not retrieved by performance.getEntries()\n      // use a single PerformanceObserver with buffered flag by type\n      // to get values that could happen before SDK init\n      experimentalEntries.forEach((type) => {\n        const observer = new PerformanceObserver(handlePerformanceEntryList)\n        observer.observe({ type, buffered: true })\n      })\n    } catch (e) {\n      // Some old browser versions (ex: chrome 67) don't support the PerformanceObserver type and buffered options\n      // In these cases, fallback to PerformanceObserver with entryTypes\n      mainEntries.push(...experimentalEntries)\n    }\n\n    const mainObserver = new PerformanceObserver(handlePerformanceEntryList)\n    mainObserver.observe({ entryTypes: mainEntries })\n\n    if (supportPerformanceObject() && 'addEventListener' in performance) {\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1559377\n      performance.addEventListener('resourcetimingbufferfull', () => {\n        performance.clearResourceTimings()\n      })\n    }\n  }\n  if (!supportPerformanceTimingEvent('navigation')) {\n    retrieveNavigationTiming((timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n  if (!supportPerformanceTimingEvent('first-input')) {\n    retrieveFirstInputTiming((timing) => {\n      handleRumPerformanceEntries(lifeCycle, configuration, [timing])\n    })\n  }\n}\n\nexport function retrieveInitialDocumentResourceTiming(callback: (timing: RumPerformanceResourceTiming) => void) {\n  runOnReadyState('interactive', () => {\n    let timing: RumPerformanceResourceTiming\n\n    const forcedAttributes = {\n      entryType: 'resource' as const,\n      initiatorType: FAKE_INITIAL_DOCUMENT,\n      traceId: getDocumentTraceId(document),\n    }\n    if (supportPerformanceTimingEvent('navigation') && performance.getEntriesByType('navigation').length > 0) {\n      const navigationEntry = performance.getEntriesByType('navigation')[0]\n      timing = assign(navigationEntry.toJSON(), forcedAttributes)\n    } else {\n      const relativePerformanceTiming = computeRelativePerformanceTiming()\n      timing = assign(\n        relativePerformanceTiming,\n        {\n          decodedBodySize: 0,\n          duration: relativePerformanceTiming.responseEnd,\n          name: window.location.href,\n          startTime: 0 as RelativeTime,\n        },\n        forcedAttributes\n      )\n    }\n    callback(timing)\n  })\n}\n\nfunction retrieveNavigationTiming(callback: (timing: RumPerformanceNavigationTiming) => void) {\n  function sendFakeTiming() {\n    callback(\n      assign(computeRelativePerformanceTiming(), {\n        entryType: 'navigation' as const,\n      })\n    )\n  }\n\n  runOnReadyState('complete', () => {\n    // Send it a bit after the actual load event, so the \"loadEventEnd\" timing is accurate\n    setTimeout(monitor(sendFakeTiming))\n  })\n}\n\n/**\n * first-input timing entry polyfill based on\n * https://github.com/GoogleChrome/web-vitals/blob/master/src/lib/polyfills/firstInputPolyfill.ts\n */\nfunction retrieveFirstInputTiming(callback: (timing: RumFirstInputTiming) => void) {\n  const startTimeStamp = dateNow()\n  let timingSent = false\n\n  const { stop: removeEventListeners } = addEventListeners(\n    window,\n    [DOM_EVENT.CLICK, DOM_EVENT.MOUSE_DOWN, DOM_EVENT.KEY_DOWN, DOM_EVENT.TOUCH_START, DOM_EVENT.POINTER_DOWN],\n    (evt) => {\n      // Only count cancelable events, which should trigger behavior important to the user.\n      if (!evt.cancelable) {\n        return\n      }\n\n      // This timing will be used to compute the \"first Input delay\", which is the delta between\n      // when the system received the event (e.g. evt.timeStamp) and when it could run the callback\n      // (e.g. performance.now()).\n      const timing: RumFirstInputTiming = {\n        entryType: 'first-input',\n        processingStart: relativeNow(),\n        startTime: evt.timeStamp as RelativeTime,\n      }\n\n      if (evt.type === DOM_EVENT.POINTER_DOWN) {\n        sendTimingIfPointerIsNotCancelled(timing)\n      } else {\n        sendTiming(timing)\n      }\n    },\n    { passive: true, capture: true }\n  )\n\n  /**\n   * Pointer events are a special case, because they can trigger main or compositor thread behavior.\n   * We differentiate these cases based on whether or not we see a pointercancel event, which are\n   * fired when we scroll. If we're scrolling we don't need to report input delay since FID excludes\n   * scrolling and pinch/zooming.\n   */\n  function sendTimingIfPointerIsNotCancelled(timing: RumFirstInputTiming) {\n    addEventListeners(\n      window,\n      [DOM_EVENT.POINTER_UP, DOM_EVENT.POINTER_CANCEL],\n      (event) => {\n        if (event.type === DOM_EVENT.POINTER_UP) {\n          sendTiming(timing)\n        }\n      },\n      { once: true }\n    )\n  }\n\n  function sendTiming(timing: RumFirstInputTiming) {\n    if (!timingSent) {\n      timingSent = true\n      removeEventListeners()\n      // In some cases the recorded delay is clearly wrong, e.g. it's negative or it's larger than\n      // the time between now and when the page was loaded.\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n      // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n      const delay = timing.processingStart - timing.startTime\n      if (delay >= 0 && delay < dateNow() - startTimeStamp) {\n        callback(timing)\n      }\n    }\n  }\n}\n\nexport type RelativePerformanceTiming = {\n  -readonly [key in keyof Omit<PerformanceTiming, 'toJSON'>]: RelativeTime\n}\n\nfunction computeRelativePerformanceTiming() {\n  const result: Partial<RelativePerformanceTiming> = {}\n  const timing = performance.timing\n  for (const key in timing) {\n    if (isNumber(timing[key as keyof PerformanceTiming])) {\n      const numberKey = key as keyof RelativePerformanceTiming\n      const timingElement = timing[numberKey] as TimeStamp\n      result[numberKey] = timingElement === 0 ? (0 as RelativeTime) : getRelativeTime(timingElement)\n    }\n  }\n  return result as RelativePerformanceTiming\n}\n\nfunction handleRumPerformanceEntries(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  entries: Array<PerformanceEntry | RumPerformanceEntry>\n) {\n  const rumPerformanceEntries = entries.filter(\n    (entry) =>\n      entry.entryType === 'resource' ||\n      entry.entryType === 'navigation' ||\n      entry.entryType === 'paint' ||\n      entry.entryType === 'longtask' ||\n      entry.entryType === 'largest-contentful-paint' ||\n      entry.entryType === 'first-input' ||\n      entry.entryType === 'layout-shift'\n  ) as RumPerformanceEntry[]\n\n  const rumAllowedPerformanceEntries = rumPerformanceEntries.filter(\n    (entry) => !isIncompleteNavigation(entry) && !isForbiddenResource(configuration, entry)\n  )\n\n  if (rumAllowedPerformanceEntries.length) {\n    lifeCycle.notify(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, rumAllowedPerformanceEntries)\n  }\n}\n\nfunction isIncompleteNavigation(entry: RumPerformanceEntry) {\n  return entry.entryType === 'navigation' && entry.loadEventEnd <= 0\n}\n\nfunction isForbiddenResource(configuration: RumConfiguration, entry: RumPerformanceEntry) {\n  return entry.entryType === 'resource' && !isAllowedRequestUrl(configuration, entry.name)\n}\n","import type { RawError } from './error'\nimport { ErrorSource } from './error'\nimport { clocksNow } from './timeUtils'\nimport { ONE_MINUTE } from './utils'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n","import type { Context } from './context'\nimport { deepClone, getType } from './utils'\n\n/**\n * Current limitation:\n * - field path do not support array, 'a.b.c' only\n */\nexport function limitModification<T extends Context, Result>(\n  object: T,\n  modifiableFieldPaths: string[],\n  modifier: (object: T) => Result\n): Result | undefined {\n  const clone = deepClone(object)\n  const result = modifier(clone)\n  modifiableFieldPaths.forEach((path) => {\n    const originalValue = get(object, path)\n    const newValue = get(clone, path)\n    const originalType = getType(originalValue)\n    const newType = getType(newValue)\n    if (newType === originalType) {\n      set(object, path, newValue)\n    } else if (originalType === 'object' && (newType === 'undefined' || newType === 'null')) {\n      set(object, path, {})\n    }\n  })\n  return result\n}\n\nfunction get(object: unknown, path: string) {\n  let current = object\n  for (const field of path.split('.')) {\n    if (!isValidObjectContaining(current, field)) {\n      return\n    }\n    current = current[field]\n  }\n  return current\n}\n\nfunction set(object: unknown, path: string, value: unknown) {\n  let current = object\n  const fields = path.split('.')\n  for (let i = 0; i < fields.length; i += 1) {\n    const field = fields[i]\n    if (!isValidObjectContaining(current, field)) {\n      return\n    }\n    if (i !== fields.length - 1) {\n      current = current[field]\n    } else {\n      current[field] = value\n    }\n  }\n}\n\nfunction isValidObjectContaining(object: unknown, field: string): object is { [key: string]: unknown } {\n  return typeof object === 'object' && object !== null && Object.prototype.hasOwnProperty.call(object, field)\n}\n","import { getSyntheticsResultId, getSyntheticsTestId, willSyntheticsInjectRum } from '@datadog/browser-core'\n\nexport function getSyntheticsContext() {\n  const testId = getSyntheticsTestId()\n  const resultId = getSyntheticsResultId()\n\n  if (testId && resultId) {\n    return {\n      test_id: testId,\n      result_id: resultId,\n      injected: willSyntheticsInjectRum(),\n    }\n  }\n}\n","import type { Context, RawError, EventRateLimiter } from '@datadog/browser-core'\nimport {\n  combine,\n  isEmptyObject,\n  limitModification,\n  timeStampNow,\n  currentDrift,\n  display,\n  createEventRateLimiter,\n  canUseEventBridge,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type {\n  CommonContext,\n  RawRumErrorEvent,\n  RawRumEvent,\n  RawRumLongTaskEvent,\n  RawRumResourceEvent,\n  RumContext,\n  User,\n} from '../rawRumEvent.types'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport { getSyntheticsContext } from './contexts/syntheticsContext'\nimport { getCiTestContext } from './contexts/ciTestContext'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { ViewContexts } from './contexts/viewContexts'\nimport type { RumSessionManager } from './rumSessionManager'\nimport type { UrlContexts } from './contexts/urlContexts'\nimport type { RumConfiguration } from './configuration'\nimport type { ActionContexts } from './rumEventsCollection/action/actionCollection'\nimport { getDisplayContext } from './contexts/displayContext'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst enum SessionType {\n  SYNTHETICS = 'synthetics',\n  USER = 'user',\n  CI_TEST = 'ci_test',\n}\n\nconst VIEW_EVENTS_MODIFIABLE_FIELD_PATHS = [\n  // Fields with sensitive data\n  'view.url',\n  'view.referrer',\n  'action.target.name',\n  'error.message',\n  'error.stack',\n  'error.resource.url',\n  'resource.url',\n]\n\nconst OTHER_EVENTS_MODIFIABLE_FIELD_PATHS = VIEW_EVENTS_MODIFIABLE_FIELD_PATHS.concat([\n  // User-customizable field\n  'context',\n])\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] }\n\nexport function startRumAssembly(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  urlContexts: UrlContexts,\n  actionContexts: ActionContexts,\n  getCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  const eventRateLimiters = {\n    [RumEventType.ERROR]: createEventRateLimiter(\n      RumEventType.ERROR,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n    [RumEventType.ACTION]: createEventRateLimiter(\n      RumEventType.ACTION,\n      configuration.eventRateLimiterThreshold,\n      reportError\n    ),\n  }\n\n  const syntheticsContext = getSyntheticsContext()\n  const ciTestContext = getCiTestContext()\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n    ({ startTime, rawRumEvent, domainContext, savedCommonContext, customerContext }) => {\n      const viewContext = viewContexts.findView(startTime)\n      const urlContext = urlContexts.findUrl(startTime)\n      // allow to send events if the session was tracked when they start\n      // except for views which are continuously updated\n      // TODO: stop sending view updates when session is expired\n      const session = sessionManager.findTrackedSession(rawRumEvent.type !== RumEventType.VIEW ? startTime : undefined)\n      if (session && viewContext && urlContext) {\n        const commonContext = savedCommonContext || getCommonContext()\n        const actionId = actionContexts.findActionId(startTime)\n\n        const rumContext: RumContext = {\n          _dd: {\n            format_version: 2,\n            drift: currentDrift(),\n            session: {\n              plan: session.plan,\n            },\n            browser_sdk_version: canUseEventBridge() ? __BUILD_ENV__SDK_VERSION__ : undefined,\n          },\n          application: {\n            id: configuration.applicationId,\n          },\n          date: timeStampNow(),\n          service: viewContext.service || configuration.service,\n          version: viewContext.version || configuration.version,\n          source: 'browser',\n          session: {\n            id: session.id,\n            type: syntheticsContext ? SessionType.SYNTHETICS : ciTestContext ? SessionType.CI_TEST : SessionType.USER,\n          },\n          view: {\n            id: viewContext.id,\n            name: viewContext.name,\n            url: urlContext.url,\n            referrer: urlContext.referrer,\n          },\n          action: needToAssembleWithAction(rawRumEvent) && actionId ? { id: actionId } : undefined,\n          synthetics: syntheticsContext,\n          ci_test: ciTestContext,\n          display: getDisplayContext(),\n        }\n\n        const serverRumEvent = combine(rumContext as RumContext & Context, rawRumEvent) as RumEvent & Context\n        serverRumEvent.context = combine(commonContext.context, customerContext)\n\n        if (!('has_replay' in serverRumEvent.session)) {\n          ;(serverRumEvent.session as Mutable<RumEvent['session']>).has_replay = commonContext.hasReplay\n        }\n\n        if (!isEmptyObject(commonContext.user)) {\n          ;(serverRumEvent.usr as Mutable<RumEvent['usr']>) = commonContext.user as User & Context\n        }\n\n        if (shouldSend(serverRumEvent, configuration.beforeSend, domainContext, eventRateLimiters)) {\n          if (isEmptyObject(serverRumEvent.context)) {\n            delete serverRumEvent.context\n          }\n          lifeCycle.notify(LifeCycleEventType.RUM_EVENT_COLLECTED, serverRumEvent)\n        }\n      }\n    }\n  )\n}\n\nfunction shouldSend(\n  event: RumEvent & Context,\n  beforeSend: RumConfiguration['beforeSend'],\n  domainContext: RumEventDomainContext,\n  eventRateLimiters: { [key in RumEventType]?: EventRateLimiter }\n) {\n  if (beforeSend) {\n    const result = limitModification(\n      event,\n      event.type === RumEventType.VIEW ? VIEW_EVENTS_MODIFIABLE_FIELD_PATHS : OTHER_EVENTS_MODIFIABLE_FIELD_PATHS,\n      (event) => beforeSend(event, domainContext)\n    )\n    if (result === false && event.type !== RumEventType.VIEW) {\n      return false\n    }\n    if (result === false) {\n      display.warn(\"Can't dismiss view events using beforeSend!\")\n    }\n  }\n\n  const rateLimitReached = eventRateLimiters[event.type]?.isLimitReached()\n  return !rateLimitReached\n}\n\nfunction needToAssembleWithAction(\n  event: RawRumEvent\n): event is RawRumErrorEvent | RawRumResourceEvent | RawRumLongTaskEvent {\n  return [RumEventType.ERROR, RumEventType.RESOURCE, RumEventType.LONG_TASK].indexOf(event.type) !== -1\n}\n","export interface CiTestWindow extends Window {\n  Cypress?: {\n    env: (key: string) => string | undefined\n  }\n}\n\nexport function getCiTestContext() {\n  const testExecutionId = (window as CiTestWindow).Cypress?.env('traceId')\n\n  if (typeof testExecutionId === 'string') {\n    return {\n      test_execution_id: testExecutionId,\n    }\n  }\n}\n","import type { RelativeTime, Duration } from '@datadog/browser-core'\nimport { addDuration, addEventListener, DOM_EVENT, elapsed, relativeNow, toServerDuration } from '@datadog/browser-core'\nimport type { InForegroundPeriod } from '../../rawRumEvent.types'\n\n// Arbitrary value to cap number of element mostly for backend & to save bandwidth\nexport const MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS = 500\n// Arbitrary value to cap number of element mostly for memory consumption in the browser\nexport const MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS = 2500\n\nexport interface ForegroundContexts {\n  isInForegroundAt: (startTime: RelativeTime) => boolean | undefined\n  selectInForegroundPeriodsFor: (startTime: RelativeTime, duration: Duration) => InForegroundPeriod[] | undefined\n  stop: () => void\n}\n\nexport interface ForegroundPeriod {\n  start: RelativeTime\n  end?: RelativeTime\n}\n\nlet foregroundPeriods: ForegroundPeriod[] = []\n\nexport function startForegroundContexts(): ForegroundContexts {\n  if (document.hasFocus()) {\n    addNewForegroundPeriod()\n  }\n\n  const { stop: stopForegroundTracking } = trackFocus(addNewForegroundPeriod)\n  const { stop: stopBlurTracking } = trackBlur(closeForegroundPeriod)\n  return {\n    isInForegroundAt,\n    selectInForegroundPeriodsFor,\n    stop: () => {\n      foregroundPeriods = []\n      stopForegroundTracking()\n      stopBlurTracking()\n    },\n  }\n}\n\nexport function addNewForegroundPeriod() {\n  if (foregroundPeriods.length > MAX_NUMBER_OF_STORED_FOREGROUND_PERIODS) {\n    return\n  }\n  const currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1]\n  const now = relativeNow()\n  if (currentForegroundPeriod !== undefined && currentForegroundPeriod.end === undefined) {\n    return\n  }\n  foregroundPeriods.push({\n    start: now,\n  })\n}\n\nexport function closeForegroundPeriod() {\n  if (foregroundPeriods.length === 0) {\n    return\n  }\n  const currentForegroundPeriod = foregroundPeriods[foregroundPeriods.length - 1]\n  const now = relativeNow()\n  if (currentForegroundPeriod.end !== undefined) {\n    return\n  }\n  currentForegroundPeriod.end = now\n}\n\nfunction trackFocus(onFocusChange: () => void) {\n  return addEventListener(window, DOM_EVENT.FOCUS, (event) => {\n    if (!event.isTrusted) {\n      return\n    }\n    onFocusChange()\n  })\n}\n\nfunction trackBlur(onBlurChange: () => void) {\n  return addEventListener(window, DOM_EVENT.BLUR, (event) => {\n    if (!event.isTrusted) {\n      return\n    }\n    onBlurChange()\n  })\n}\n\nfunction isInForegroundAt(startTime: RelativeTime): boolean {\n  for (let i = foregroundPeriods.length - 1; i >= 0; i--) {\n    const foregroundPeriod = foregroundPeriods[i]\n    if (foregroundPeriod.end !== undefined && startTime > foregroundPeriod.end) {\n      break\n    }\n    if (\n      startTime > foregroundPeriod.start &&\n      (foregroundPeriod.end === undefined || startTime < foregroundPeriod.end)\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction selectInForegroundPeriodsFor(eventStartTime: RelativeTime, duration: Duration): InForegroundPeriod[] {\n  const eventEndTime = addDuration(eventStartTime, duration)\n  const filteredForegroundPeriods: InForegroundPeriod[] = []\n\n  const earliestIndex = Math.max(0, foregroundPeriods.length - MAX_NUMBER_OF_SELECTABLE_FOREGROUND_PERIODS)\n  for (let i = foregroundPeriods.length - 1; i >= earliestIndex; i--) {\n    const foregroundPeriod = foregroundPeriods[i]\n    if (foregroundPeriod.end !== undefined && eventStartTime > foregroundPeriod.end) {\n      // event starts after the end of the current focus period\n      // since the array is sorted, we can stop looking for foreground periods\n      break\n    }\n    if (eventEndTime < foregroundPeriod.start) {\n      // event ends before the start of the current focus period\n      // continue to previous one\n      continue\n    }\n    const startTime = eventStartTime > foregroundPeriod.start ? eventStartTime : foregroundPeriod.start\n    const startDuration = elapsed(eventStartTime, startTime)\n    const endTime =\n      foregroundPeriod.end === undefined || eventEndTime < foregroundPeriod.end ? eventEndTime : foregroundPeriod.end\n    const endDuration = elapsed(startTime, endTime)\n    filteredForegroundPeriods.unshift({\n      start: toServerDuration(startDuration),\n      duration: toServerDuration(endDuration),\n    })\n  }\n  return filteredForegroundPeriods\n}\n","import type { Context, RawError, RelativeTime, Subscription } from '@datadog/browser-core'\nimport type { RumPerformanceEntry } from '../browser/performanceCollection'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { CommonContext, RawRumEvent } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\nimport type { RequestCompleteEvent, RequestStartEvent } from './requestCollection'\nimport type { AutoAction } from './rumEventsCollection/action/actionCollection'\nimport type { ViewEvent, ViewCreatedEvent, ViewEndedEvent } from './rumEventsCollection/view/trackViews'\n\nexport const enum LifeCycleEventType {\n  PERFORMANCE_ENTRIES_COLLECTED,\n  AUTO_ACTION_COMPLETED,\n  VIEW_CREATED,\n  VIEW_UPDATED,\n  VIEW_ENDED,\n  REQUEST_STARTED,\n  REQUEST_COMPLETED,\n\n  // The SESSION_EXPIRED lifecycle event has been introduced to represent when a session has expired\n  // and trigger cleanup tasks related to this, prior to renewing the session. Its implementation is\n  // slightly naive: it is not triggered as soon as the session is expired, but rather just before\n  // notifying that the session is renewed. Thus, the session id is already set to the newly renewed\n  // session.\n  //\n  // This implementation is \"good enough\" for our use-cases. Improving this is not trivial,\n  // primarily because multiple instances of the SDK may be managing the same session cookie at\n  // the same time, for example when using Logs and RUM on the same page, or opening multiple tabs\n  // on the same domain.\n  SESSION_EXPIRED,\n\n  SESSION_RENEWED,\n  BEFORE_UNLOAD,\n  RAW_RUM_EVENT_COLLECTED,\n  RUM_EVENT_COLLECTED,\n  RAW_ERROR_COLLECTED,\n}\n\nexport class LifeCycle {\n  private callbacks: { [key in LifeCycleEventType]?: Array<(data: any) => void> } = {}\n\n  notify(eventType: LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, data: RumPerformanceEntry[]): void\n  notify(eventType: LifeCycleEventType.REQUEST_STARTED, data: RequestStartEvent): void\n  notify(eventType: LifeCycleEventType.REQUEST_COMPLETED, data: RequestCompleteEvent): void\n  notify(eventType: LifeCycleEventType.AUTO_ACTION_COMPLETED, data: AutoAction): void\n  notify(eventType: LifeCycleEventType.VIEW_CREATED, data: ViewCreatedEvent): void\n  notify(eventType: LifeCycleEventType.VIEW_UPDATED, data: ViewEvent): void\n  notify(eventType: LifeCycleEventType.VIEW_ENDED, data: ViewEndedEvent): void\n  notify(\n    eventType: LifeCycleEventType.RAW_ERROR_COLLECTED,\n    data: { error: RawError; savedCommonContext?: CommonContext; customerContext?: Context }\n  ): void\n  notify(\n    eventType:\n      | LifeCycleEventType.SESSION_EXPIRED\n      | LifeCycleEventType.SESSION_RENEWED\n      | LifeCycleEventType.BEFORE_UNLOAD\n  ): void\n  notify(eventType: LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, data: RawRumEventCollectedData): void\n  notify(eventType: LifeCycleEventType.RUM_EVENT_COLLECTED, data: RumEvent & Context): void\n  notify(eventType: LifeCycleEventType, data?: any) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n\n  subscribe(\n    eventType: LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    callback: (data: RumPerformanceEntry[]) => void\n  ): Subscription\n  subscribe(eventType: LifeCycleEventType.REQUEST_STARTED, callback: (data: RequestStartEvent) => void): Subscription\n  subscribe(\n    eventType: LifeCycleEventType.REQUEST_COMPLETED,\n    callback: (data: RequestCompleteEvent) => void\n  ): Subscription\n  subscribe(eventType: LifeCycleEventType.AUTO_ACTION_COMPLETED, callback: (data: AutoAction) => void): Subscription\n  subscribe(eventType: LifeCycleEventType.VIEW_CREATED, callback: (data: ViewCreatedEvent) => void): Subscription\n  subscribe(eventType: LifeCycleEventType.VIEW_UPDATED, callback: (data: ViewEvent) => void): Subscription\n  subscribe(eventType: LifeCycleEventType.VIEW_ENDED, callback: (data: ViewEndedEvent) => void): Subscription\n  subscribe(\n    eventType: LifeCycleEventType.RAW_ERROR_COLLECTED,\n    callback: (data: { error: RawError; savedCommonContext?: CommonContext; customerContext?: Context }) => void\n  ): Subscription\n  subscribe(\n    eventType:\n      | LifeCycleEventType.SESSION_EXPIRED\n      | LifeCycleEventType.SESSION_RENEWED\n      | LifeCycleEventType.BEFORE_UNLOAD,\n    callback: () => void\n  ): Subscription\n  subscribe(\n    eventType: LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n    callback: (data: RawRumEventCollectedData) => void\n  ): Subscription\n  subscribe(\n    eventType: LifeCycleEventType.RUM_EVENT_COLLECTED,\n    callback: (data: RumEvent & Context) => void\n  ): Subscription\n  subscribe(eventType: LifeCycleEventType, callback: (data?: any) => void) {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n\nexport interface RawRumEventCollectedData<E extends RawRumEvent = RawRumEvent> {\n  startTime: RelativeTime\n  savedCommonContext?: CommonContext\n  customerContext?: Context\n  rawRumEvent: E\n  domainContext: RumEventDomainContext<E['type']>\n}\n","import { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod'\nimport { monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { Duration, RelativeTime, ClocksState } from '../tools/timeUtils'\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/timeUtils'\nimport { normalizeUrl } from '../tools/urlPolyfill'\nimport { shallowClone } from '../tools/utils'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startTime: RelativeTime // deprecated\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable() {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable()\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable() {\n  const observable = new Observable<XhrContext>(() => {\n    const { stop: stopInstrumentingStart } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr,\n    })\n\n    const { stop: stopInstrumentingSend } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before() {\n        sendXhr.call(this, observable)\n      },\n    })\n\n    const { stop: stopInstrumentingAbort } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr,\n    })\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n  return observable\n}\n\nfunction openXhr(this: XMLHttpRequest, method: string, url: string | URL | undefined | null) {\n  xhrContexts.set(this, {\n    state: 'open',\n    method,\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(this: XMLHttpRequest, observable: Observable<XhrContext>) {\n  const context = xhrContexts.get(this)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startTime = relativeNow()\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = this\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before() {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd()\n      }\n    },\n  })\n\n  const onEnd = monitor(() => {\n    this.removeEventListener('loadend', onEnd)\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = this.status\n    observable.notify(shallowClone(completeContext))\n  })\n  this.addEventListener('loadend', onEnd)\n  observable.notify(startContext)\n}\n\nfunction abortXhr(this: XMLHttpRequest) {\n  const context = xhrContexts.get(this) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n","import { ONE_HOUR, ONE_MINUTE } from '../../tools/utils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\n","import type { RelativeTime } from './timeUtils'\nimport { relativeNow } from './timeUtils'\nimport type { TimeoutId } from './utils'\nimport { ONE_MINUTE } from './utils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ContextHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  context: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_CONTEXTS_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of contexts spans. This whole class assumes that contexts are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ContextHistory<Context> {\n  private entries: Array<ContextHistoryEntry<Context>> = []\n  private clearOldContextsInterval: TimeoutId\n\n  constructor(private expireDelay: number) {\n    this.clearOldContextsInterval = setInterval(() => this.clearOldContexts(), CLEAR_OLD_CONTEXTS_INTERVAL)\n  }\n\n  /**\n   * Add a context to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(context: Context, startTime: RelativeTime): ContextHistoryEntry<Context> {\n    const entry: ContextHistoryEntry<Context> = {\n      context,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        const index = this.entries.indexOf(entry)\n        if (index >= 0) {\n          this.entries.splice(index, 1)\n        }\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n    this.entries.unshift(entry)\n    return entry\n  }\n\n  /**\n   * Return the latest context that was active during `startTime`, or the currently active context\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  find(startTime: RelativeTime = END_OF_TIMES): Context | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.context\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active context, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all contexts that were active during `startTime`, or all currently active contexts if no\n   * `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES): Context[] {\n    return this.entries\n      .filter((entry) => entry.startTime <= startTime && startTime <= entry.endTime)\n      .map((entry) => entry.context)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldContextsInterval)\n  }\n\n  private clearOldContexts() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n","import { callMonitored, monitor } from './monitor'\nimport { noop } from './utils'\n\nexport function instrumentMethod<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  instrumentationFactory: (\n    original: OBJECT[METHOD]\n  ) => (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => ReturnType<OBJECT[METHOD]>\n) {\n  const original = object[method]\n\n  let instrumentation = instrumentationFactory(original)\n\n  const instrumentationWrapper = function (this: OBJECT): ReturnType<OBJECT[METHOD]> | undefined {\n    if (typeof instrumentation !== 'function') {\n      return undefined\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return instrumentation.apply(this, arguments as unknown as Parameters<OBJECT[METHOD]>)\n  }\n  object[method] = instrumentationWrapper as OBJECT[METHOD]\n\n  return {\n    stop: () => {\n      if (object[method] === instrumentationWrapper) {\n        object[method] = original\n      } else {\n        instrumentation = original\n      }\n    },\n  }\n}\n\nexport function instrumentMethodAndCallOriginal<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  {\n    before,\n    after,\n  }: {\n    before?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n    after?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n  }\n) {\n  return instrumentMethod(\n    object,\n    method,\n    (original) =>\n      function () {\n        const args = arguments as unknown as Parameters<OBJECT[METHOD]>\n        let result\n\n        if (before) {\n          callMonitored(before, this as ThisParameterType<OBJECT[METHOD]>, args)\n        }\n\n        if (typeof original === 'function') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          result = original.apply(this, args)\n        }\n\n        if (after) {\n          callMonitored(after, this as ThisParameterType<OBJECT[METHOD]>, args)\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result\n      }\n  )\n}\n\nexport function instrumentSetter<OBJECT extends { [key: string]: any }, PROPERTY extends keyof OBJECT>(\n  object: OBJECT,\n  property: PROPERTY,\n  after: (thisObject: OBJECT, value: OBJECT[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(object, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  let instrumentation = (thisObject: OBJECT, value: OBJECT[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(\n      monitor(() => {\n        after(thisObject, value)\n      }),\n      0\n    )\n  }\n\n  const instrumentationWrapper = function (this: OBJECT, value: OBJECT[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(object, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(object, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(object, property, originalDescriptor)\n      } else {\n        instrumentation = noop\n      }\n    },\n  }\n}\n","import { instrumentMethod } from '../tools/instrumentMethod'\nimport { callMonitored, monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { Duration, ClocksState } from '../tools/timeUtils'\nimport { elapsed, clocksNow, timeStampNow } from '../tools/timeUtils'\nimport { normalizeUrl } from '../tools/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: RequestInfo\n  init?: RequestInit\n  url: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchCompleteContext extends FetchContextBase {\n  state: 'complete'\n  duration: Duration\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchCompleteContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nfunction createFetchObservable() {\n  const observable = new Observable<FetchContext>(() => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(\n      window,\n      'fetch',\n      (originalFetch) =>\n        function (input, init) {\n          let responsePromise: Promise<Response>\n\n          const context = callMonitored(beforeSend, null, [observable, input, init])\n          if (context) {\n            responsePromise = originalFetch.call(this, context.input, context.init)\n            callMonitored(afterSend, null, [observable, responsePromise, context])\n          } else {\n            responsePromise = originalFetch.call(this, input, init)\n          }\n\n          return responsePromise\n        }\n    )\n\n    return stop\n  })\n\n  return observable\n}\n\nfunction beforeSend(observable: Observable<FetchContext>, input: RequestInfo, init?: RequestInit) {\n  const method = (init && init.method) || (typeof input === 'object' && input.method) || 'GET'\n  const url = normalizeUrl((typeof input === 'object' && input.url) || (input as string))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n  }\n\n  observable.notify(context)\n\n  return context\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const reportFetch = (response: Response | Error) => {\n    const context = startContext as unknown as FetchCompleteContext\n    context.state = 'complete'\n    context.duration = elapsed(context.startClocks.timeStamp, timeStampNow())\n\n    if ('stack' in response || response instanceof Error) {\n      context.status = 0\n      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR\n      context.error = response\n\n      observable.notify(context)\n    } else if ('status' in response) {\n      context.response = response\n      context.responseType = response.type\n      context.status = response.status\n      context.isAborted = false\n\n      observable.notify(context)\n    }\n  }\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch))\n}\n","import { getOrigin, matchList, objectEntries, shallowClone, performDraw, isNumber } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../configuration'\nimport type {\n  RumFetchCompleteContext,\n  RumFetchStartContext,\n  RumXhrCompleteContext,\n  RumXhrStartContext,\n} from '../requestCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\n\nexport interface Tracer {\n  traceFetch: (context: Partial<RumFetchStartContext>) => void\n  traceXhr: (context: Partial<RumXhrStartContext>, xhr: XMLHttpRequest) => void\n  clearTracingIfNeeded: (context: RumFetchCompleteContext | RumXhrCompleteContext) => void\n}\n\ninterface TracingHeaders {\n  [key: string]: string\n}\n\n/**\n * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the\n * request did not reach the server, but the browser does not expose this. So, we clear tracing\n * information if the request ended with status 0 without being aborted by the application.\n *\n * Reasoning:\n *\n * * Applications are usually aborting requests after a bit of time, for example when the user is\n * typing (autocompletion) or navigating away (in a SPA). With a performant device and good\n * network conditions, the request is likely to reach the server before being canceled.\n *\n * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)\n * are likely to finish quickly and without reaching the server.\n *\n * Of course, it might not be the case every time, but it should limit having incomplete traces a\n * bit.\n * */\nexport function clearTracingIfNeeded(context: RumFetchCompleteContext | RumXhrCompleteContext) {\n  if (context.status === 0 && !context.isAborted) {\n    context.traceId = undefined\n    context.spanId = undefined\n    context.traceSampled = undefined\n  }\n}\n\nexport function startTracer(configuration: RumConfiguration, sessionManager: RumSessionManager): Tracer {\n  return {\n    clearTracingIfNeeded,\n    traceFetch: (context) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        if (context.input instanceof Request && !context.init?.headers) {\n          context.input = new Request(context.input)\n          Object.keys(tracingHeaders).forEach((key) => {\n            ;(context.input as Request).headers.append(key, tracingHeaders[key])\n          })\n        } else {\n          context.init = shallowClone(context.init)\n          const headers: string[][] = []\n          if (context.init.headers instanceof Headers) {\n            context.init.headers.forEach((value, key) => {\n              headers.push([key, value])\n            })\n          } else if (Array.isArray(context.init.headers)) {\n            context.init.headers.forEach((header) => {\n              headers.push(header)\n            })\n          } else if (context.init.headers) {\n            Object.keys(context.init.headers).forEach((key) => {\n              headers.push([key, (context.init!.headers as Record<string, string>)[key]])\n            })\n          }\n          context.init.headers = headers.concat(objectEntries(tracingHeaders) as string[][])\n        }\n      }),\n    traceXhr: (context, xhr) =>\n      injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders: TracingHeaders) => {\n        Object.keys(tracingHeaders).forEach((name) => {\n          xhr.setRequestHeader(name, tracingHeaders[name])\n        })\n      }),\n  }\n}\n\nfunction injectHeadersIfTracingAllowed(\n  configuration: RumConfiguration,\n  context: Partial<RumFetchStartContext | RumXhrStartContext>,\n  sessionManager: RumSessionManager,\n  inject: (tracingHeaders: TracingHeaders) => void\n) {\n  if (!isTracingSupported() || !isAllowedUrl(configuration, context.url!) || !sessionManager.findTrackedSession()) {\n    return\n  }\n\n  context.traceId = new TraceIdentifier()\n  context.spanId = new TraceIdentifier()\n  context.traceSampled = !isNumber(configuration.tracingSampleRate) || performDraw(configuration.tracingSampleRate)\n  inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled))\n}\n\nfunction isAllowedUrl(configuration: RumConfiguration, requestUrl: string) {\n  return matchList(configuration.allowedTracingOrigins, getOrigin(requestUrl))\n}\n\nexport function isTracingSupported() {\n  return getCrypto() !== undefined\n}\n\nfunction getCrypto() {\n  return window.crypto || (window as any).msCrypto\n}\n\n/**\n * When trace is not sampled, set priority to '0' instead of not adding the tracing headers\n * to prepare the implementation for sampling delegation.\n */\nfunction makeTracingHeaders(traceId: TraceIdentifier, spanId: TraceIdentifier, traceSampled: boolean): TracingHeaders {\n  return {\n    'x-datadog-origin': 'rum',\n    'x-datadog-parent-id': spanId.toDecimalString(),\n    'x-datadog-sampling-priority': traceSampled ? '1' : '0',\n    'x-datadog-trace-id': traceId.toDecimalString(),\n  }\n}\n\n/* eslint-disable no-bitwise */\nexport class TraceIdentifier {\n  private buffer: Uint8Array = new Uint8Array(8)\n\n  constructor() {\n    getCrypto().getRandomValues(this.buffer)\n    this.buffer[0] = this.buffer[0] & 0x7f // force 63-bit\n  }\n\n  toString(radix: number) {\n    let high = this.readInt32(0)\n    let low = this.readInt32(4)\n    let str = ''\n\n    do {\n      const mod = (high % radix) * 4294967296 + low\n      high = Math.floor(high / radix)\n      low = Math.floor(mod / radix)\n      str = (mod % radix).toString(radix) + str\n    } while (high || low)\n\n    return str\n  }\n\n  /**\n   * Format used everywhere except the trace intake\n   */\n  toDecimalString() {\n    return this.toString(10)\n  }\n\n  private readInt32(offset: number) {\n    return (\n      this.buffer[offset] * 16777216 +\n      (this.buffer[offset + 1] << 16) +\n      (this.buffer[offset + 2] << 8) +\n      this.buffer[offset + 3]\n    )\n  }\n}\n/* eslint-enable no-bitwise */\n","import type {\n  Duration,\n  XhrCompleteContext,\n  XhrStartContext,\n  ClocksState,\n  FetchStartContext,\n  FetchCompleteContext,\n} from '@datadog/browser-core'\nimport { RequestType, initFetchObservable, initXhrObservable } from '@datadog/browser-core'\nimport type { RumSessionManager } from '..'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport { isAllowedRequestUrl } from './rumEventsCollection/resource/resourceUtils'\nimport type { TraceIdentifier, Tracer } from './tracing/tracer'\nimport { startTracer } from './tracing/tracer'\n\nexport interface CustomContext {\n  requestIndex: number\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n}\nexport interface RumFetchStartContext extends FetchStartContext, CustomContext {}\nexport interface RumFetchCompleteContext extends FetchCompleteContext, CustomContext {}\nexport interface RumXhrStartContext extends XhrStartContext, CustomContext {}\nexport interface RumXhrCompleteContext extends XhrCompleteContext, CustomContext {}\n\nexport interface RequestStartEvent {\n  requestIndex: number\n  url: string\n}\n\nexport interface RequestCompleteEvent {\n  requestIndex: number\n  type: RequestType\n  method: string\n  url: string\n  status: number\n  responseType?: string\n  startClocks: ClocksState\n  duration: Duration\n  spanId?: TraceIdentifier\n  traceId?: TraceIdentifier\n  traceSampled?: boolean\n  xhr?: XMLHttpRequest\n  response?: Response\n  input?: RequestInfo\n  init?: RequestInit\n  error?: Error\n}\n\nlet nextRequestIndex = 1\n\nexport function startRequestCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n) {\n  const tracer = startTracer(configuration, sessionManager)\n  trackXhr(lifeCycle, configuration, tracer)\n  trackFetch(lifeCycle, configuration, tracer)\n}\n\nexport function trackXhr(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initXhrObservable().subscribe((rawContext) => {\n    const context = rawContext as RumXhrStartContext | RumXhrCompleteContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceXhr(context, context.xhr)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.XHR,\n          url: context.url,\n          xhr: context.xhr,\n        })\n        break\n    }\n  })\n\n  return { stop: () => subscription.unsubscribe() }\n}\n\nexport function trackFetch(lifeCycle: LifeCycle, configuration: RumConfiguration, tracer: Tracer) {\n  const subscription = initFetchObservable().subscribe((rawContext) => {\n    const context = rawContext as RumFetchCompleteContext | RumFetchStartContext\n    if (!isAllowedRequestUrl(configuration, context.url)) {\n      return\n    }\n\n    switch (context.state) {\n      case 'start':\n        tracer.traceFetch(context)\n        context.requestIndex = getNextRequestIndex()\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_STARTED, {\n          requestIndex: context.requestIndex,\n          url: context.url,\n        })\n        break\n      case 'complete':\n        tracer.clearTracingIfNeeded(context)\n\n        lifeCycle.notify(LifeCycleEventType.REQUEST_COMPLETED, {\n          duration: context.duration,\n          method: context.method,\n          requestIndex: context.requestIndex,\n          responseType: context.responseType,\n          spanId: context.spanId,\n          startClocks: context.startClocks,\n          status: context.status,\n          traceId: context.traceId,\n          traceSampled: context.traceSampled,\n          type: RequestType.FETCH,\n          url: context.url,\n          response: context.response,\n          init: context.init,\n          input: context.input,\n        })\n        break\n    }\n  })\n  return { stop: () => subscription.unsubscribe() }\n}\n\nfunction getNextRequestIndex() {\n  const result = nextRequestIndex\n  nextRequestIndex += 1\n  return result\n}\n","import { noop } from '@datadog/browser-core'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport interface EventCounts {\n  errorCount: number\n  actionCount: number\n  longTaskCount: number\n  resourceCount: number\n  frustrationCount: number\n}\n\nexport function trackEventCounts(lifeCycle: LifeCycle, callback: (eventCounts: EventCounts) => void = noop) {\n  const eventCounts: EventCounts = {\n    errorCount: 0,\n    longTaskCount: 0,\n    resourceCount: 0,\n    actionCount: 0,\n    frustrationCount: 0,\n  }\n\n  const subscription = lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (event): void => {\n    switch (event.type) {\n      case RumEventType.ERROR:\n        eventCounts.errorCount += 1\n        callback(eventCounts)\n        break\n      case RumEventType.ACTION:\n        eventCounts.actionCount += 1\n        if (event.action.frustration) {\n          eventCounts.frustrationCount += event.action.frustration.type.length\n        }\n        callback(eventCounts)\n        break\n      case RumEventType.LONG_TASK:\n        eventCounts.longTaskCount += 1\n        callback(eventCounts)\n        break\n      case RumEventType.RESOURCE:\n        eventCounts.resourceCount += 1\n        callback(eventCounts)\n        break\n    }\n  })\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n    eventCounts,\n  }\n}\n","import type { Subscription, TimeoutId, TimeStamp } from '@datadog/browser-core'\nimport { instrumentMethodAndCallOriginal, matchList, monitor, Observable, timeStampNow } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\n// Delay to wait for a page activity to validate the tracking process\nexport const PAGE_ACTIVITY_VALIDATION_DELAY = 100\n// Delay to wait after a page activity to end the tracking process\nexport const PAGE_ACTIVITY_END_DELAY = 100\n\nexport interface PageActivityEvent {\n  isBusy: boolean\n}\n\nexport type PageActivityEndEvent = { hadActivity: true; end: TimeStamp } | { hadActivity: false }\n\n/**\n * Wait for the page activity end\n *\n * Detection lifecycle:\n * ```\n *                        Wait page activity end\n *              .-------------------'--------------------.\n *              v                                        v\n *     [Wait for a page activity ]          [Wait for a maximum duration]\n *     [timeout: VALIDATION_DELAY]          [  timeout: maxDuration     ]\n *          /                  \\                           |\n *         v                    v                          |\n *  [No page activity]   [Page activity]                   |\n *         |                   |,----------------------.   |\n *         v                   v                       |   |\n *     (Discard)     [Wait for a page activity]        |   |\n *                   [   timeout: END_DELAY   ]        |   |\n *                       /                \\            |   |\n *                      v                  v           |   |\n *             [No page activity]    [Page activity]   |   |\n *                      |                 |            |   |\n *                      |                 '------------'   |\n *                      '-----------. ,--------------------'\n *                                   v\n *                                 (End)\n * ```\n *\n * Note: by assuming that maxDuration is greater than VALIDATION_DELAY, we are sure that if the\n * process is still alive after maxDuration, it has been validated.\n */\nexport function waitPageActivityEnd(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  const pageActivityObservable = createPageActivityObservable(lifeCycle, domMutationObservable, configuration)\n  return doWaitPageActivityEnd(pageActivityObservable, pageActivityEndCallback, maxDuration)\n}\n\nexport function doWaitPageActivityEnd(\n  pageActivityObservable: Observable<PageActivityEvent>,\n  pageActivityEndCallback: (event: PageActivityEndEvent) => void,\n  maxDuration?: number\n) {\n  let pageActivityEndTimeoutId: TimeoutId\n  let hasCompleted = false\n\n  const validationTimeoutId = setTimeout(\n    monitor(() => complete({ hadActivity: false })),\n    PAGE_ACTIVITY_VALIDATION_DELAY\n  )\n  const maxDurationTimeoutId =\n    maxDuration &&\n    setTimeout(\n      monitor(() => complete({ hadActivity: true, end: timeStampNow() })),\n      maxDuration\n    )\n\n  const pageActivitySubscription = pageActivityObservable.subscribe(({ isBusy }) => {\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    const lastChangeTime = timeStampNow()\n    if (!isBusy) {\n      pageActivityEndTimeoutId = setTimeout(\n        monitor(() => complete({ hadActivity: true, end: lastChangeTime })),\n        PAGE_ACTIVITY_END_DELAY\n      )\n    }\n  })\n\n  const stop = () => {\n    hasCompleted = true\n    clearTimeout(validationTimeoutId)\n    clearTimeout(pageActivityEndTimeoutId)\n    clearTimeout(maxDurationTimeoutId)\n    pageActivitySubscription.unsubscribe()\n  }\n\n  function complete(event: PageActivityEndEvent) {\n    if (hasCompleted) {\n      return\n    }\n    stop()\n    pageActivityEndCallback(event)\n  }\n  return { stop }\n}\n\nexport function createPageActivityObservable(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n): Observable<PageActivityEvent> {\n  const observable = new Observable<PageActivityEvent>(() => {\n    const subscriptions: Subscription[] = []\n    let firstRequestIndex: undefined | number\n    let pendingRequestsCount = 0\n\n    subscriptions.push(\n      domMutationObservable.subscribe(notifyPageActivity),\n      lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n        if (entries.some((entry) => entry.entryType === 'resource' && !isExcludedUrl(configuration, entry.name))) {\n          notifyPageActivity()\n        }\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_STARTED, (startEvent) => {\n        if (isExcludedUrl(configuration, startEvent.url)) {\n          return\n        }\n        if (firstRequestIndex === undefined) {\n          firstRequestIndex = startEvent.requestIndex\n        }\n        pendingRequestsCount += 1\n        notifyPageActivity()\n      }),\n      lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request) => {\n        if (\n          isExcludedUrl(configuration, request.url) ||\n          firstRequestIndex === undefined ||\n          // If the request started before the tracking start, ignore it\n          request.requestIndex < firstRequestIndex\n        ) {\n          return\n        }\n        pendingRequestsCount -= 1\n        notifyPageActivity()\n      })\n    )\n\n    const { stop: stopTrackingWindowOpen } = trackWindowOpen(notifyPageActivity)\n\n    return () => {\n      stopTrackingWindowOpen()\n      subscriptions.forEach((s) => s.unsubscribe())\n    }\n\n    function notifyPageActivity() {\n      observable.notify({ isBusy: pendingRequestsCount > 0 })\n    }\n  })\n\n  return observable\n}\n\nfunction isExcludedUrl(configuration: RumConfiguration, requestUrl: string): boolean {\n  return matchList(configuration.excludedActivityUrls, requestUrl)\n}\n\nfunction trackWindowOpen(callback: () => void) {\n  return instrumentMethodAndCallOriginal(window, 'open', { before: callback })\n}\n","import { monitor, ONE_SECOND } from '@datadog/browser-core'\nimport type { Click } from './trackClickActions'\n\nexport interface ClickChain {\n  tryAppend: (click: Click) => boolean\n  stop: () => void\n}\n\nexport const MAX_DURATION_BETWEEN_CLICKS = ONE_SECOND\nexport const MAX_DISTANCE_BETWEEN_CLICKS = 100\n\nconst enum ClickChainStatus {\n  WaitingForMoreClicks,\n  WaitingForClicksToStop,\n  Finalized,\n}\n\nexport function createClickChain(firstClick: Click, onFinalize: (clicks: Click[]) => void): ClickChain {\n  const bufferedClicks: Click[] = []\n  let status = ClickChainStatus.WaitingForMoreClicks\n  let maxDurationBetweenClicksTimeout: number | undefined\n  appendClick(firstClick)\n\n  function appendClick(click: Click) {\n    click.stopObservable.subscribe(tryFinalize)\n    bufferedClicks.push(click)\n    clearTimeout(maxDurationBetweenClicksTimeout)\n    maxDurationBetweenClicksTimeout = setTimeout(monitor(dontAcceptMoreClick), MAX_DURATION_BETWEEN_CLICKS)\n  }\n\n  function tryFinalize() {\n    if (status === ClickChainStatus.WaitingForClicksToStop && bufferedClicks.every((click) => click.isStopped())) {\n      status = ClickChainStatus.Finalized\n      onFinalize(bufferedClicks)\n    }\n  }\n\n  function dontAcceptMoreClick() {\n    clearTimeout(maxDurationBetweenClicksTimeout)\n    if (status === ClickChainStatus.WaitingForMoreClicks) {\n      status = ClickChainStatus.WaitingForClicksToStop\n      tryFinalize()\n    }\n  }\n\n  return {\n    tryAppend: (click) => {\n      if (status !== ClickChainStatus.WaitingForMoreClicks) {\n        return false\n      }\n\n      if (\n        bufferedClicks.length > 0 &&\n        !areEventsSimilar(bufferedClicks[bufferedClicks.length - 1].event, click.event)\n      ) {\n        dontAcceptMoreClick()\n        return false\n      }\n\n      appendClick(click)\n      return true\n    },\n    stop: () => {\n      dontAcceptMoreClick()\n    },\n  }\n}\n\n/**\n * Checks whether two events are similar by comparing their target, position and timestamp\n */\nfunction areEventsSimilar(first: MouseEvent, second: MouseEvent) {\n  return (\n    first.target === second.target &&\n    mouseEventDistance(first, second) <= MAX_DISTANCE_BETWEEN_CLICKS &&\n    first.timeStamp - second.timeStamp <= MAX_DURATION_BETWEEN_CLICKS\n  )\n}\n\nfunction mouseEventDistance(origin: MouseEvent, other: MouseEvent) {\n  return Math.sqrt(Math.pow(origin.clientX - other.clientX, 2) + Math.pow(origin.clientY - other.clientY, 2))\n}\n","import { safeTruncate, isIE, find } from '@datadog/browser-core'\n\n/**\n * Get the action name from the attribute 'data-dd-action-name' on the element or any of its parent.\n * It can also be retrieved from a user defined attribute.\n */\nexport const DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE = 'data-dd-action-name'\n\nexport function getActionNameFromElement(element: Element, userProgrammaticAttribute?: string): string {\n  // Proceed to get the action name in two steps:\n  // * first, get the name programmatically, explicitly defined by the user.\n  // * then, use strategies that are known to return good results. Those strategies will be used on\n  //   the element and a few parents, but it's likely that they won't succeed at all.\n  // * if no name is found this way, use strategies returning less accurate names as a fallback.\n  //   Those are much likely to succeed.\n  return (\n    getActionNameFromElementProgrammatically(element, DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE) ||\n    (userProgrammaticAttribute && getActionNameFromElementProgrammatically(element, userProgrammaticAttribute)) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, priorityStrategies) ||\n    getActionNameFromElementForStrategies(element, userProgrammaticAttribute, fallbackStrategies) ||\n    ''\n  )\n}\n\nfunction getActionNameFromElementProgrammatically(targetElement: Element, programmaticAttribute: string) {\n  let elementWithAttribute\n  // We don't use getActionNameFromElementForStrategies here, because we want to consider all parents,\n  // without limit. It is up to the user to declare a relevant naming strategy.\n  // If available, use element.closest() to match get the attribute from the element or any of its\n  // parent.  Else fallback to a more traditional implementation.\n  if (supportsElementClosest()) {\n    elementWithAttribute = targetElement.closest(`[${programmaticAttribute}]`)\n  } else {\n    let element: Element | null = targetElement\n    while (element) {\n      if (element.hasAttribute(programmaticAttribute)) {\n        elementWithAttribute = element\n        break\n      }\n      element = element.parentElement\n    }\n  }\n\n  if (!elementWithAttribute) {\n    return\n  }\n  const name = elementWithAttribute.getAttribute(programmaticAttribute)!\n  return truncate(normalizeWhitespace(name.trim()))\n}\n\ntype NameStrategy = (\n  element: Element | HTMLElement | HTMLInputElement | HTMLSelectElement,\n  userProgrammaticAttribute: string | undefined\n) => string | undefined | null\n\nconst priorityStrategies: NameStrategy[] = [\n  // associated LABEL text\n  (element, userProgrammaticAttribute) => {\n    // IE does not support element.labels, so we fallback to a CSS selector based on the element id\n    // instead\n    if (supportsLabelProperty()) {\n      if ('labels' in element && element.labels && element.labels.length > 0) {\n        return getTextualContent(element.labels[0], userProgrammaticAttribute)\n      }\n    } else if (element.id) {\n      const label =\n        element.ownerDocument &&\n        find(element.ownerDocument.querySelectorAll('label'), (label) => label.htmlFor === element.id)\n      return label && getTextualContent(label, userProgrammaticAttribute)\n    }\n  },\n  // INPUT button (and associated) value\n  (element) => {\n    if (element.nodeName === 'INPUT') {\n      const input = element as HTMLInputElement\n      const type = input.getAttribute('type')\n      if (type === 'button' || type === 'submit' || type === 'reset') {\n        return input.value\n      }\n    }\n  },\n  // BUTTON, LABEL or button-like element text\n  (element, userProgrammaticAttribute) => {\n    if (element.nodeName === 'BUTTON' || element.nodeName === 'LABEL' || element.getAttribute('role') === 'button') {\n      return getTextualContent(element, userProgrammaticAttribute)\n    }\n  },\n  (element) => element.getAttribute('aria-label'),\n  // associated element text designated by the aria-labelledby attribute\n  (element, userProgrammaticAttribute) => {\n    const labelledByAttribute = element.getAttribute('aria-labelledby')\n    if (labelledByAttribute) {\n      return labelledByAttribute\n        .split(/\\s+/)\n        .map((id) => getElementById(element, id))\n        .filter((label): label is HTMLElement => Boolean(label))\n        .map((element) => getTextualContent(element, userProgrammaticAttribute))\n        .join(' ')\n    }\n  },\n  (element) => element.getAttribute('alt'),\n  (element) => element.getAttribute('name'),\n  (element) => element.getAttribute('title'),\n  (element) => element.getAttribute('placeholder'),\n  // SELECT first OPTION text\n  (element, userProgrammaticAttribute) => {\n    if ('options' in element && element.options.length > 0) {\n      return getTextualContent(element.options[0], userProgrammaticAttribute)\n    }\n  },\n]\n\nconst fallbackStrategies: NameStrategy[] = [\n  (element, userProgrammaticAttribute) => getTextualContent(element, userProgrammaticAttribute),\n]\n\n/**\n * Iterates over the target element and its parent, using the strategies list to get an action name.\n * Each strategies are applied on each element, stopping as soon as a non-empty value is returned.\n */\nconst MAX_PARENTS_TO_CONSIDER = 10\nfunction getActionNameFromElementForStrategies(\n  targetElement: Element,\n  userProgrammaticAttribute: string | undefined,\n  strategies: NameStrategy[]\n) {\n  let element: Element | null = targetElement\n  let recursionCounter = 0\n  while (\n    recursionCounter <= MAX_PARENTS_TO_CONSIDER &&\n    element &&\n    element.nodeName !== 'BODY' &&\n    element.nodeName !== 'HTML' &&\n    element.nodeName !== 'HEAD'\n  ) {\n    for (const strategy of strategies) {\n      const name = strategy(element, userProgrammaticAttribute)\n      if (typeof name === 'string') {\n        const trimmedName = name.trim()\n        if (trimmedName) {\n          return truncate(normalizeWhitespace(trimmedName))\n        }\n      }\n    }\n    // Consider a FORM as a contextual limit to get the action name.  This is experimental and may\n    // be reconsidered in the future.\n    if (element.nodeName === 'FORM') {\n      break\n    }\n    element = element.parentElement\n    recursionCounter += 1\n  }\n}\n\nfunction normalizeWhitespace(s: string) {\n  return s.replace(/\\s+/g, ' ')\n}\n\nfunction truncate(s: string) {\n  return s.length > 100 ? `${safeTruncate(s, 100)} [...]` : s\n}\n\nfunction getElementById(refElement: Element, id: string) {\n  // Use the element ownerDocument here, because tests are executed in an iframe, so\n  // document.getElementById won't work.\n  return refElement.ownerDocument ? refElement.ownerDocument.getElementById(id) : null\n}\n\nfunction getTextualContent(element: Element | HTMLElement, userProgrammaticAttribute: string | undefined) {\n  if ((element as HTMLElement).isContentEditable) {\n    return\n  }\n\n  if ('innerText' in element) {\n    let text = element.innerText\n\n    const removeTextFromElements = (query: string) => {\n      const list = element.querySelectorAll<Element | HTMLElement>(query)\n      for (let index = 0; index < list.length; index += 1) {\n        const element = list[index]\n        if ('innerText' in element) {\n          const textToReplace = element.innerText\n          if (textToReplace && textToReplace.trim().length > 0) {\n            text = text.replace(textToReplace, '')\n          }\n        }\n      }\n    }\n\n    if (!supportsInnerTextScriptAndStyleRemoval()) {\n      // remove the inner text of SCRIPT and STYLES from the result. This is a bit dirty, but should\n      // be relatively fast and work in most cases.\n      removeTextFromElements('script, style')\n    }\n\n    // remove the text of elements with programmatic attribute value\n    removeTextFromElements(`[${DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE}]`)\n\n    if (userProgrammaticAttribute) {\n      removeTextFromElements(`[${userProgrammaticAttribute}]`)\n    }\n\n    return text\n  }\n\n  return element.textContent\n}\n\n/**\n * Returns true if element.innerText excludes the text from inline SCRIPT and STYLE element. This\n * should be the case everywhere except on Internet Explorer 10 and 11 (see [1])\n *\n * The innerText property relies on what is actually rendered to compute its output, so to check if\n * it actually excludes SCRIPT and STYLE content, a solution would be to create a style element, set\n * its content to '*', inject it in the document body, and check if the style element innerText\n * property returns '*'. Using a new `document` instance won't work as it is not rendered.\n *\n * This solution requires specific CSP rules (see [2]) to be set by the customer. We want to avoid\n * this, so instead we rely on browser detection. In case of false negative, the impact should be\n * low, since we rely on this result to remove the SCRIPT and STYLE innerText (which will be empty)\n * from a parent element innerText.\n *\n * [1]: https://web.archive.org/web/20210602165716/http://perfectionkills.com/the-poor-misunderstood-innerText/#diff-with-textContent\n * [2]: https://github.com/DataDog/browser-sdk/issues/1084\n */\nfunction supportsInnerTextScriptAndStyleRemoval() {\n  return !isIE()\n}\n\n/**\n * Returns true if the browser supports the element.labels property.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsLabelPropertyResult: boolean | undefined\nfunction supportsLabelProperty() {\n  if (supportsLabelPropertyResult === undefined) {\n    supportsLabelPropertyResult = 'labels' in HTMLInputElement.prototype\n  }\n  return supportsLabelPropertyResult\n}\n\n/**\n * Returns true if the browser supports the element.closest method.  This should be the case\n * everywhere except on Internet Explorer.\n * Note: The result is computed lazily, because we don't want any DOM access when the SDK is\n * evaluated.\n */\nlet supportsElementClosestResult: boolean | undefined\nfunction supportsElementClosest() {\n  if (supportsElementClosestResult === undefined) {\n    supportsElementClosestResult = 'closest' in HTMLElement.prototype\n  }\n  return supportsElementClosestResult\n}\n","export function isIE() {\n  return Boolean((document as any).documentMode)\n}\n\nexport function isChromium() {\n  return !!(window as any).chrome || /HeadlessChrome/.test(window.navigator.userAgent)\n}\n","import { cssEscape } from '@datadog/browser-core'\nimport { DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE } from './getActionNameFromElement'\n\n/**\n * Stable attributes are attributes that are commonly used to identify parts of a UI (ex:\n * component). Those attribute values should not be generated randomly (hardcoded most of the time)\n * and stay the same across deploys. They are not necessarily unique across the document.\n */\nexport const STABLE_ATTRIBUTES = [\n  DEFAULT_PROGRAMMATIC_ACTION_NAME_ATTRIBUTE,\n  // Common test attributes (list provided by google recorder)\n  'data-testid',\n  'data-test',\n  'data-qa',\n  'data-cy',\n  'data-test-id',\n  'data-qa-id',\n  'data-testing',\n  // FullStory decorator attributes:\n  'data-component',\n  'data-element',\n  'data-source-file',\n]\n\nexport function getSelectorsFromElement(element: Element, actionNameAttribute: string | undefined) {\n  let attributeSelectors = getStableAttributeSelectors()\n  if (actionNameAttribute) {\n    attributeSelectors = [(element: Element) => getAttributeSelector(actionNameAttribute, element)].concat(\n      attributeSelectors\n    )\n  }\n  const globallyUniqueSelectorStrategies = attributeSelectors.concat(getIDSelector)\n  const uniqueAmongChildrenSelectorStrategies = attributeSelectors.concat([getClassSelector, getTagNameSelector])\n  return {\n    selector: getSelectorFromElement(element, globallyUniqueSelectorStrategies, uniqueAmongChildrenSelectorStrategies),\n    selector_combined: getSelectorFromElement(\n      element,\n      globallyUniqueSelectorStrategies,\n      uniqueAmongChildrenSelectorStrategies,\n      { useCombinedSelectors: true }\n    ),\n    selector_stopping_when_unique: getSelectorFromElement(\n      element,\n      globallyUniqueSelectorStrategies.concat([getClassSelector, getTagNameSelector]),\n      uniqueAmongChildrenSelectorStrategies\n    ),\n    selector_all_together: getSelectorFromElement(\n      element,\n      globallyUniqueSelectorStrategies.concat([getClassSelector, getTagNameSelector]),\n      uniqueAmongChildrenSelectorStrategies,\n      { useCombinedSelectors: true }\n    ),\n  }\n}\n\ntype GetSelector = (element: Element) => string | undefined\n\nfunction isGeneratedValue(value: string) {\n  // To compute the \"URL path group\", the backend replaces every URL path parts as a question mark\n  // if it thinks the part is an identifier. The condition it uses is to checks whether a digit is\n  // present.\n  //\n  // Here, we use the same strategy: if a the value contains a digit, we consider it generated. This\n  // strategy might be a bit naive and fail in some cases, but there are many fallbacks to generate\n  // CSS selectors so it should be fine most of the time. We might want to allow customers to\n  // provide their own `isGeneratedValue` at some point.\n  return /[0-9]/.test(value)\n}\n\nfunction getSelectorFromElement(\n  targetElement: Element,\n  globallyUniqueSelectorStrategies: GetSelector[],\n  uniqueAmongChildrenSelectorStrategies: GetSelector[],\n  { useCombinedSelectors = false } = {}\n): string {\n  let targetElementSelector = ''\n  let element: Element | null = targetElement\n\n  while (element && element.nodeName !== 'HTML') {\n    const globallyUniqueSelector = findSelector(\n      element,\n      globallyUniqueSelectorStrategies,\n      isSelectorUniqueGlobally,\n      useCombinedSelectors ? targetElementSelector : undefined\n    )\n    if (globallyUniqueSelector) {\n      return combineSelector(globallyUniqueSelector, targetElementSelector)\n    }\n\n    const uniqueSelectorAmongChildren = findSelector(\n      element,\n      uniqueAmongChildrenSelectorStrategies,\n      isSelectorUniqueAmongSiblings,\n      useCombinedSelectors ? targetElementSelector : undefined\n    )\n    targetElementSelector = combineSelector(\n      uniqueSelectorAmongChildren || getPositionSelector(element) || getTagNameSelector(element),\n      targetElementSelector\n    )\n\n    element = element.parentElement\n  }\n\n  return targetElementSelector\n}\n\nfunction getIDSelector(element: Element): string | undefined {\n  if (element.id && !isGeneratedValue(element.id)) {\n    return `#${cssEscape(element.id)}`\n  }\n}\n\nfunction getClassSelector(element: Element): string | undefined {\n  if (element.tagName === 'BODY') {\n    return\n  }\n  if (element.classList.length > 0) {\n    for (let i = 0; i < element.classList.length; i += 1) {\n      const className = element.classList[i]\n      if (isGeneratedValue(className)) {\n        continue\n      }\n\n      return `${element.tagName}.${cssEscape(className)}`\n    }\n  }\n}\n\nfunction getTagNameSelector(element: Element): string {\n  return element.tagName\n}\n\nlet stableAttributeSelectorsCache: GetSelector[] | undefined\nfunction getStableAttributeSelectors() {\n  if (!stableAttributeSelectorsCache) {\n    stableAttributeSelectorsCache = STABLE_ATTRIBUTES.map(\n      (attribute) => (element: Element) => getAttributeSelector(attribute, element)\n    )\n  }\n  return stableAttributeSelectorsCache\n}\n\nfunction getAttributeSelector(attributeName: string, element: Element): string | undefined {\n  if (element.hasAttribute(attributeName)) {\n    return `${element.tagName}[${attributeName}=\"${cssEscape(element.getAttribute(attributeName)!)}\"]`\n  }\n}\n\nfunction getPositionSelector(element: Element): string | undefined {\n  const parent = element.parentElement!\n  let sibling = parent.firstElementChild\n  let currentIndex = 0\n  let elementIndex: number | undefined\n\n  while (sibling) {\n    if (sibling.tagName === element.tagName) {\n      currentIndex += 1\n      if (sibling === element) {\n        elementIndex = currentIndex\n      }\n\n      if (elementIndex !== undefined && currentIndex > 1) {\n        // Performance improvement: avoid iterating over all children, stop as soon as we are sure\n        // the element is not alone\n        break\n      }\n    }\n    sibling = sibling.nextElementSibling\n  }\n\n  return currentIndex > 1 ? `${element.tagName}:nth-of-type(${elementIndex!})` : undefined\n}\n\nfunction findSelector(\n  element: Element,\n  selectorGetters: GetSelector[],\n  predicate: (element: Element, selector: string) => boolean,\n  childSelector?: string\n) {\n  for (const selectorGetter of selectorGetters) {\n    const elementSelector = selectorGetter(element)\n    const fullSelector = elementSelector && combineSelector(elementSelector, childSelector)\n    if (fullSelector && predicate(element, fullSelector)) {\n      return elementSelector\n    }\n  }\n}\n\n/**\n * Check whether the selector is unique among the whole document.\n */\nfunction isSelectorUniqueGlobally(element: Element, selector: string): boolean {\n  return element.ownerDocument.querySelectorAll(selector).length === 1\n}\n\n/**\n * Check whether the selector is unique among the element siblings. In other words, it returns true\n * if \"ELEMENT_PARENT > SELECTOR\" returns a single element.\n *\n * The result will be less accurate on browsers that don't support :scope (i. e. IE): it will check\n * for any element matching the selector contained in the parent (in other words,\n * \"ELEMENT_PARENT SELECTOR\" returns a single element), regardless of whether the selector is a\n * direct descendent of the element parent. This should not impact results too much: if it\n * inaccurately returns false, we'll just fall back to another strategy.\n */\nfunction isSelectorUniqueAmongSiblings(element: Element, selector: string): boolean {\n  return (\n    element.parentElement!.querySelectorAll(supportScopeSelector() ? combineSelector(':scope', selector) : selector)\n      .length === 1\n  )\n}\n\nfunction combineSelector(parent: string, child: string | undefined): string {\n  return child ? `${parent}>${child}` : parent\n}\n\nlet supportScopeSelectorCache: boolean | undefined\nexport function supportScopeSelector() {\n  if (supportScopeSelectorCache === undefined) {\n    try {\n      document.querySelector(':scope')\n      supportScopeSelectorCache = true\n    } catch {\n      supportScopeSelectorCache = false\n    }\n  }\n  return supportScopeSelectorCache\n}\n","import { addEventListener, DOM_EVENT, monitor } from '@datadog/browser-core'\n\nexport type MouseEventOnElement = MouseEvent & { target: Element }\n\nexport type GetUserActivity = () => { selection: boolean; input: boolean }\nexport interface ActionEventsHooks<ClickContext> {\n  onPointerDown: (event: MouseEventOnElement) => ClickContext | undefined\n  onClick: (context: ClickContext, event: MouseEventOnElement, getUserActivity: GetUserActivity) => void\n}\n\nexport function listenActionEvents<ClickContext>({ onPointerDown, onClick }: ActionEventsHooks<ClickContext>) {\n  let hasSelectionChanged = false\n  let selectionEmptyAtPointerDown: boolean\n  let hasInputChanged = false\n  let clickContext: ClickContext | undefined\n\n  const listeners = [\n    addEventListener(\n      window,\n      DOM_EVENT.POINTER_DOWN,\n      (event) => {\n        hasSelectionChanged = false\n        selectionEmptyAtPointerDown = isSelectionEmpty()\n        if (isMouseEventOnElement(event)) {\n          clickContext = onPointerDown(event)\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.SELECTION_CHANGE,\n      () => {\n        if (!selectionEmptyAtPointerDown || !isSelectionEmpty()) {\n          hasSelectionChanged = true\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.CLICK,\n      (clickEvent: MouseEvent) => {\n        if (isMouseEventOnElement(clickEvent) && clickContext) {\n          // Use a scoped variable to make sure the value is not changed by other clicks\n          const userActivity = {\n            selection: hasSelectionChanged,\n            input: hasInputChanged,\n          }\n          if (!hasInputChanged) {\n            setTimeout(\n              monitor(() => {\n                userActivity.input = hasInputChanged\n              })\n            )\n          }\n\n          onClick(clickContext, clickEvent, () => userActivity)\n          clickContext = undefined\n        }\n      },\n      { capture: true }\n    ),\n\n    addEventListener(\n      window,\n      DOM_EVENT.INPUT,\n      () => {\n        hasInputChanged = true\n      },\n      { capture: true }\n    ),\n  ]\n\n  return {\n    stop: () => {\n      listeners.forEach((listener) => listener.stop())\n    },\n  }\n}\n\nfunction isSelectionEmpty(): boolean {\n  const selection = window.getSelection()\n  return !selection || selection.isCollapsed\n}\n\nfunction isMouseEventOnElement(event: Event): event is MouseEventOnElement {\n  return event.target instanceof Element\n}\n","import { elementMatches, ONE_SECOND } from '@datadog/browser-core'\nimport { FrustrationType } from '../../../rawRumEvent.types'\nimport type { Click } from './trackClickActions'\n\nconst MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE = 3\n\nexport function computeFrustration(clicks: Click[], rageClick: Click) {\n  if (isRage(clicks)) {\n    rageClick.addFrustration(FrustrationType.RAGE_CLICK)\n    if (clicks.some(isDead)) {\n      rageClick.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n    if (rageClick.hasError) {\n      rageClick.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    return { isRage: true }\n  }\n\n  const hasSelectionChanged = clicks.some((click) => click.getUserActivity().selection)\n  clicks.forEach((click) => {\n    if (click.hasError) {\n      click.addFrustration(FrustrationType.ERROR_CLICK)\n    }\n    if (\n      isDead(click) &&\n      // Avoid considering clicks part of a double-click or triple-click selections as dead clicks\n      !hasSelectionChanged\n    ) {\n      click.addFrustration(FrustrationType.DEAD_CLICK)\n    }\n  })\n  return { isRage: false }\n}\n\nexport function isRage(clicks: Click[]) {\n  if (clicks.some((click) => click.getUserActivity().selection)) {\n    return false\n  }\n  for (let i = 0; i < clicks.length - (MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1); i += 1) {\n    if (\n      clicks[i + MIN_CLICKS_PER_SECOND_TO_CONSIDER_RAGE - 1].event.timeStamp - clicks[i].event.timeStamp <=\n      ONE_SECOND\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nconst DEAD_CLICK_EXCLUDE_SELECTOR =\n  // inputs that don't trigger a meaningful event like \"input\" when clicked, including textual\n  // inputs (using a negative selector is shorter here)\n  'input:not([type=\"checkbox\"]):not([type=\"radio\"]):not([type=\"button\"]):not([type=\"submit\"]):not([type=\"reset\"]):not([type=\"range\"]),' +\n  'textarea,' +\n  'select,' +\n  // canvas, as there is no good way to detect activity occurring on them\n  'canvas,' +\n  // links that are interactive (have an href attribute) or any of their descendants, as they can\n  // open a new tab or navigate to a hash without triggering a meaningful event\n  'a[href],' +\n  'a[href] *'\n\nexport function isDead(click: Click) {\n  if (click.hasPageActivity || click.getUserActivity().input) {\n    return false\n  }\n  return !elementMatches(click.event.target, DEAD_CLICK_EXCLUDE_SELECTOR)\n}\n","import type { Duration, ClocksState, RelativeTime, TimeStamp } from '@datadog/browser-core'\nimport {\n  timeStampNow,\n  isExperimentalFeatureEnabled,\n  Observable,\n  assign,\n  getRelativeTime,\n  ONE_MINUTE,\n  ContextHistory,\n  generateUUID,\n  clocksNow,\n  ONE_SECOND,\n  elapsed,\n} from '@datadog/browser-core'\nimport type { FrustrationType } from '../../../rawRumEvent.types'\nimport { ActionType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { trackEventCounts } from '../../trackEventCounts'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\nimport type { ClickChain } from './clickChain'\nimport { createClickChain } from './clickChain'\nimport { getActionNameFromElement } from './getActionNameFromElement'\nimport { getSelectorsFromElement } from './getSelectorsFromElement'\nimport type { MouseEventOnElement, GetUserActivity } from './listenActionEvents'\nimport { listenActionEvents } from './listenActionEvents'\nimport { computeFrustration } from './computeFrustration'\n\ninterface ActionCounts {\n  errorCount: number\n  longTaskCount: number\n  resourceCount: number\n}\n\nexport interface ClickAction {\n  type: ActionType.CLICK\n  id: string\n  name: string\n  target?: {\n    selector: string\n    selector_with_stable_attributes?: string\n    width: number\n    height: number\n  }\n  position?: { x: number; y: number }\n  startClocks: ClocksState\n  duration?: Duration\n  counts: ActionCounts\n  event: MouseEventOnElement\n  frustrationTypes: FrustrationType[]\n  events: Event[]\n}\n\nexport interface ActionContexts {\n  findActionId: (startTime?: RelativeTime) => string | string[] | undefined\n}\n\ntype ClickActionIdHistory = ContextHistory<ClickAction['id']>\n\n// Maximum duration for click actions\nexport const CLICK_ACTION_MAX_DURATION = 10 * ONE_SECOND\nexport const ACTION_CONTEXT_TIME_OUT_DELAY = 5 * ONE_MINUTE // arbitrary\n\nexport function trackClickActions(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration\n) {\n  const history: ClickActionIdHistory = new ContextHistory(ACTION_CONTEXT_TIME_OUT_DELAY)\n  const stopObservable = new Observable<void>()\n  let currentClickChain: ClickChain | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    history.reset()\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, stopClickChain)\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, stopClickChain)\n\n  const { stop: stopActionEventsListener } = listenActionEvents<ClickActionBase>({\n    onPointerDown: (pointerDownEvent) => processPointerDown(configuration, history, pointerDownEvent),\n    onClick: (clickActionBase, clickEvent, getUserActivity) =>\n      processClick(\n        configuration,\n        lifeCycle,\n        domMutationObservable,\n        history,\n        stopObservable,\n        appendClickToClickChain,\n        clickActionBase,\n        clickEvent,\n        getUserActivity\n      ),\n  })\n\n  const actionContexts: ActionContexts = {\n    findActionId: (startTime?: RelativeTime) =>\n      configuration.trackFrustrations ? history.findAll(startTime) : history.find(startTime),\n  }\n\n  return {\n    stop: () => {\n      stopClickChain()\n      stopObservable.notify()\n      stopActionEventsListener()\n    },\n    actionContexts,\n  }\n\n  function appendClickToClickChain(click: Click) {\n    if (!currentClickChain || !currentClickChain.tryAppend(click)) {\n      const rageClick = click.clone()\n      currentClickChain = createClickChain(click, (clicks) => {\n        finalizeClicks(clicks, rageClick)\n      })\n    }\n  }\n\n  function stopClickChain() {\n    if (currentClickChain) {\n      currentClickChain.stop()\n    }\n  }\n}\n\nfunction processPointerDown(\n  configuration: RumConfiguration,\n  history: ClickActionIdHistory,\n  pointerDownEvent: MouseEventOnElement\n) {\n  if (!configuration.trackFrustrations && history.find()) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any new\n    // action if another one is already occurring.\n    return\n  }\n\n  const clickActionBase = computeClickActionBase(pointerDownEvent, configuration.actionNameAttribute)\n  if (!configuration.trackFrustrations && !clickActionBase.name) {\n    // TODO: remove this in a future major version. To keep retrocompatibility, ignore any action\n    // with a blank name\n    return\n  }\n\n  return clickActionBase\n}\n\nfunction processClick(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  history: ClickActionIdHistory,\n  stopObservable: Observable<void>,\n  appendClickToClickChain: (click: Click) => void,\n  clickActionBase: ClickActionBase,\n  clickEvent: MouseEventOnElement,\n  getUserActivity: GetUserActivity\n) {\n  const click = newClick(lifeCycle, history, getUserActivity, clickActionBase, clickEvent)\n\n  if (configuration.trackFrustrations) {\n    appendClickToClickChain(click)\n  }\n\n  const { stop: stopWaitPageActivityEnd } = waitPageActivityEnd(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    (pageActivityEndEvent) => {\n      if (pageActivityEndEvent.hadActivity && pageActivityEndEvent.end < click.startClocks.timeStamp) {\n        // If the clock is looking weird, just discard the click\n        click.discard()\n      } else {\n        click.stop(pageActivityEndEvent.hadActivity ? pageActivityEndEvent.end : undefined)\n\n        // Validate or discard the click only if we don't track frustrations. It'll be done when\n        // the click chain is finalized.\n        if (!configuration.trackFrustrations) {\n          if (!pageActivityEndEvent.hadActivity) {\n            // If we are not tracking frustrations, we should discard the click to keep backward\n            // compatibility.\n            click.discard()\n          } else {\n            click.validate()\n          }\n        }\n      }\n    },\n    CLICK_ACTION_MAX_DURATION\n  )\n\n  const viewEndedSubscription = lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    click.stop(endClocks.timeStamp)\n  })\n\n  const stopSubscription = stopObservable.subscribe(() => {\n    click.stop()\n  })\n\n  click.stopObservable.subscribe(() => {\n    viewEndedSubscription.unsubscribe()\n    stopWaitPageActivityEnd()\n    stopSubscription.unsubscribe()\n  })\n}\n\ntype ClickActionBase = Pick<ClickAction, 'type' | 'name' | 'target' | 'position'>\n\nfunction computeClickActionBase(event: MouseEventOnElement, actionNameAttribute?: string): ClickActionBase {\n  let target: ClickAction['target']\n  let position: ClickAction['position']\n\n  if (isExperimentalFeatureEnabled('clickmap')) {\n    const rect = event.target.getBoundingClientRect()\n    target = assign(\n      {\n        width: Math.round(rect.width),\n        height: Math.round(rect.height),\n      },\n      getSelectorsFromElement(event.target, actionNameAttribute)\n    )\n    position = {\n      // Use clientX and Y because for SVG element offsetX and Y are relatives to the <svg> element\n      x: Math.round(event.clientX - rect.left),\n      y: Math.round(event.clientY - rect.top),\n    }\n  }\n\n  return {\n    type: ActionType.CLICK,\n    target,\n    position,\n    name: getActionNameFromElement(event.target, actionNameAttribute),\n  }\n}\n\nconst enum ClickStatus {\n  // Initial state, the click is still ongoing.\n  ONGOING,\n  // The click is no more ongoing but still needs to be validated or discarded.\n  STOPPED,\n  // Final state, the click has been stopped and validated or discarded.\n  FINALIZED,\n}\n\nexport type Click = ReturnType<typeof newClick>\n\nfunction newClick(\n  lifeCycle: LifeCycle,\n  history: ClickActionIdHistory,\n  getUserActivity: GetUserActivity,\n  clickActionBase: ClickActionBase,\n  clickEvent: MouseEventOnElement\n) {\n  const id = generateUUID()\n  const startClocks = clocksNow()\n  const historyEntry = history.add(id, startClocks.relative)\n  const eventCountsSubscription = trackEventCounts(lifeCycle)\n  let status = ClickStatus.ONGOING\n  let activityEndTime: undefined | TimeStamp\n  const frustrationTypes: FrustrationType[] = []\n  const stopObservable = new Observable<void>()\n\n  function stop(newActivityEndTime?: TimeStamp) {\n    if (status !== ClickStatus.ONGOING) {\n      return\n    }\n    activityEndTime = newActivityEndTime\n    status = ClickStatus.STOPPED\n    if (activityEndTime) {\n      historyEntry.close(getRelativeTime(activityEndTime))\n    } else {\n      historyEntry.remove()\n    }\n    eventCountsSubscription.stop()\n    stopObservable.notify()\n  }\n\n  return {\n    event: clickEvent,\n    stop,\n    stopObservable,\n\n    get hasError() {\n      return eventCountsSubscription.eventCounts.errorCount > 0\n    },\n    get hasPageActivity() {\n      return activityEndTime !== undefined\n    },\n    getUserActivity,\n    addFrustration: (frustrationType: FrustrationType) => {\n      frustrationTypes.push(frustrationType)\n    },\n    startClocks,\n\n    isStopped: () => status === ClickStatus.STOPPED || status === ClickStatus.FINALIZED,\n\n    clone: () => newClick(lifeCycle, history, getUserActivity, clickActionBase, clickEvent),\n\n    validate: (domEvents?: Event[]) => {\n      stop()\n      if (status !== ClickStatus.STOPPED) {\n        return\n      }\n\n      const { resourceCount, errorCount, longTaskCount } = eventCountsSubscription.eventCounts\n      const clickAction: ClickAction = assign(\n        {\n          type: ActionType.CLICK as const,\n          duration: activityEndTime && elapsed(startClocks.timeStamp, activityEndTime),\n          startClocks,\n          id,\n          frustrationTypes,\n          counts: {\n            resourceCount,\n            errorCount,\n            longTaskCount,\n          },\n          events: domEvents ?? [clickEvent],\n          event: clickEvent,\n        },\n        clickActionBase\n      )\n      lifeCycle.notify(LifeCycleEventType.AUTO_ACTION_COMPLETED, clickAction)\n      status = ClickStatus.FINALIZED\n    },\n\n    discard: () => {\n      stop()\n      status = ClickStatus.FINALIZED\n    },\n  }\n}\n\nexport function finalizeClicks(clicks: Click[], rageClick: Click) {\n  const { isRage } = computeFrustration(clicks, rageClick)\n  if (isRage) {\n    clicks.forEach((click) => click.discard())\n    rageClick.stop(timeStampNow())\n    rageClick.validate(clicks.map((click) => click.event))\n  } else {\n    rageClick.discard()\n    clicks.forEach((click) => click.validate())\n  }\n}\n","import type { ClocksState, Context, Observable } from '@datadog/browser-core'\nimport { noop, assign, combine, toServerDuration, generateUUID } from '@datadog/browser-core'\n\nimport type { CommonContext, RawRumActionEvent } from '../../../rawRumEvent.types'\nimport { ActionType, RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { ForegroundContexts } from '../../contexts/foregroundContexts'\nimport type { RumConfiguration } from '../../configuration'\nimport type { ActionContexts, ClickAction } from './trackClickActions'\nimport { trackClickActions } from './trackClickActions'\n\nexport type { ActionContexts }\n\nexport interface CustomAction {\n  type: ActionType.CUSTOM\n  name: string\n  startClocks: ClocksState\n  context?: Context\n}\n\nexport type AutoAction = ClickAction\n\nexport function startActionCollection(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  foregroundContexts: ForegroundContexts\n) {\n  lifeCycle.subscribe(LifeCycleEventType.AUTO_ACTION_COMPLETED, (action) =>\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processAction(action, foregroundContexts))\n  )\n\n  let actionContexts: ActionContexts = { findActionId: noop as () => undefined }\n  if (configuration.trackInteractions) {\n    actionContexts = trackClickActions(lifeCycle, domMutationObservable, configuration).actionContexts\n  }\n\n  return {\n    addAction: (action: CustomAction, savedCommonContext?: CommonContext) => {\n      lifeCycle.notify(\n        LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n        assign(\n          {\n            savedCommonContext,\n          },\n          processAction(action, foregroundContexts)\n        )\n      )\n    },\n    actionContexts,\n  }\n}\n\nfunction processAction(\n  action: AutoAction | CustomAction,\n  foregroundContexts: ForegroundContexts\n): RawRumEventCollectedData<RawRumActionEvent> {\n  const autoActionProperties = isAutoAction(action)\n    ? {\n        action: {\n          id: action.id,\n          loading_time: toServerDuration(action.duration),\n          frustration: {\n            type: action.frustrationTypes,\n          },\n          error: {\n            count: action.counts.errorCount,\n          },\n          long_task: {\n            count: action.counts.longTaskCount,\n          },\n          resource: {\n            count: action.counts.resourceCount,\n          },\n        },\n        _dd: {\n          action: {\n            target: action.target,\n            position: action.position,\n          },\n        },\n      }\n    : undefined\n  const customerContext = !isAutoAction(action) ? action.context : undefined\n  const actionEvent: RawRumActionEvent = combine(\n    {\n      action: {\n        id: generateUUID(),\n        target: {\n          name: action.name,\n        },\n        type: action.type,\n      },\n      date: action.startClocks.timeStamp,\n      type: RumEventType.ACTION as const,\n    },\n    autoActionProperties\n  )\n  const inForeground = foregroundContexts.isInForegroundAt(action.startClocks.relative)\n  if (inForeground !== undefined) {\n    actionEvent.view = { in_foreground: inForeground }\n  }\n  return {\n    customerContext,\n    rawRumEvent: actionEvent,\n    startTime: action.startClocks.relative,\n    domainContext: isAutoAction(action) ? { event: action.event, events: action.events } : {},\n  }\n}\n\nfunction isAutoAction(action: AutoAction | CustomAction): action is AutoAction {\n  return action.type !== ActionType.CUSTOM\n}\n","import { instrumentMethodAndCallOriginal } from '../../tools/instrumentMethod'\nimport { computeStackTrace } from './computeStackTrace'\nimport type { UnhandledErrorCallback, StackTrace } from './types'\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/\n\n/**\n * Cross-browser collection of unhandled errors\n *\n * Supports:\n * - Firefox: full stack trace with line numbers, plus column number\n * on top frame; column number is not guaranteed\n * - Opera: full stack trace with line and column numbers\n * - Chrome: full stack trace with line and column numbers\n * - Safari: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n * - IE: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n * - IE5.5+ (only 8.0 tested)\n * - Firefox 0.9+ (only 3.5+ tested)\n * - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n * Exceptions Have Stacktrace to be enabled in opera:config)\n * - Safari 3+ (only 4+ tested)\n * - Chrome 1+ (only 5+ tested)\n * - Konqueror 3.5+ (untested)\n *\n * Tries to catch all unhandled errors and report them to the\n * callback.\n *\n * Callbacks receive a StackTrace object as described in the\n * computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\n\nexport function startUnhandledErrorCollection(callback: UnhandledErrorCallback) {\n  const { stop: stopInstrumentingOnError } = instrumentOnError(callback)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(callback)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\n/**\n * Install a global onerror handler\n */\nfunction instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onerror', {\n    before(this: any, message: Event | string, url?: string, lineNo?: number, columnNo?: number, errorObj?: Error) {\n      let stack: StackTrace\n\n      if (errorObj) {\n        stack = computeStackTrace(errorObj)\n        callback(stack, errorObj)\n      } else {\n        const location = {\n          url,\n          column: columnNo,\n          line: lineNo,\n        }\n\n        let name\n        let msg = message\n        if ({}.toString.call(message) === '[object String]') {\n          const groups = ERROR_TYPES_RE.exec(msg as string)\n          if (groups) {\n            name = groups[1]\n            msg = groups[2]\n          }\n        }\n\n        stack = {\n          name,\n          message: typeof msg === 'string' ? msg : undefined,\n          stack: [location],\n        }\n\n        callback(stack, message)\n      }\n    },\n  })\n}\n\n/**\n * Install a global onunhandledrejection handler\n */\nfunction instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onunhandledrejection', {\n    before(e: PromiseRejectionEvent) {\n      const reason = e.reason || 'Empty reason'\n      const stack = computeStackTrace(reason)\n      callback(stack, reason)\n    },\n  })\n}\n","import { computeStackTrace } from '../tracekit'\nimport { createHandlingStack, formatErrorMessage, toStackTraceString } from '../../tools/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { find, jsonStringify } from '../../tools/utils'\nimport { ConsoleApiName } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\n\nexport interface ConsoleLog {\n  message: string\n  api: ConsoleApiName\n  stack?: string\n  handlingStack?: string\n}\n\nconst consoleObservablesByApi: { [k in ConsoleApiName]?: Observable<ConsoleLog> } = {}\n\nexport function initConsoleObservable(apis: ConsoleApiName[]) {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api)\n    }\n    return consoleObservablesByApi[api]!\n  })\n\n  return mergeObservables<ConsoleLog>(...consoleObservables)\n}\n\n/* eslint-disable no-console */\nfunction createConsoleObservable(api: ConsoleApiName) {\n  const observable = new Observable<ConsoleLog>(() => {\n    const originalConsoleApi = console[api]\n\n    console[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      console[api] = originalConsoleApi\n    }\n  })\n\n  return observable\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  // Todo: remove console error prefix in the next major version\n  let message = params.map((param) => formatConsoleParameters(param)).join(' ')\n  let stack\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = find(params, (param: unknown): param is Error => param instanceof Error)\n    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n    message = `console error: ${message}`\n  }\n\n  return {\n    api,\n    message,\n    stack,\n    handlingStack,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return param\n  }\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(param, 2)\n}\n","import { toStackTraceString } from '../../tools/error'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { DOM_EVENT, includes, addEventListener, safeTruncate } from '../../tools/utils'\nimport type { Report, BrowserWindow, ReportType } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = typeof RawReportType[keyof typeof RawReportType]\n\nexport interface RawReport {\n  type: RawReportType\n  subtype: string\n  message: string\n  stack?: string\n}\n\nexport function initReportObservable(apis: RawReportType[]) {\n  const observables: Array<Observable<RawReport>> = []\n\n  if (includes(apis, RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable())\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables<RawReport>(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  const observable = new Observable<RawReport>(() => {\n    if (!(window as BrowserWindow).ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Report[]) =>\n      reports.forEach((report) => {\n        observable.notify(buildRawReportFromReport(report))\n      })\n    )\n\n    const observer = new (window as BrowserWindow).ReportingObserver!(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n\n  return observable\n}\n\nfunction createCspViolationReportObservable() {\n  const observable = new Observable<RawReport>(() => {\n    const handleCspViolation = monitor((event: SecurityPolicyViolationEvent) => {\n      observable.notify(buildRawReportFromCspViolation(event))\n    })\n\n    const { stop } = addEventListener(document, DOM_EVENT.SECURITY_POLICY_VIOLATION, handleCspViolation)\n\n    return stop\n  })\n  return observable\n}\n\nfunction buildRawReportFromReport({ type, body }: Report): RawReport {\n  return {\n    type,\n    subtype: body.id,\n    message: `${type}: ${body.message}`,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  }\n}\n\nfunction buildRawReportFromCspViolation(event: SecurityPolicyViolationEvent): RawReport {\n  const type = RawReportType.cspViolation\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return {\n    type: RawReportType.cspViolation,\n    subtype: event.effectiveDirective,\n    message: `${type}: ${message}`,\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | undefined,\n  lineNumber: number | undefined,\n  columnNumber: number | undefined\n): string | undefined {\n  return (\n    sourceFile &&\n    toStackTraceString({\n      name,\n      message,\n      stack: [\n        {\n          func: '?',\n          url: sourceFile,\n          line: lineNumber,\n          column: columnNumber,\n        },\n      ],\n    })\n  )\n}\n","import type { EventEmitter, RelativeTime } from '@datadog/browser-core'\nimport { addEventListeners, DOM_EVENT } from '@datadog/browser-core'\n\nlet trackFirstHiddenSingleton: { timeStamp: RelativeTime } | undefined\nlet stopListeners: (() => void) | undefined\n\nexport function trackFirstHidden(emitter: EventEmitter = window) {\n  if (!trackFirstHiddenSingleton) {\n    if (document.visibilityState === 'hidden') {\n      trackFirstHiddenSingleton = {\n        timeStamp: 0 as RelativeTime,\n      }\n    } else {\n      trackFirstHiddenSingleton = {\n        timeStamp: Infinity as RelativeTime,\n      }\n      ;({ stop: stopListeners } = addEventListeners(\n        emitter,\n        [DOM_EVENT.PAGE_HIDE, DOM_EVENT.VISIBILITY_CHANGE],\n        (event) => {\n          if (event.type === 'pagehide' || document.visibilityState === 'hidden') {\n            trackFirstHiddenSingleton!.timeStamp = event.timeStamp as RelativeTime\n            stopListeners!()\n          }\n        },\n        { capture: true }\n      ))\n    }\n  }\n\n  return trackFirstHiddenSingleton\n}\n\nexport function resetFirstHidden() {\n  if (stopListeners) {\n    stopListeners()\n  }\n  trackFirstHiddenSingleton = undefined\n}\n","import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport {\n  assign,\n  ErrorSource,\n  generateUUID,\n  computeRawError,\n  ErrorHandling,\n  computeStackTrace,\n  Observable,\n  trackRuntimeError,\n} from '@datadog/browser-core'\nimport type { CommonContext, RawRumErrorEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { ForegroundContexts } from '../../contexts/foregroundContexts'\nimport { trackConsoleError } from './trackConsoleError'\nimport { trackReportError } from './trackReportError'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startErrorCollection(lifeCycle: LifeCycle, foregroundContexts: ForegroundContexts) {\n  const errorObservable = new Observable<RawError>()\n\n  trackConsoleError(errorObservable)\n  trackRuntimeError(errorObservable)\n  trackReportError(errorObservable)\n\n  errorObservable.subscribe((error) => lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error }))\n\n  return doStartErrorCollection(lifeCycle, foregroundContexts)\n}\n\nexport function doStartErrorCollection(lifeCycle: LifeCycle, foregroundContexts: ForegroundContexts) {\n  lifeCycle.subscribe(LifeCycleEventType.RAW_ERROR_COLLECTED, ({ error, customerContext, savedCommonContext }) => {\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      assign(\n        {\n          customerContext,\n          savedCommonContext,\n        },\n        processError(error, foregroundContexts)\n      )\n    )\n  })\n\n  return {\n    addError: (\n      { error, handlingStack, startClocks, context: customerContext }: ProvidedError,\n      savedCommonContext?: CommonContext\n    ) => {\n      const stackTrace = error instanceof Error ? computeStackTrace(error) : undefined\n      const rawError = computeRawError({\n        stackTrace,\n        originalError: error,\n        handlingStack,\n        startClocks,\n        nonErrorPrefix: 'Provided',\n        source: ErrorSource.CUSTOM,\n        handling: ErrorHandling.HANDLED,\n      })\n\n      lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, {\n        customerContext,\n        savedCommonContext,\n        error: rawError,\n      })\n    },\n  }\n}\n\nfunction processError(\n  error: RawError,\n  foregroundContexts: ForegroundContexts\n): RawRumEventCollectedData<RawRumErrorEvent> {\n  const rawRumEvent: RawRumErrorEvent = {\n    date: error.startClocks.timeStamp,\n    error: {\n      id: generateUUID(),\n      message: error.message,\n      source: error.source,\n      stack: error.stack,\n      handling_stack: error.handlingStack,\n      type: error.type,\n      handling: error.handling,\n      causes: error.causes,\n      source_type: 'browser',\n    },\n    type: RumEventType.ERROR as const,\n  }\n  const inForeground = foregroundContexts.isInForegroundAt(error.startClocks.relative)\n  if (inForeground !== undefined) {\n    rawRumEvent.view = { in_foreground: inForeground }\n  }\n\n  return {\n    rawRumEvent,\n    startTime: error.startClocks.relative,\n    domainContext: {\n      error: error.originalError,\n    },\n  }\n}\n","import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, initConsoleObservable, ErrorSource, ConsoleApiName } from '@datadog/browser-core'\n\nexport function trackConsoleError(errorObservable: Observable<RawError>) {\n  const subscription = initConsoleObservable([ConsoleApiName.error]).subscribe((consoleError) =>\n    errorObservable.notify({\n      startClocks: clocksNow(),\n      message: consoleError.message,\n      stack: consoleError.stack,\n      source: ErrorSource.CONSOLE,\n      handling: ErrorHandling.HANDLED,\n      handlingStack: consoleError.handlingStack,\n    })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n","import type { RawError } from '../../tools/error'\nimport { ErrorSource, computeRawError, ErrorHandling } from '../../tools/error'\nimport type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/timeUtils'\nimport { startUnhandledErrorCollection } from '../tracekit'\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  return startUnhandledErrorCollection((stackTrace, originalError) => {\n    errorObservable.notify(\n      computeRawError({\n        stackTrace,\n        originalError,\n        startClocks: clocksNow(),\n        nonErrorPrefix: 'Uncaught',\n        source: ErrorSource.SOURCE,\n        handling: ErrorHandling.UNHANDLED,\n      })\n    )\n  })\n}\n","import type { Observable, RawError } from '@datadog/browser-core'\nimport { clocksNow, ErrorHandling, ErrorSource, initReportObservable, RawReportType } from '@datadog/browser-core'\n\nexport function trackReportError(errorObservable: Observable<RawError>) {\n  const subscription = initReportObservable([RawReportType.cspViolation, RawReportType.intervention]).subscribe(\n    (reportError) =>\n      errorObservable.notify({\n        startClocks: clocksNow(),\n        message: reportError.message,\n        stack: reportError.stack,\n        type: reportError.subtype,\n        source: ErrorSource.REPORT,\n        handling: ErrorHandling.UNHANDLED,\n      })\n  )\n\n  return {\n    stop: () => {\n      subscription.unsubscribe()\n    },\n  }\n}\n","import type { Duration, RelativeTime } from '@datadog/browser-core'\nimport { addDuration } from '@datadog/browser-core'\nimport type { RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\nimport type { RequestCompleteEvent } from '../../requestCollection'\nimport { toValidEntry } from './resourceUtils'\n\ninterface Timing {\n  startTime: RelativeTime\n  duration: Duration\n}\n\n/**\n * Look for corresponding timing in resource timing buffer\n *\n * Observations:\n * - Timing (start, end) are nested inside the request (start, end)\n * - Some timing can be not exactly nested, being off by < 1 ms\n * - Browsers generate a timing entry for OPTIONS request\n *\n * Strategy:\n * - from valid nested entries (with 1 ms error margin)\n * - if a single timing match, return the timing\n * - if two following timings match (OPTIONS request), return the timing for the actual request\n * - otherwise we can't decide, return undefined\n */\nexport function matchRequestTiming(request: RequestCompleteEvent) {\n  if (!performance || !('getEntriesByName' in performance)) {\n    return\n  }\n  const sameNameEntries = performance.getEntriesByName(request.url, 'resource')\n\n  if (!sameNameEntries.length || !('toJSON' in sameNameEntries[0])) {\n    return\n  }\n\n  const candidates = sameNameEntries\n    .map((entry) => entry.toJSON() as RumPerformanceResourceTiming)\n    .filter(toValidEntry)\n    .filter((entry) =>\n      isBetween(\n        entry,\n        request.startClocks.relative,\n        endTime({ startTime: request.startClocks.relative, duration: request.duration })\n      )\n    )\n\n  if (candidates.length === 1) {\n    return candidates[0]\n  }\n\n  if (candidates.length === 2 && firstCanBeOptionRequest(candidates)) {\n    return candidates[1]\n  }\n\n  return\n}\n\nfunction firstCanBeOptionRequest(correspondingEntries: RumPerformanceResourceTiming[]) {\n  return endTime(correspondingEntries[0]) <= correspondingEntries[1].startTime\n}\n\nfunction endTime(timing: Timing) {\n  return addDuration(timing.startTime, timing.duration)\n}\n\nfunction isBetween(timing: Timing, start: RelativeTime, end: RelativeTime) {\n  const errorMargin = 1 as Duration\n  return timing.startTime >= start - errorMargin && endTime(timing) <= addDuration(end, errorMargin)\n}\n","import {\n  combine,\n  generateUUID,\n  RequestType,\n  ResourceType,\n  toServerDuration,\n  relativeToClocks,\n  assign,\n  isNumber,\n} from '@datadog/browser-core'\nimport type { ClocksState } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../../configuration'\nimport type { RumPerformanceEntry, RumPerformanceResourceTiming } from '../../../browser/performanceCollection'\nimport type {\n  PerformanceEntryRepresentation,\n  RumXhrResourceEventDomainContext,\n  RumFetchResourceEventDomainContext,\n} from '../../../domainContext.types'\nimport type { RawRumResourceEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RequestCompleteEvent } from '../../requestCollection'\nimport type { RumSessionManager } from '../../rumSessionManager'\nimport { matchRequestTiming } from './matchRequestTiming'\nimport {\n  computePerformanceResourceDetails,\n  computePerformanceResourceDuration,\n  computeResourceKind,\n  computeSize,\n  isRequestKind,\n} from './resourceUtils'\n\nexport function startResourceCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n) {\n  lifeCycle.subscribe(LifeCycleEventType.REQUEST_COMPLETED, (request: RequestCompleteEvent) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, processRequest(request, configuration, sessionManager))\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'resource' && !isRequestKind(entry)) {\n        lifeCycle.notify(\n          LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n          processResourceEntry(entry, configuration, sessionManager)\n        )\n      }\n    }\n  })\n}\n\nfunction processRequest(\n  request: RequestCompleteEvent,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n): RawRumEventCollectedData<RawRumResourceEvent> {\n  const type = request.type === RequestType.XHR ? ResourceType.XHR : ResourceType.FETCH\n\n  const matchingTiming = matchRequestTiming(request)\n  const startClocks = matchingTiming ? relativeToClocks(matchingTiming.startTime) : request.startClocks\n  const correspondingTimingOverrides = matchingTiming ? computePerformanceEntryMetrics(matchingTiming) : undefined\n\n  const tracingInfo = computeRequestTracingInfo(request, configuration)\n  const indexingInfo = computeIndexingInfo(sessionManager, startClocks)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        duration: toServerDuration(request.duration),\n        method: request.method,\n        status_code: request.status,\n        url: request.url,\n      },\n      type: RumEventType.RESOURCE as const,\n    },\n    tracingInfo,\n    correspondingTimingOverrides,\n    indexingInfo\n  )\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: matchingTiming && toPerformanceEntryRepresentation(matchingTiming),\n      xhr: request.xhr,\n      response: request.response,\n      requestInput: request.input,\n      requestInit: request.init,\n      error: request.error,\n    } as RumFetchResourceEventDomainContext | RumXhrResourceEventDomainContext,\n  }\n}\n\nfunction processResourceEntry(\n  entry: RumPerformanceResourceTiming,\n  configuration: RumConfiguration,\n  sessionManager: RumSessionManager\n): RawRumEventCollectedData<RawRumResourceEvent> {\n  const type = computeResourceKind(entry)\n  const entryMetrics = computePerformanceEntryMetrics(entry)\n  const startClocks = relativeToClocks(entry.startTime)\n\n  const tracingInfo = computeEntryTracingInfo(entry, configuration)\n  const indexingInfo = computeIndexingInfo(sessionManager, startClocks)\n\n  const resourceEvent = combine(\n    {\n      date: startClocks.timeStamp,\n      resource: {\n        id: generateUUID(),\n        type,\n        url: entry.name,\n      },\n      type: RumEventType.RESOURCE as const,\n    },\n    tracingInfo,\n    entryMetrics,\n    indexingInfo\n  )\n  return {\n    startTime: startClocks.relative,\n    rawRumEvent: resourceEvent,\n    domainContext: {\n      performanceEntry: toPerformanceEntryRepresentation(entry),\n    },\n  }\n}\n\nfunction computePerformanceEntryMetrics(timing: RumPerformanceResourceTiming) {\n  return {\n    resource: assign(\n      {\n        duration: computePerformanceResourceDuration(timing),\n        size: computeSize(timing),\n      },\n      computePerformanceResourceDetails(timing)\n    ),\n  }\n}\n\nfunction computeRequestTracingInfo(request: RequestCompleteEvent, configuration: RumConfiguration) {\n  const hasBeenTraced = request.traceSampled && request.traceId && request.spanId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      span_id: request.spanId!.toDecimalString(),\n      trace_id: request.traceId!.toDecimalString(),\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\nfunction computeEntryTracingInfo(entry: RumPerformanceResourceTiming, configuration: RumConfiguration) {\n  const hasBeenTraced = entry.traceId\n  if (!hasBeenTraced) {\n    return undefined\n  }\n  return {\n    _dd: {\n      trace_id: entry.traceId,\n      rule_psr: getRulePsr(configuration),\n    },\n  }\n}\n\n// TODO next major: use directly PerformanceEntry type in domain context\nfunction toPerformanceEntryRepresentation(entry: RumPerformanceEntry): PerformanceEntryRepresentation {\n  return entry as PerformanceEntryRepresentation\n}\n\n/**\n * @returns number between 0 and 1 which represents tracing sample rate\n */\nfunction getRulePsr(configuration: RumConfiguration) {\n  return isNumber(configuration.tracingSampleRate) ? configuration.tracingSampleRate / 100 : undefined\n}\n\nfunction computeIndexingInfo(sessionManager: RumSessionManager, resourceStart: ClocksState) {\n  const session = sessionManager.findTrackedSession(resourceStart.relative)\n  return {\n    _dd: {\n      discarded: !session || !session.resourceAllowed,\n    },\n  }\n}\n","import type { Duration, EventEmitter, RelativeTime } from '@datadog/browser-core'\nimport {\n  assign,\n  addEventListeners,\n  DOM_EVENT,\n  elapsed,\n  ONE_MINUTE,\n  find,\n  findLast,\n  relativeNow,\n} from '@datadog/browser-core'\n\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type {\n  RumFirstInputTiming,\n  RumLargestContentfulPaintTiming,\n  RumPerformancePaintTiming,\n} from '../../../browser/performanceCollection'\nimport { trackFirstHidden } from './trackFirstHidden'\n\n// Discard LCP and FCP timings above a certain delay to avoid incorrect data\n// It happens in some cases like sleep mode or some browser implementations\nexport const TIMING_MAXIMUM_DELAY = 10 * ONE_MINUTE\n\nexport interface Timings {\n  firstContentfulPaint?: Duration\n  firstByte?: Duration\n  domInteractive?: Duration\n  domContentLoaded?: Duration\n  domComplete?: Duration\n  loadEvent?: Duration\n  largestContentfulPaint?: Duration\n  firstInputDelay?: Duration\n  firstInputTime?: Duration\n}\n\nexport function trackInitialViewTimings(lifeCycle: LifeCycle, callback: (timings: Timings) => void) {\n  const timings: Timings = {}\n  function setTimings(newTimings: Partial<Timings>) {\n    assign(timings, newTimings)\n    callback(timings)\n  }\n\n  const { stop: stopNavigationTracking } = trackNavigationTimings(lifeCycle, setTimings)\n  const { stop: stopFCPTracking } = trackFirstContentfulPaintTiming(lifeCycle, (firstContentfulPaint) =>\n    setTimings({ firstContentfulPaint })\n  )\n  const { stop: stopLCPTracking } = trackLargestContentfulPaintTiming(lifeCycle, window, (largestContentfulPaint) => {\n    setTimings({\n      largestContentfulPaint,\n    })\n  })\n  const { stop: stopFIDTracking } = trackFirstInputTimings(lifeCycle, ({ firstInputDelay, firstInputTime }) => {\n    setTimings({\n      firstInputDelay,\n      firstInputTime,\n    })\n  })\n\n  return {\n    stop: () => {\n      stopNavigationTracking()\n      stopFCPTracking()\n      stopLCPTracking()\n      stopFIDTracking()\n    },\n  }\n}\n\nexport function trackNavigationTimings(lifeCycle: LifeCycle, callback: (timings: Partial<Timings>) => void) {\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'navigation') {\n        callback({\n          domComplete: entry.domComplete,\n          domContentLoaded: entry.domContentLoadedEventEnd,\n          domInteractive: entry.domInteractive,\n          loadEvent: entry.loadEventEnd,\n          // In some cases the value reported is negative or is larger\n          // than the current page time. Ignore these cases:\n          // https://github.com/GoogleChrome/web-vitals/issues/137\n          // https://github.com/GoogleChrome/web-vitals/issues/162\n          firstByte: entry.responseStart >= 0 && entry.responseStart <= relativeNow() ? entry.responseStart : undefined,\n        })\n      }\n    }\n  })\n\n  return { stop }\n}\n\nexport function trackFirstContentfulPaintTiming(lifeCycle: LifeCycle, callback: (fcpTiming: RelativeTime) => void) {\n  const firstHidden = trackFirstHidden()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const fcpEntry = find(\n      entries,\n      (entry): entry is RumPerformancePaintTiming =>\n        entry.entryType === 'paint' &&\n        entry.name === 'first-contentful-paint' &&\n        entry.startTime < firstHidden.timeStamp &&\n        entry.startTime < TIMING_MAXIMUM_DELAY\n    )\n    if (fcpEntry) {\n      callback(fcpEntry.startTime)\n    }\n  })\n  return { stop }\n}\n\n/**\n * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield\n * multiple values, only the most recent one should be used.\n * Documentation: https://web.dev/lcp/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getLCP.ts\n */\nexport function trackLargestContentfulPaintTiming(\n  lifeCycle: LifeCycle,\n  emitter: EventEmitter,\n  callback: (lcpTiming: RelativeTime) => void\n) {\n  const firstHidden = trackFirstHidden()\n\n  // Ignore entries that come after the first user interaction.  According to the documentation, the\n  // browser should not send largest-contentful-paint entries after a user interact with the page,\n  // but the web-vitals reference implementation uses this as a safeguard.\n  let firstInteractionTimestamp = Infinity\n  const { stop: stopEventListener } = addEventListeners(\n    emitter,\n    [DOM_EVENT.POINTER_DOWN, DOM_EVENT.KEY_DOWN],\n    (event) => {\n      firstInteractionTimestamp = event.timeStamp\n    },\n    { capture: true, once: true }\n  )\n\n  const { unsubscribe: unsubscribeLifeCycle } = lifeCycle.subscribe(\n    LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED,\n    (entries) => {\n      const lcpEntry = findLast(\n        entries,\n        (entry): entry is RumLargestContentfulPaintTiming =>\n          entry.entryType === 'largest-contentful-paint' &&\n          entry.startTime < firstInteractionTimestamp &&\n          entry.startTime < firstHidden.timeStamp &&\n          entry.startTime < TIMING_MAXIMUM_DELAY\n      )\n      if (lcpEntry) {\n        callback(lcpEntry.startTime)\n      }\n    }\n  )\n\n  return {\n    stop: () => {\n      stopEventListener()\n      unsubscribeLifeCycle()\n    },\n  }\n}\n\n/**\n * Track the first input occurring during the initial View to return:\n * - First Input Delay\n * - First Input Time\n * Callback is called at most one time.\n * Documentation: https://web.dev/fid/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getFID.ts\n */\nexport function trackFirstInputTimings(\n  lifeCycle: LifeCycle,\n  callback: ({ firstInputDelay, firstInputTime }: { firstInputDelay: Duration; firstInputTime: Duration }) => void\n) {\n  const firstHidden = trackFirstHidden()\n\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    const firstInputEntry = find(\n      entries,\n      (entry): entry is RumFirstInputTiming =>\n        entry.entryType === 'first-input' && entry.startTime < firstHidden.timeStamp\n    )\n    if (firstInputEntry) {\n      const firstInputDelay = elapsed(firstInputEntry.startTime, firstInputEntry.processingStart)\n      callback({\n        // Ensure firstInputDelay to be positive, see\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1185815\n        firstInputDelay: firstInputDelay >= 0 ? firstInputDelay : (0 as Duration),\n        firstInputTime: firstInputEntry.startTime as Duration,\n      })\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n","import type { Duration, RelativeTime, Observable, ClocksState } from '@datadog/browser-core'\nimport { noop, round, ONE_SECOND, elapsed } from '@datadog/browser-core'\nimport type { RumLayoutShiftTiming } from '../../../browser/performanceCollection'\nimport { supportPerformanceTimingEvent } from '../../../browser/performanceCollection'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\nimport type { RumConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { EventCounts } from '../../trackEventCounts'\nimport { trackEventCounts } from '../../trackEventCounts'\nimport { waitPageActivityEnd } from '../../waitPageActivityEnd'\n\nexport interface ViewMetrics {\n  eventCounts: EventCounts\n  loadingTime?: Duration\n  cumulativeLayoutShift?: number\n}\n\nexport function trackViewMetrics(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  scheduleViewUpdate: () => void,\n  loadingType: ViewLoadingType,\n  viewStart: ClocksState\n) {\n  const viewMetrics: ViewMetrics = {\n    eventCounts: {\n      errorCount: 0,\n      longTaskCount: 0,\n      resourceCount: 0,\n      actionCount: 0,\n      frustrationCount: 0,\n    },\n  }\n  const { stop: stopEventCountsTracking } = trackEventCounts(lifeCycle, (newEventCounts) => {\n    viewMetrics.eventCounts = newEventCounts\n    scheduleViewUpdate()\n  })\n\n  const { stop: stopLoadingTimeTracking, setLoadEvent } = trackLoadingTime(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    loadingType,\n    viewStart,\n    (newLoadingTime) => {\n      viewMetrics.loadingTime = newLoadingTime\n      scheduleViewUpdate()\n    }\n  )\n\n  let stopCLSTracking: () => void\n  if (isLayoutShiftSupported()) {\n    viewMetrics.cumulativeLayoutShift = 0\n    ;({ stop: stopCLSTracking } = trackCumulativeLayoutShift(lifeCycle, (cumulativeLayoutShift) => {\n      viewMetrics.cumulativeLayoutShift = cumulativeLayoutShift\n      scheduleViewUpdate()\n    }))\n  } else {\n    stopCLSTracking = noop\n  }\n  return {\n    stop: () => {\n      stopEventCountsTracking()\n      stopLoadingTimeTracking()\n      stopCLSTracking()\n    },\n    setLoadEvent,\n    viewMetrics,\n  }\n}\n\nfunction trackLoadingTime(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  loadType: ViewLoadingType,\n  viewStart: ClocksState,\n  callback: (loadingTime: Duration) => void\n) {\n  let isWaitingForLoadEvent = loadType === ViewLoadingType.INITIAL_LOAD\n  let isWaitingForActivityLoadingTime = true\n  const loadingTimeCandidates: Duration[] = []\n\n  function invokeCallbackIfAllCandidatesAreReceived() {\n    if (!isWaitingForActivityLoadingTime && !isWaitingForLoadEvent && loadingTimeCandidates.length > 0) {\n      callback(Math.max(...loadingTimeCandidates) as Duration)\n    }\n  }\n\n  const { stop } = waitPageActivityEnd(lifeCycle, domMutationObservable, configuration, (event) => {\n    if (isWaitingForActivityLoadingTime) {\n      isWaitingForActivityLoadingTime = false\n      if (event.hadActivity) {\n        loadingTimeCandidates.push(elapsed(viewStart.timeStamp, event.end))\n      }\n      invokeCallbackIfAllCandidatesAreReceived()\n    }\n  })\n\n  return {\n    stop,\n    setLoadEvent: (loadEvent: Duration) => {\n      if (isWaitingForLoadEvent) {\n        isWaitingForLoadEvent = false\n        loadingTimeCandidates.push(loadEvent)\n        invokeCallbackIfAllCandidatesAreReceived()\n      }\n    },\n  }\n}\n\n/**\n * Track the cumulative layout shifts (CLS).\n * Layout shifts are grouped into session windows.\n * The minimum gap between session windows is 1 second.\n * The maximum duration of a session window is 5 second.\n * The session window layout shift value is the sum of layout shifts inside it.\n * The CLS value is the max of session windows values.\n *\n * This yields a new value whenever the CLS value is updated (a higher session window value is computed).\n *\n * See isLayoutShiftSupported to check for browser support.\n *\n * Documentation:\n * https://web.dev/cls/\n * https://web.dev/evolving-cls/\n * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/getCLS.ts\n */\nfunction trackCumulativeLayoutShift(lifeCycle: LifeCycle, callback: (layoutShift: number) => void) {\n  let maxClsValue = 0\n  const window = slidingSessionWindow()\n  const { unsubscribe: stop } = lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType === 'layout-shift' && !entry.hadRecentInput) {\n        window.update(entry)\n        if (window.value() > maxClsValue) {\n          maxClsValue = window.value()\n          callback(round(maxClsValue, 4))\n        }\n      }\n    }\n  })\n\n  return {\n    stop,\n  }\n}\n\nfunction slidingSessionWindow() {\n  let value = 0\n  let startTime: RelativeTime\n  let endTime: RelativeTime\n  return {\n    update: (entry: RumLayoutShiftTiming) => {\n      const shouldCreateNewWindow =\n        startTime === undefined ||\n        entry.startTime - endTime >= ONE_SECOND ||\n        entry.startTime - startTime >= 5 * ONE_SECOND\n      if (shouldCreateNewWindow) {\n        startTime = endTime = entry.startTime\n        value = entry.value\n      } else {\n        value += entry.value\n        endTime = entry.startTime\n      }\n    },\n    value: () => value,\n  }\n}\n\n/**\n * Check whether `layout-shift` is supported by the browser.\n */\nfunction isLayoutShiftSupported() {\n  return supportPerformanceTimingEvent('layout-shift')\n}\n","import type { Duration, ClocksState, TimeStamp, Observable, Subscription, RelativeTime } from '@datadog/browser-core'\nimport {\n  shallowClone,\n  assign,\n  elapsed,\n  generateUUID,\n  monitor,\n  ONE_MINUTE,\n  throttle,\n  clocksNow,\n  clocksOrigin,\n  timeStampNow,\n  display,\n  looksLikeRelativeTime,\n} from '@datadog/browser-core'\n\nimport type { ViewCustomTimings } from '../../../rawRumEvent.types'\nimport { ViewLoadingType } from '../../../rawRumEvent.types'\n\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { EventCounts } from '../../trackEventCounts'\nimport type { LocationChange } from '../../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { Timings } from './trackInitialViewTimings'\nimport { trackInitialViewTimings } from './trackInitialViewTimings'\nimport { trackViewMetrics } from './trackViewMetrics'\n\nexport interface ViewEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  location: Readonly<Location>\n  timings: Timings\n  customTimings: ViewCustomTimings\n  eventCounts: EventCounts\n  documentVersion: number\n  startClocks: ClocksState\n  duration: Duration\n  isActive: boolean\n  loadingTime?: Duration\n  loadingType: ViewLoadingType\n  cumulativeLayoutShift?: number\n}\n\nexport interface ViewCreatedEvent {\n  id: string\n  name?: string\n  service?: string\n  version?: string\n  startClocks: ClocksState\n}\n\nexport interface ViewEndedEvent {\n  endClocks: ClocksState\n}\n\nexport const THROTTLE_VIEW_UPDATE_PERIOD = 3000\nexport const SESSION_KEEP_ALIVE_INTERVAL = 5 * ONE_MINUTE\n\nexport interface ViewOptions {\n  name?: string\n  service?: string\n  version?: string\n}\n\nexport function trackViews(\n  location: Location,\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  locationChangeObservable: Observable<LocationChange>,\n  areViewsTrackedAutomatically: boolean,\n  initialViewOptions?: ViewOptions\n) {\n  const { stop: stopInitialViewTracking, initialView } = trackInitialView(initialViewOptions)\n  let currentView = initialView\n\n  const { stop: stopViewLifeCycle } = startViewLifeCycle()\n\n  let locationChangeSubscription: Subscription\n  if (areViewsTrackedAutomatically) {\n    locationChangeSubscription = renewViewOnLocationChange(locationChangeObservable)\n  }\n\n  function trackInitialView(options?: ViewOptions) {\n    const initialView = newView(\n      lifeCycle,\n      domMutationObservable,\n      configuration,\n      location,\n      ViewLoadingType.INITIAL_LOAD,\n      clocksOrigin(),\n      options\n    )\n    const { stop } = trackInitialViewTimings(lifeCycle, (timings) => {\n      initialView.updateTimings(timings)\n      initialView.scheduleUpdate()\n    })\n    return { initialView, stop }\n  }\n\n  function trackViewChange(startClocks?: ClocksState, viewOptions?: ViewOptions) {\n    return newView(\n      lifeCycle,\n      domMutationObservable,\n      configuration,\n      location,\n      ViewLoadingType.ROUTE_CHANGE,\n      startClocks,\n      viewOptions\n    )\n  }\n\n  function startViewLifeCycle() {\n    lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n      // do not trigger view update to avoid wrong data\n      currentView.end()\n      // Renew view on session renewal\n      currentView = trackViewChange(undefined, {\n        name: currentView.name,\n        service: currentView.service,\n        version: currentView.version,\n      })\n    })\n\n    // End the current view on page unload\n    lifeCycle.subscribe(LifeCycleEventType.BEFORE_UNLOAD, () => {\n      currentView.end()\n      currentView.triggerUpdate()\n    })\n\n    // Session keep alive\n    const keepAliveInterval = window.setInterval(\n      monitor(() => {\n        currentView.triggerUpdate()\n      }),\n      SESSION_KEEP_ALIVE_INTERVAL\n    )\n\n    return {\n      stop: () => {\n        clearInterval(keepAliveInterval)\n      },\n    }\n  }\n\n  function renewViewOnLocationChange(locationChangeObservable: Observable<LocationChange>) {\n    return locationChangeObservable.subscribe(({ oldLocation, newLocation }) => {\n      if (areDifferentLocation(oldLocation, newLocation)) {\n        currentView.end()\n        currentView.triggerUpdate()\n        currentView = trackViewChange()\n        return\n      }\n    })\n  }\n\n  return {\n    addTiming: (name: string, time: RelativeTime | TimeStamp = timeStampNow()) => {\n      currentView.addTiming(name, time)\n      currentView.scheduleUpdate()\n    },\n    startView: (options?: ViewOptions, startClocks?: ClocksState) => {\n      currentView.end(startClocks)\n      currentView.triggerUpdate()\n      currentView = trackViewChange(startClocks, options)\n    },\n    stop: () => {\n      locationChangeSubscription?.unsubscribe()\n      stopInitialViewTracking()\n      stopViewLifeCycle()\n      currentView.end()\n    },\n  }\n}\n\nfunction newView(\n  lifeCycle: LifeCycle,\n  domMutationObservable: Observable<void>,\n  configuration: RumConfiguration,\n  initialLocation: Location,\n  loadingType: ViewLoadingType,\n  startClocks: ClocksState = clocksNow(),\n  viewOptions?: ViewOptions\n) {\n  // Setup initial values\n  const id = generateUUID()\n  let timings: Timings = {}\n  const customTimings: ViewCustomTimings = {}\n  let documentVersion = 0\n  let endClocks: ClocksState | undefined\n  const location = shallowClone(initialLocation)\n\n  let name: string | undefined\n  let service: string | undefined\n  let version: string | undefined\n  if (viewOptions) {\n    name = viewOptions.name\n    service = viewOptions.service\n    version = viewOptions.version\n  }\n\n  lifeCycle.notify(LifeCycleEventType.VIEW_CREATED, { id, name, startClocks, service, version })\n\n  // Update the view every time the measures are changing\n  const { throttled: scheduleViewUpdate, cancel: cancelScheduleViewUpdate } = throttle(\n    monitor(triggerViewUpdate),\n    THROTTLE_VIEW_UPDATE_PERIOD,\n    {\n      leading: false,\n    }\n  )\n\n  const {\n    setLoadEvent,\n    stop: stopViewMetricsTracking,\n    viewMetrics,\n  } = trackViewMetrics(lifeCycle, domMutationObservable, configuration, scheduleViewUpdate, loadingType, startClocks)\n\n  // Initial view update\n  triggerViewUpdate()\n\n  function triggerViewUpdate() {\n    documentVersion += 1\n    const currentEnd = endClocks === undefined ? timeStampNow() : endClocks.timeStamp\n    lifeCycle.notify(\n      LifeCycleEventType.VIEW_UPDATED,\n      assign(\n        {\n          customTimings,\n          documentVersion,\n          id,\n          name,\n          service,\n          version,\n          loadingType,\n          location,\n          startClocks,\n          timings,\n          duration: elapsed(startClocks.timeStamp, currentEnd),\n          isActive: endClocks === undefined,\n        },\n        viewMetrics\n      )\n    )\n  }\n\n  return {\n    name,\n    service,\n    version,\n    scheduleUpdate: scheduleViewUpdate,\n    end(clocks = clocksNow()) {\n      endClocks = clocks\n      lifeCycle.notify(LifeCycleEventType.VIEW_ENDED, { endClocks })\n      stopViewMetricsTracking()\n    },\n    triggerUpdate() {\n      // cancel any pending view updates execution\n      cancelScheduleViewUpdate()\n      triggerViewUpdate()\n    },\n    updateTimings(newTimings: Timings) {\n      timings = newTimings\n      if (newTimings.loadEvent !== undefined) {\n        setLoadEvent(newTimings.loadEvent)\n      }\n    },\n    addTiming(name: string, time: RelativeTime | TimeStamp) {\n      const relativeTime = looksLikeRelativeTime(time) ? time : elapsed(startClocks.timeStamp, time)\n      customTimings[sanitizeTiming(name)] = relativeTime\n    },\n  }\n}\n\n/**\n * Timing name is used as facet path that must contain only letters, digits, or the characters - _ . @ $\n */\nfunction sanitizeTiming(name: string) {\n  const sanitized = name.replace(/[^a-zA-Z0-9-_.@$]/g, '_')\n  if (sanitized !== name) {\n    display.warn(`Invalid timing name: ${name}, sanitized to: ${sanitized}`)\n  }\n  return sanitized\n}\n\nfunction areDifferentLocation(currentLocation: Location, otherLocation: Location) {\n  return (\n    currentLocation.pathname !== otherLocation.pathname ||\n    (!isHashAnAnchor(otherLocation.hash) &&\n      getPathFromHash(otherLocation.hash) !== getPathFromHash(currentLocation.hash))\n  )\n}\n\nfunction isHashAnAnchor(hash: string) {\n  const correspondingId = hash.substr(1)\n  return !!document.getElementById(correspondingId)\n}\n\nfunction getPathFromHash(hash: string) {\n  const index = hash.indexOf('?')\n  return index < 0 ? hash : hash.slice(0, index)\n}\n","import type { Duration, ServerDuration, Observable } from '@datadog/browser-core'\nimport { isEmptyObject, mapValues, toServerDuration, isNumber } from '@datadog/browser-core'\nimport type { RecorderApi } from '../../../boot/rumPublicApi'\nimport type { RawRumViewEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle, RawRumEventCollectedData } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { ForegroundContexts } from '../../contexts/foregroundContexts'\nimport type { LocationChange } from '../../../browser/locationChangeObservable'\nimport type { RumConfiguration } from '../../configuration'\nimport type { ViewEvent, ViewOptions } from './trackViews'\nimport { trackViews } from './trackViews'\n\nexport function startViewCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  domMutationObservable: Observable<void>,\n  locationChangeObservable: Observable<LocationChange>,\n  foregroundContexts: ForegroundContexts,\n  recorderApi: RecorderApi,\n  initialViewOptions?: ViewOptions\n) {\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_UPDATED, (view) =>\n    lifeCycle.notify(\n      LifeCycleEventType.RAW_RUM_EVENT_COLLECTED,\n      processViewUpdate(view, foregroundContexts, recorderApi)\n    )\n  )\n\n  return trackViews(\n    location,\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    locationChangeObservable,\n    !configuration.trackViewsManually,\n    initialViewOptions\n  )\n}\n\nfunction processViewUpdate(\n  view: ViewEvent,\n  foregroundContexts: ForegroundContexts,\n  recorderApi: RecorderApi\n): RawRumEventCollectedData<RawRumViewEvent> {\n  const replayStats = recorderApi.getReplayStats(view.id)\n  const viewEvent: RawRumViewEvent = {\n    _dd: {\n      document_version: view.documentVersion,\n      replay_stats: replayStats,\n    },\n    date: view.startClocks.timeStamp,\n    type: RumEventType.VIEW,\n    view: {\n      action: {\n        count: view.eventCounts.actionCount,\n      },\n      frustration: {\n        count: view.eventCounts.frustrationCount,\n      },\n      cumulative_layout_shift: view.cumulativeLayoutShift,\n      first_byte: toServerDuration(view.timings.firstByte),\n      dom_complete: toServerDuration(view.timings.domComplete),\n      dom_content_loaded: toServerDuration(view.timings.domContentLoaded),\n      dom_interactive: toServerDuration(view.timings.domInteractive),\n      error: {\n        count: view.eventCounts.errorCount,\n      },\n      first_contentful_paint: toServerDuration(view.timings.firstContentfulPaint),\n      first_input_delay: toServerDuration(view.timings.firstInputDelay),\n      first_input_time: toServerDuration(view.timings.firstInputTime),\n      is_active: view.isActive,\n      name: view.name,\n      largest_contentful_paint: toServerDuration(view.timings.largestContentfulPaint),\n      load_event: toServerDuration(view.timings.loadEvent),\n      loading_time: discardNegativeDuration(toServerDuration(view.loadingTime)),\n      loading_type: view.loadingType,\n      long_task: {\n        count: view.eventCounts.longTaskCount,\n      },\n      resource: {\n        count: view.eventCounts.resourceCount,\n      },\n      time_spent: toServerDuration(view.duration),\n      in_foreground_periods: foregroundContexts.selectInForegroundPeriodsFor(view.startClocks.relative, view.duration),\n    },\n    session: {\n      has_replay: replayStats ? true : undefined,\n    },\n  }\n  if (!isEmptyObject(view.customTimings)) {\n    viewEvent.view.custom_timings = mapValues(\n      view.customTimings,\n      toServerDuration as (duration: Duration) => ServerDuration\n    )\n  }\n  return {\n    rawRumEvent: viewEvent,\n    startTime: view.startClocks.relative,\n    domainContext: {\n      location: view.location,\n    },\n  }\n}\n\nfunction discardNegativeDuration(duration: ServerDuration | undefined): ServerDuration | undefined {\n  return isNumber(duration) && duration < 0 ? undefined : duration\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport { getCookie, setCookie } from '../../browser/cookie'\nimport { isChromium } from '../../tools/browserDetection'\nimport { monitor } from '../../tools/monitor'\nimport { dateNow } from '../../tools/timeUtils'\nimport * as utils from '../../tools/utils'\nimport { SESSION_EXPIRATION_DELAY } from './sessionConstants'\nimport type { SessionState } from './sessionStore'\n\nconst SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport const SESSION_COOKIE_NAME = '_dd_s'\n\n// arbitrary values\nexport const LOCK_RETRY_DELAY = 10\nexport const MAX_NUMBER_OF_LOCK_RETRIES = 100\n\ntype Operations = {\n  options: CookieOptions\n  process: (cookieSession: SessionState) => SessionState | undefined\n  after?: (cookieSession: SessionState) => void\n}\n\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function withCookieLockAccess(operations: Operations, numberOfRetries = 0) {\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (numberOfRetries >= MAX_NUMBER_OF_LOCK_RETRIES) {\n    next()\n    return\n  }\n  let currentLock: string\n  let currentSession = retrieveSession()\n  if (isCookieLockEnabled()) {\n    // if someone has lock, retry later\n    if (currentSession.lock) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = utils.generateUUID()\n    currentSession.lock = currentLock\n    setSession(currentSession, operations.options)\n    // if lock is not acquired, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentSession)\n  if (isCookieLockEnabled()) {\n    // if lock corrupted after process, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock!) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    persistSession(processedSession, operations.options)\n  }\n  if (isCookieLockEnabled()) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentSession = retrieveSession()\n      if (currentSession.lock !== currentLock!) {\n        retryLater(operations, numberOfRetries)\n        return\n      }\n      delete currentSession.lock\n      setSession(currentSession, operations.options)\n      processedSession = currentSession\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date cookie value, the value could have been modified by another tab\n  operations.after?.(processedSession || currentSession)\n  next()\n}\n\n/**\n * Cookie lock strategy allows mitigating issues due to concurrent access to cookie.\n * This issue concerns only chromium browsers and enabling this on firefox increase cookie write failures.\n */\nfunction isCookieLockEnabled() {\n  return isChromium()\n}\n\nfunction retryLater(operations: Operations, currentNumberOfRetries: number) {\n  setTimeout(\n    monitor(() => {\n      withCookieLockAccess(operations, currentNumberOfRetries + 1)\n    }),\n    LOCK_RETRY_DELAY\n  )\n}\n\nfunction next() {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    withCookieLockAccess(nextOperations)\n  }\n}\n\nexport function persistSession(session: SessionState, options: CookieOptions) {\n  if (isExpiredState(session)) {\n    clearSession(options)\n    return\n  }\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n  setSession(session, options)\n}\n\nfunction setSession(session: SessionState, options: CookieOptions) {\n  setCookie(SESSION_COOKIE_NAME, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n}\n\nexport function toSessionString(session: SessionState) {\n  return utils\n    .objectEntries(session)\n    .map(([key, value]) => `${key}=${value as string}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function retrieveSession(): SessionState {\n  const sessionString = getCookie(SESSION_COOKIE_NAME)\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined): sessionString is string {\n  return (\n    sessionString !== undefined &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n\nfunction isExpiredState(session: SessionState) {\n  return utils.isEmptyObject(session)\n}\n\nfunction clearSession(options: CookieOptions) {\n  setCookie(SESSION_COOKIE_NAME, '', 0, options)\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport { COOKIE_ACCESS_DELAY } from '../../browser/cookie'\nimport { monitor } from '../../tools/monitor'\nimport { Observable } from '../../tools/observable'\nimport { dateNow } from '../../tools/timeUtils'\nimport * as utils from '../../tools/utils'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { retrieveSession, withCookieLockAccess } from './sessionCookieStore'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  stop: () => void\n}\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  lock?: string\n\n  [key: string]: string | undefined\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  options: CookieOptions,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  const watchSessionTimeoutId = setInterval(monitor(watchSession), COOKIE_ACCESS_DELAY)\n  let sessionCache: SessionState = retrieveActiveSession()\n\n  function expandOrRenewSession() {\n    let isTracked: boolean\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => {\n        const synchronizedSession = synchronizeSession(cookieSession)\n        isTracked = expandOrRenewCookie(synchronizedSession)\n        return synchronizedSession\n      },\n      after: (cookieSession) => {\n        if (isTracked && !hasSessionInCache()) {\n          renewSession(cookieSession)\n        }\n        sessionCache = cookieSession\n      },\n    })\n  }\n\n  function expandSession() {\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => (hasSessionInCache() ? synchronizeSession(cookieSession) : undefined),\n    })\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session cookie\n   * - if the session is not active, clear the session cookie and expire the session cache\n   */\n  function watchSession() {\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => (!isActiveSession(cookieSession) ? {} : undefined),\n      after: synchronizeSession,\n    })\n  }\n\n  function synchronizeSession(cookieSession: SessionState) {\n    if (!isActiveSession(cookieSession)) {\n      cookieSession = {}\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(cookieSession)) {\n        expireSession()\n      } else {\n        sessionCache = cookieSession\n      }\n    }\n    return cookieSession\n  }\n\n  function expandOrRenewCookie(cookieSession: SessionState) {\n    const { trackingType, isTracked } = computeSessionState(cookieSession[productKey])\n    cookieSession[productKey] = trackingType\n    if (isTracked && !cookieSession.id) {\n      cookieSession.id = utils.generateUUID()\n      cookieSession.created = String(dateNow())\n    }\n    return isTracked\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(cookieSession: SessionState) {\n    return sessionCache.id !== cookieSession.id || sessionCache[productKey] !== cookieSession[productKey]\n  }\n\n  function expireSession() {\n    sessionCache = {}\n    expireObservable.notify()\n  }\n\n  function renewSession(cookieSession: SessionState) {\n    sessionCache = cookieSession\n    renewObservable.notify()\n  }\n\n  function retrieveActiveSession(): SessionState {\n    const session = retrieveSession()\n    if (isActiveSession(session)) {\n      return session\n    }\n    return {}\n  }\n\n  function isActiveSession(session: SessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return (\n      (session.created === undefined || dateNow() - Number(session.created) < SESSION_TIME_OUT_DELAY) &&\n      (session.expire === undefined || dateNow() < Number(session.expire))\n    )\n  }\n\n  return {\n    expandOrRenewSession: utils.throttle(monitor(expandOrRenewSession), COOKIE_ACCESS_DELAY).throttled,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n  }\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport type { Observable } from '../../tools/observable'\nimport * as utils from '../../tools/utils'\nimport type { Context } from '../../tools/context'\nimport { ContextHistory } from '../../tools/contextHistory'\nimport type { RelativeTime } from '../../tools/timeUtils'\nimport { relativeNow, clocksOrigin } from '../../tools/timeUtils'\nimport { monitor } from '../../tools/monitor'\nimport { tryOldCookiesMigration } from './oldCookiesMigration'\nimport { startSessionStore } from './sessionStore'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\n\nexport interface SessionManager<TrackingType extends string> {\n  findActiveSession: (startTime?: RelativeTime) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n}\n\nexport const VISIBILITY_CHECK_DELAY = utils.ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  options: CookieOptions,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionManager<TrackingType> {\n  tryOldCookiesMigration(options)\n  const sessionStore = startSessionStore(options, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ContextHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackActivity(() => sessionStore.expandOrRenewSession())\n  trackVisibility(() => sessionStore.expandSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n    }\n  }\n\n  return {\n    findActiveSession: (startTime) => sessionContextHistory.find(startTime),\n    renewObservable: sessionStore.renewObservable,\n    expireObservable: sessionStore.expireObservable,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(expandOrRenewSession: () => void) {\n  const { stop } = utils.addEventListeners(\n    window,\n    [utils.DOM_EVENT.CLICK, utils.DOM_EVENT.TOUCH_START, utils.DOM_EVENT.KEY_DOWN, utils.DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(expandSession: () => void) {\n  const expandSessionWhenVisible = monitor(() => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  })\n\n  const { stop } = utils.addEventListener(document, utils.DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport { getCookie } from '../../browser/cookie'\nimport type { SessionState } from './sessionStore'\nimport { SESSION_COOKIE_NAME, persistSession } from './sessionCookieStore'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(options: CookieOptions) {\n  const sessionString = getCookie(SESSION_COOKIE_NAME)\n  const oldSessionId = getCookie(OLD_SESSION_COOKIE_NAME)\n  const oldRumType = getCookie(OLD_RUM_COOKIE_NAME)\n  const oldLogsType = getCookie(OLD_LOGS_COOKIE_NAME)\n  if (!sessionString) {\n    const session: SessionState = {}\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n    persistSession(session, options)\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { performDraw, startSessionManager } from '@datadog/browser-core'\nimport type { RumConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\n\nexport const RUM_SESSION_KEY = 'rum'\n\nexport interface RumSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => RumSession | undefined\n}\n\nexport type RumSession = {\n  id: string\n  plan: RumSessionPlan\n  sessionReplayAllowed: boolean\n  longTaskAllowed: boolean\n  resourceAllowed: boolean\n}\n\nexport const enum RumSessionPlan {\n  WITHOUT_SESSION_REPLAY = 1,\n  WITH_SESSION_REPLAY = 2,\n}\n\nexport const enum RumTrackingType {\n  NOT_TRACKED = '0',\n  // Note: the \"tracking type\" value (stored in the session cookie) does not match the \"session\n  // plan\" value (sent in RUM events). This is expected, and was done to keep retrocompatibility\n  // with active sessions when upgrading the SDK.\n  TRACKED_WITH_SESSION_REPLAY = '1',\n  TRACKED_WITHOUT_SESSION_REPLAY = '2',\n}\n\nexport function startRumSessionManager(configuration: RumConfiguration, lifeCycle: LifeCycle): RumSessionManager {\n  const sessionManager = startSessionManager(configuration.cookieOptions, RUM_SESSION_KEY, (rawTrackingType) =>\n    computeSessionState(configuration, rawTrackingType)\n  )\n\n  sessionManager.expireObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_EXPIRED)\n  })\n\n  sessionManager.renewObservable.subscribe(() => {\n    lifeCycle.notify(LifeCycleEventType.SESSION_RENEWED)\n  })\n\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findActiveSession(startTime)\n      if (!session || !isTypeTracked(session.trackingType)) {\n        return\n      }\n      const plan =\n        session.trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n          ? RumSessionPlan.WITH_SESSION_REPLAY\n          : RumSessionPlan.WITHOUT_SESSION_REPLAY\n      return {\n        id: session.id,\n        plan,\n        sessionReplayAllowed: plan === RumSessionPlan.WITH_SESSION_REPLAY,\n        longTaskAllowed:\n          configuration.trackLongTasks !== undefined\n            ? configuration.trackLongTasks\n            : configuration.oldPlansBehavior && plan === RumSessionPlan.WITH_SESSION_REPLAY,\n        resourceAllowed:\n          configuration.trackResources !== undefined\n            ? configuration.trackResources\n            : configuration.oldPlansBehavior && plan === RumSessionPlan.WITH_SESSION_REPLAY,\n      }\n    },\n  }\n}\n\n/**\n * Start a tracked replay session stub\n */\nexport function startRumSessionManagerStub(): RumSessionManager {\n  const session: RumSession = {\n    id: '00000000-aaaa-0000-aaaa-000000000000',\n    plan: RumSessionPlan.WITHOUT_SESSION_REPLAY, // plan value should not be taken into account for mobile\n    sessionReplayAllowed: false,\n    longTaskAllowed: true,\n    resourceAllowed: true,\n  }\n  return {\n    findTrackedSession: () => session,\n  }\n}\n\nfunction computeSessionState(configuration: RumConfiguration, rawTrackingType?: string) {\n  let trackingType: RumTrackingType\n  if (hasValidRumSession(rawTrackingType)) {\n    trackingType = rawTrackingType\n  } else if (!performDraw(configuration.sampleRate)) {\n    trackingType = RumTrackingType.NOT_TRACKED\n  } else if (!performDraw(configuration.sessionReplaySampleRate)) {\n    trackingType = RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  } else {\n    trackingType = RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  }\n  return {\n    trackingType,\n    isTracked: isTypeTracked(trackingType),\n  }\n}\n\nfunction hasValidRumSession(trackingType?: string): trackingType is RumTrackingType {\n  return (\n    trackingType === RumTrackingType.NOT_TRACKED ||\n    trackingType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY ||\n    trackingType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY\n  )\n}\n\nfunction isTypeTracked(rumSessionType: RumTrackingType | undefined) {\n  return (\n    rumSessionType === RumTrackingType.TRACKED_WITHOUT_SESSION_REPLAY ||\n    rumSessionType === RumTrackingType.TRACKED_WITH_SESSION_REPLAY\n  )\n}\n","import { display } from '../tools/display'\nimport type { Context } from '../tools/context'\nimport { addEventListener, DOM_EVENT, jsonStringify, noop, objectValues } from '../tools/utils'\nimport { monitor } from '../tools/monitor'\nimport type { HttpRequest } from './httpRequest'\n\n// https://en.wikipedia.org/wiki/UTF-8\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport class Batch {\n  private pushOnlyBuffer: string[] = []\n  private upsertBuffer: { [key: string]: string } = {}\n  private bufferBytesCount = 0\n  private bufferMessagesCount = 0\n\n  constructor(\n    private request: HttpRequest,\n    private batchMessagesLimit: number,\n    private batchBytesLimit: number,\n    private messageBytesLimit: number,\n    private flushTimeout: number,\n    private beforeUnloadCallback: () => void = noop\n  ) {\n    this.setupFlushOnExit()\n    this.flushPeriodically()\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  flush(sendFn = this.request.send) {\n    if (this.bufferMessagesCount !== 0) {\n      const messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer))\n      const bytesCount = this.bufferBytesCount\n\n      this.pushOnlyBuffer = []\n      this.upsertBuffer = {}\n      this.bufferBytesCount = 0\n      this.bufferMessagesCount = 0\n\n      sendFn({ data: messages.join('\\n'), bytesCount })\n    }\n  }\n\n  flushOnExit() {\n    this.flush(this.request.sendOnExit)\n  }\n\n  computeBytesCount(candidate: string) {\n    // Accurate bytes count computations can degrade performances when there is a lot of events to process\n    if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n      return candidate.length\n    }\n\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(candidate).length\n    }\n\n    return new Blob([candidate]).size\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const { processedMessage, messageBytesCount } = this.process(message)\n    if (messageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB.`\n      )\n      return\n    }\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n    if (this.willReachedBytesLimitWith(messageBytesCount)) {\n      this.flush()\n    }\n\n    this.push(processedMessage, messageBytesCount, key)\n    if (this.isFull()) {\n      this.flush()\n    }\n  }\n\n  private process(message: Context) {\n    const processedMessage = jsonStringify(message)!\n    const messageBytesCount = this.computeBytesCount(processedMessage)\n    return { processedMessage, messageBytesCount }\n  }\n\n  private push(processedMessage: string, messageBytesCount: number, key?: string) {\n    if (this.bufferMessagesCount > 0) {\n      // \\n separator at serialization\n      this.bufferBytesCount += 1\n    }\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage\n    } else {\n      this.pushOnlyBuffer.push(processedMessage)\n    }\n    this.bufferBytesCount += messageBytesCount\n    this.bufferMessagesCount += 1\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = this.computeBytesCount(removedMessage)\n    this.bufferBytesCount -= messageBytesCount\n    this.bufferMessagesCount -= 1\n    if (this.bufferMessagesCount > 0) {\n      this.bufferBytesCount -= 1\n    }\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n\n  private willReachedBytesLimitWith(messageBytesCount: number) {\n    // byte of the separator at the end of the message\n    return this.bufferBytesCount + messageBytesCount + 1 >= this.batchBytesLimit\n  }\n\n  private isFull() {\n    return this.bufferMessagesCount === this.batchMessagesLimit || this.bufferBytesCount >= this.batchBytesLimit\n  }\n\n  private flushPeriodically() {\n    setTimeout(\n      monitor(() => {\n        this.flush()\n        this.flushPeriodically()\n      }),\n      this.flushTimeout\n    )\n  }\n\n  private setupFlushOnExit() {\n    /**\n     * With sendBeacon, requests are guaranteed to be successfully sent during document unload\n     */\n    // @ts-ignore this function is not always defined\n    if (navigator.sendBeacon) {\n      /**\n       * beforeunload is called before visibilitychange\n       * register first to be sure to be called before flush on beforeunload\n       * caveat: unload can still be canceled by another listener\n       */\n      addEventListener(window, DOM_EVENT.BEFORE_UNLOAD, this.beforeUnloadCallback)\n\n      /**\n       * Only event that guarantee to fire on mobile devices when the page transitions to background state\n       * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n       */\n      addEventListener(document, DOM_EVENT.VISIBILITY_CHANGE, () => {\n        if (document.visibilityState === 'hidden') {\n          this.flushOnExit()\n        }\n      })\n      /**\n       * Safari does not support yet to send a request during:\n       * - a visibility change during doc unload (cf: https://bugs.webkit.org/show_bug.cgi?id=194897)\n       * - a page hide transition (cf: https://bugs.webkit.org/show_bug.cgi?id=188329)\n       */\n      addEventListener(window, DOM_EVENT.BEFORE_UNLOAD, () => this.flushOnExit())\n    }\n  }\n}\n","import type { EndpointType } from '../domain/configuration'\nimport { monitor } from '../tools/monitor'\nimport type { RawError } from '../tools/error'\nimport { clocksNow } from '../tools/timeUtils'\nimport { ONE_KIBI_BYTE, ONE_MEBI_BYTE, ONE_SECOND, ONE_MINUTE } from '../tools/utils'\nimport { ErrorSource } from '../tools/error'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, endpointType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(\n    monitor(() => {\n      const payload = state.queuedPayloads.first()\n      send(payload, state, sendStrategy, {\n        onSuccess: () => {\n          state.queuedPayloads.dequeue()\n          state.currentBackoffTime = INITIAL_BACKOFF_TIME\n          retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, endpointType, reportError)\n        },\n        onFailure: () => {\n          state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n          scheduleRetry(state, sendStrategy, endpointType, reportError)\n        },\n      })\n    }),\n    state.currentBackoffTime\n  )\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${endpointType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, endpointType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return response.status === 0 || response.status === 408 || response.status === 429 || response.status >= 500\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n","import type { EndpointBuilder } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/context'\nimport { monitor } from '../tools/monitor'\nimport type { RawError } from '../tools/error'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n}\n\nexport interface Payload {\n  data: string | FormData\n  bytesCount: number\n}\n\nexport function createHttpRequest(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(endpointBuilder: EndpointBuilder, bytesLimit: number, { data, bytesCount }: Payload) {\n  const url = endpointBuilder.build()\n  const canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const isQueued = navigator.sendBeacon(url, data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  sendXHR(url, data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount }: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const url = endpointBuilder.build()\n  const canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    fetch(url, { method: 'POST', body: data, keepalive: true }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status })),\n      monitor(() => {\n        // failed to queue the request\n        sendXHR(url, data, onResponse)\n      })\n    )\n  } else {\n    sendXHR(url, data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(url: string, data: Payload['data'], onResponse?: (r: HttpResponse) => void) {\n  const request = new XMLHttpRequest()\n  const onLoadEnd = monitor(() => {\n    // prevent multiple onResponse callbacks\n    // if the xhr instance is reused by a third party\n    request.removeEventListener('loadend', onLoadEnd)\n    onResponse?.({ status: request.status })\n  })\n  request.open('POST', url, true)\n  request.addEventListener('loadend', onLoadEnd)\n  request.send(data)\n}\n","import type { Context, EndpointBuilder, TelemetryEvent, Observable, RawError } from '@datadog/browser-core'\nimport { Batch, combine, createHttpRequest, isTelemetryReplicationAllowed } from '@datadog/browser-core'\nimport type { RumConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport { RumEventType } from '../rawRumEvent.types'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumBatch(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  telemetryEventObservable: Observable<TelemetryEvent & Context>,\n  reportError: (error: RawError) => void\n) {\n  const batch = makeRumBatch(configuration, lifeCycle, reportError)\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    if (serverRumEvent.type === RumEventType.VIEW) {\n      batch.upsert(serverRumEvent, serverRumEvent.view.id)\n    } else {\n      batch.add(serverRumEvent)\n    }\n  })\n\n  telemetryEventObservable.subscribe((event) => batch.add(event, isTelemetryReplicationAllowed(configuration)))\n}\n\ninterface RumBatch {\n  add: (message: Context, replicated?: boolean) => void\n  upsert: (message: Context, key: string) => void\n}\n\nfunction makeRumBatch(\n  configuration: RumConfiguration,\n  lifeCycle: LifeCycle,\n  reportError: (error: RawError) => void\n): RumBatch {\n  const primaryBatch = createRumBatch(configuration.rumEndpointBuilder, () =>\n    lifeCycle.notify(LifeCycleEventType.BEFORE_UNLOAD)\n  )\n\n  let replicaBatch: Batch | undefined\n  const replica = configuration.replica\n  if (replica !== undefined) {\n    replicaBatch = createRumBatch(replica.rumEndpointBuilder)\n  }\n\n  function createRumBatch(endpointBuilder: EndpointBuilder, unloadCallback?: () => void) {\n    return new Batch(\n      createHttpRequest(endpointBuilder, configuration.batchBytesLimit, reportError),\n      configuration.batchMessagesLimit,\n      configuration.batchBytesLimit,\n      configuration.messageBytesLimit,\n      configuration.flushTimeout,\n      unloadCallback\n    )\n  }\n\n  function withReplicaApplicationId(message: Context) {\n    return combine(message, { application: { id: replica!.applicationId } })\n  }\n\n  return {\n    add: (message: Context, replicated = true) => {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(withReplicaApplicationId(message))\n      }\n    },\n    upsert: (message: Context, key: string) => {\n      primaryBatch.upsert(message, key)\n      if (replicaBatch) {\n        replicaBatch.upsert(withReplicaApplicationId(message), key)\n      }\n    },\n  }\n}\n","import {\n  addEventListener,\n  DOM_EVENT,\n  instrumentMethodAndCallOriginal,\n  Observable,\n  shallowClone,\n} from '@datadog/browser-core'\n\nexport interface LocationChange {\n  oldLocation: Readonly<Location>\n  newLocation: Readonly<Location>\n}\n\nexport function createLocationChangeObservable(location: Location) {\n  let currentLocation = shallowClone(location)\n  const observable = new Observable<LocationChange>(() => {\n    const { stop: stopHistoryTracking } = trackHistory(onLocationChange)\n    const { stop: stopHashTracking } = trackHash(onLocationChange)\n    return () => {\n      stopHistoryTracking()\n      stopHashTracking()\n    }\n  })\n\n  function onLocationChange() {\n    if (currentLocation.href === location.href) {\n      return\n    }\n    const newLocation = shallowClone(location)\n    observable.notify({\n      newLocation,\n      oldLocation: currentLocation,\n    })\n    currentLocation = newLocation\n  }\n\n  return observable\n}\n\nfunction trackHistory(onHistoryChange: () => void) {\n  const { stop: stopInstrumentingPushState } = instrumentMethodAndCallOriginal(history, 'pushState', {\n    after: onHistoryChange,\n  })\n  const { stop: stopInstrumentingReplaceState } = instrumentMethodAndCallOriginal(history, 'replaceState', {\n    after: onHistoryChange,\n  })\n  const { stop: removeListener } = addEventListener(window, DOM_EVENT.POP_STATE, onHistoryChange)\n\n  return {\n    stop: () => {\n      stopInstrumentingPushState()\n      stopInstrumentingReplaceState()\n      removeListener()\n    },\n  }\n}\n\nfunction trackHash(onHashChange: () => void) {\n  return addEventListener(window, DOM_EVENT.HASH_CHANGE, onHashChange)\n}\n","// Keep the following in sync with packages/rum/src/entries/main.ts\nimport { defineGlobal, getGlobalObject, noop } from '@datadog/browser-core'\nimport type { RumPublicApi } from '@datadog/browser-rum-core'\nimport { makeRumPublicApi, startRum } from '@datadog/browser-rum-core'\n\nexport {\n  CommonProperties,\n  RumPublicApi as RumGlobal,\n  RumInitConfiguration,\n  // Events\n  RumEvent,\n  RumActionEvent,\n  RumErrorEvent,\n  RumLongTaskEvent,\n  RumResourceEvent,\n  RumViewEvent,\n  // Events context\n  RumEventDomainContext,\n  RumViewEventDomainContext,\n  RumErrorEventDomainContext,\n  RumActionEventDomainContext,\n  RumFetchResourceEventDomainContext,\n  RumXhrResourceEventDomainContext,\n  RumOtherResourceEventDomainContext,\n  RumLongTaskEventDomainContext,\n} from '@datadog/browser-rum-core'\nexport { DefaultPrivacyLevel } from '@datadog/browser-core'\n\nexport const datadogRum = makeRumPublicApi(startRum, {\n  start: noop,\n  stop: noop,\n  onRumStart: noop,\n  isRecording: () => false,\n  getReplayStats: () => undefined,\n})\n\ninterface BrowserWindow extends Window {\n  DD_RUM?: RumPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_RUM', datadogRum)\n","import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { assign } from '../tools/utils'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport function makePublicApi<T>(stub: T): T & { onReady(callback: () => void): void; version: string } {\n  const publicApi = assign(\n    {\n      version: __BUILD_ENV__SDK_VERSION__,\n\n      // This API method is intentionally not monitored, since the only thing executed is the\n      // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n      // we don't want to interfere with the user uncaught exceptions.\n      onReady(callback: () => void) {\n        callback()\n      },\n    },\n    stub\n  )\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable: { q?: Array<() => void> } | undefined = global[name]\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n","import type { Context, InitConfiguration, TimeStamp, RelativeTime } from '@datadog/browser-core'\nimport {\n  willSyntheticsInjectRum,\n  assign,\n  BoundedBuffer,\n  buildCookieOptions,\n  createContextManager,\n  deepClone,\n  makePublicApi,\n  monitor,\n  clocksNow,\n  timeStampNow,\n  display,\n  callMonitored,\n  createHandlingStack,\n  canUseEventBridge,\n  areCookiesAuthorized,\n} from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport type { ViewContexts } from '../domain/contexts/viewContexts'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport type { User, ReplayStats } from '../rawRumEvent.types'\nimport { ActionType } from '../rawRumEvent.types'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport { validateAndBuildRumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/rumEventsCollection/view/trackViews'\nimport type { startRum } from './startRum'\n\nexport type RumPublicApi = ReturnType<typeof makeRumPublicApi>\n\nexport type StartRum = typeof startRum\n\ntype StartRumResult = ReturnType<typeof startRum>\n\nexport interface RecorderApi {\n  start: () => void\n  stop: () => void\n  onRumStart: (\n    lifeCycle: LifeCycle,\n    configuration: RumConfiguration,\n    sessionManager: RumSessionManager,\n    viewContexts: ViewContexts\n  ) => void\n  isRecording: () => boolean\n  getReplayStats: (viewId: string) => ReplayStats | undefined\n}\ninterface RumPublicApiOptions {\n  ignoreInitIfSyntheticsWillInjectRum?: boolean\n}\n\nexport function makeRumPublicApi(\n  startRumImpl: StartRum,\n  recorderApi: RecorderApi,\n  { ignoreInitIfSyntheticsWillInjectRum = true }: RumPublicApiOptions = {}\n) {\n  let isAlreadyInitialized = false\n\n  const globalContextManager = createContextManager()\n  const userContextManager = createContextManager()\n\n  let getInternalContextStrategy: StartRumResult['getInternalContext'] = () => undefined\n  let getInitConfigurationStrategy = (): InitConfiguration | undefined => undefined\n\n  let bufferApiCalls = new BoundedBuffer()\n  let addTimingStrategy: StartRumResult['addTiming'] = (name, time = timeStampNow()) => {\n    bufferApiCalls.add(() => addTimingStrategy(name, time))\n  }\n  let startViewStrategy: StartRumResult['startView'] = (options, startClocks = clocksNow()) => {\n    bufferApiCalls.add(() => startViewStrategy(options, startClocks))\n  }\n  let addActionStrategy: StartRumResult['addAction'] = (\n    action,\n    commonContext = {\n      context: globalContextManager.getContext(),\n      user: userContextManager.getContext(),\n    }\n  ) => {\n    bufferApiCalls.add(() => addActionStrategy(action, commonContext))\n  }\n  let addErrorStrategy: StartRumResult['addError'] = (\n    providedError,\n    commonContext = {\n      context: globalContextManager.getContext(),\n      user: userContextManager.getContext(),\n    }\n  ) => {\n    bufferApiCalls.add(() => addErrorStrategy(providedError, commonContext))\n  }\n\n  function initRum(initConfiguration: RumInitConfiguration) {\n    // If we are in a Synthetics test configured to automatically inject a RUM instance, we want to\n    // completely discard the customer application RUM instance by ignoring their init() call.  But,\n    // we should not ignore the init() call from the Synthetics-injected RUM instance, so the\n    // internal `ignoreInitIfSyntheticsWillInjectRum` option is here to bypass this condition.\n    if (ignoreInitIfSyntheticsWillInjectRum && willSyntheticsInjectRum()) {\n      return\n    }\n\n    if (canUseEventBridge()) {\n      initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n    } else if (!canHandleSession(initConfiguration)) {\n      return\n    }\n\n    if (!canInitRum(initConfiguration)) {\n      return\n    }\n\n    const configuration = validateAndBuildRumConfiguration(initConfiguration)\n    if (!configuration) {\n      return\n    }\n\n    if (!configuration.trackViewsManually) {\n      doStartRum(initConfiguration, configuration)\n    } else {\n      // drain beforeInitCalls by buffering them until we start RUM\n      // if we get a startView, drain re-buffered calls before continuing to drain beforeInitCalls\n      // in order to ensure that calls are processed in order\n      const beforeInitCalls = bufferApiCalls\n      bufferApiCalls = new BoundedBuffer()\n\n      startViewStrategy = (options) => {\n        doStartRum(initConfiguration, configuration, options)\n      }\n      beforeInitCalls.drain()\n    }\n    getInitConfigurationStrategy = () => deepClone<InitConfiguration>(initConfiguration)\n\n    isAlreadyInitialized = true\n  }\n\n  function doStartRum(\n    initConfiguration: RumInitConfiguration,\n    configuration: RumConfiguration,\n    initialViewOptions?: ViewOptions\n  ) {\n    const startRumResults = startRumImpl(\n      initConfiguration,\n      configuration,\n      () => ({\n        user: userContextManager.getContext(),\n        context: globalContextManager.getContext(),\n        hasReplay: recorderApi.isRecording() ? true : undefined,\n      }),\n      recorderApi,\n      initialViewOptions\n    )\n\n    ;({\n      startView: startViewStrategy,\n      addAction: addActionStrategy,\n      addError: addErrorStrategy,\n      addTiming: addTimingStrategy,\n      getInternalContext: getInternalContextStrategy,\n    } = startRumResults)\n    bufferApiCalls.drain()\n\n    recorderApi.onRumStart(\n      startRumResults.lifeCycle,\n      configuration,\n      startRumResults.session,\n      startRumResults.viewContexts\n    )\n  }\n\n  const startView: {\n    (name?: string): void\n    (options: ViewOptions): void\n  } = monitor((options?: string | ViewOptions) => {\n    const sanitizedOptions = typeof options === 'object' ? options : { name: options }\n    startViewStrategy(sanitizedOptions)\n  })\n\n  const rumPublicApi = makePublicApi({\n    init: monitor(initRum),\n\n    /** @deprecated: use setGlobalContextProperty instead */\n    addRumGlobalContext: monitor(globalContextManager.add),\n    setGlobalContextProperty: monitor(globalContextManager.setContextProperty),\n\n    /** @deprecated: use removeGlobalContextProperty instead */\n    removeRumGlobalContext: monitor(globalContextManager.remove),\n    removeGlobalContextProperty: monitor(globalContextManager.removeContextProperty),\n\n    /** @deprecated: use getGlobalContext instead */\n    getRumGlobalContext: monitor(globalContextManager.get),\n    getGlobalContext: monitor(globalContextManager.getContext),\n\n    /** @deprecated: use setGlobalContext instead */\n    setRumGlobalContext: monitor(globalContextManager.set),\n    setGlobalContext: monitor(globalContextManager.setContext),\n\n    clearGlobalContext: monitor(globalContextManager.clearContext),\n\n    getInternalContext: monitor((startTime?: number) => getInternalContextStrategy(startTime)),\n    getInitConfiguration: monitor(() => getInitConfigurationStrategy()),\n\n    addAction: monitor((name: string, context?: object) => {\n      addActionStrategy({\n        name,\n        context: deepClone(context as Context),\n        startClocks: clocksNow(),\n        type: ActionType.CUSTOM,\n      })\n    }),\n\n    addError: (error: unknown, context?: object) => {\n      const handlingStack = createHandlingStack()\n      callMonitored(() => {\n        addErrorStrategy({\n          error,\n          handlingStack,\n          context: deepClone(context as Context),\n          startClocks: clocksNow(),\n        })\n      })\n    },\n\n    addTiming: monitor((name: string, time?: number) => {\n      addTimingStrategy(name, time as RelativeTime | TimeStamp | undefined)\n    }),\n\n    setUser: monitor((newUser: User) => {\n      if (typeof newUser !== 'object' || !newUser) {\n        display.error('Unsupported user:', newUser)\n      } else {\n        userContextManager.setContext(sanitizeUser(newUser as Context))\n      }\n    }),\n\n    getUser: monitor(userContextManager.getContext),\n\n    setUserProperty: monitor((key, property) => {\n      const sanitizedProperty = sanitizeUser({ [key]: property })[key]\n      userContextManager.setContextProperty(key, sanitizedProperty)\n    }),\n\n    removeUserProperty: monitor(userContextManager.removeContextProperty),\n\n    /** @deprecated: renamed to clearUser */\n    removeUser: monitor(userContextManager.clearContext),\n    clearUser: monitor(userContextManager.clearContext),\n\n    startView,\n\n    startSessionReplayRecording: monitor(recorderApi.start),\n    stopSessionReplayRecording: monitor(recorderApi.stop),\n  })\n  return rumPublicApi\n\n  function sanitizeUser(newUser: Context) {\n    const shallowClonedUser = assign(newUser, {})\n    if ('id' in shallowClonedUser) {\n      shallowClonedUser.id = String(shallowClonedUser.id)\n    }\n    if ('name' in shallowClonedUser) {\n      shallowClonedUser.name = String(shallowClonedUser.name)\n    }\n    if ('email' in shallowClonedUser) {\n      shallowClonedUser.email = String(shallowClonedUser.email)\n    }\n    return shallowClonedUser\n  }\n\n  function canHandleSession(initConfiguration: RumInitConfiguration): boolean {\n    if (!areCookiesAuthorized(buildCookieOptions(initConfiguration))) {\n      display.warn('Cookies are not authorized, we will not send any data.')\n      return false\n    }\n\n    if (isLocalFile()) {\n      display.error('Execution is not allowed in the current context.')\n      return false\n    }\n    return true\n  }\n\n  function canInitRum(initConfiguration: RumInitConfiguration) {\n    if (isAlreadyInitialized) {\n      if (!initConfiguration.silentMultipleInit) {\n        display.error('DD_RUM is already initialized.')\n      }\n      return false\n    }\n    return true\n  }\n\n  function overrideInitConfigurationForBridge<C extends InitConfiguration>(initConfiguration: C): C {\n    return assign({}, initConfiguration, {\n      applicationId: '00000000-aaaa-0000-aaaa-000000000000',\n      clientToken: 'empty',\n      sampleRate: 100,\n    })\n  }\n\n  function isLocalFile() {\n    return window.location.protocol === 'file:'\n  }\n}\n","import type { Configuration, InitConfiguration, MatchOption, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  serializeConfiguration,\n  assign,\n  DefaultPrivacyLevel,\n  display,\n  isPercentage,\n  objectHasValue,\n  validateAndBuildConfiguration,\n} from '@datadog/browser-core'\nimport type { RumEventDomainContext } from '../domainContext.types'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport interface RumInitConfiguration extends InitConfiguration {\n  // global options\n  applicationId: string\n  beforeSend?: ((event: RumEvent, context: RumEventDomainContext) => void | boolean) | undefined\n  /**\n   * @deprecated use sessionReplaySampleRate instead\n   */\n  premiumSampleRate?: number | undefined\n  excludedActivityUrls?: MatchOption[] | undefined\n\n  // tracing options\n  allowedTracingOrigins?: MatchOption[] | undefined\n  tracingSampleRate?: number | undefined\n\n  // replay options\n  defaultPrivacyLevel?: DefaultPrivacyLevel | undefined\n  /**\n   * @deprecated use sessionReplaySampleRate instead\n   */\n  replaySampleRate?: number | undefined\n  sessionReplaySampleRate?: number | undefined\n\n  // action options\n  trackInteractions?: boolean | undefined\n  trackFrustrations?: boolean | undefined\n  actionNameAttribute?: string | undefined\n\n  // view options\n  trackViewsManually?: boolean | undefined\n\n  trackResources?: boolean | undefined\n  trackLongTasks?: boolean | undefined\n}\n\nexport type HybridInitConfiguration = Omit<RumInitConfiguration, 'applicationId' | 'clientToken'>\n\nexport interface RumConfiguration extends Configuration {\n  // Built from init configuration\n  actionNameAttribute: string | undefined\n  allowedTracingOrigins: MatchOption[]\n  tracingSampleRate: number | undefined\n  excludedActivityUrls: MatchOption[]\n  applicationId: string\n  defaultPrivacyLevel: DefaultPrivacyLevel\n  oldPlansBehavior: boolean\n  sessionReplaySampleRate: number\n  trackInteractions: boolean\n  trackFrustrations: boolean\n  trackViewsManually: boolean\n  trackResources: boolean | undefined\n  trackLongTasks: boolean | undefined\n  version?: string\n}\n\nexport function validateAndBuildRumConfiguration(\n  initConfiguration: RumInitConfiguration\n): RumConfiguration | undefined {\n  if (!initConfiguration.applicationId) {\n    display.error('Application ID is not configured, no RUM data will be collected.')\n    return\n  }\n\n  if (\n    initConfiguration.sessionReplaySampleRate !== undefined &&\n    !isPercentage(initConfiguration.sessionReplaySampleRate)\n  ) {\n    display.error('Session Replay Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  // TODO remove fallback in next major\n  let premiumSampleRate = initConfiguration.premiumSampleRate ?? initConfiguration.replaySampleRate\n  if (premiumSampleRate !== undefined && initConfiguration.sessionReplaySampleRate !== undefined) {\n    display.warn('Ignoring Premium Sample Rate because Session Replay Sample Rate is set')\n    premiumSampleRate = undefined\n  }\n\n  if (premiumSampleRate !== undefined && !isPercentage(premiumSampleRate)) {\n    display.error('Premium Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.tracingSampleRate !== undefined && !isPercentage(initConfiguration.tracingSampleRate)) {\n    display.error('Tracing Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.allowedTracingOrigins !== undefined) {\n    if (!Array.isArray(initConfiguration.allowedTracingOrigins)) {\n      display.error('Allowed Tracing Origins should be an array')\n      return\n    }\n    if (initConfiguration.allowedTracingOrigins.length !== 0 && initConfiguration.service === undefined) {\n      display.error('Service need to be configured when tracing is enabled')\n      return\n    }\n  }\n\n  if (initConfiguration.excludedActivityUrls !== undefined && !Array.isArray(initConfiguration.excludedActivityUrls)) {\n    display.error('Excluded Activity Urls should be an array')\n    return\n  }\n\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n  if (!baseConfiguration) {\n    return\n  }\n\n  const trackFrustrations = !!initConfiguration.trackFrustrations\n\n  return assign(\n    {\n      applicationId: initConfiguration.applicationId,\n      version: initConfiguration.version,\n      actionNameAttribute: initConfiguration.actionNameAttribute,\n      sessionReplaySampleRate: initConfiguration.sessionReplaySampleRate ?? premiumSampleRate ?? 100,\n      oldPlansBehavior: initConfiguration.sessionReplaySampleRate === undefined,\n      allowedTracingOrigins: initConfiguration.allowedTracingOrigins ?? [],\n      tracingSampleRate: initConfiguration.tracingSampleRate,\n      excludedActivityUrls: initConfiguration.excludedActivityUrls ?? [],\n      trackInteractions: !!initConfiguration.trackInteractions || trackFrustrations,\n      trackFrustrations,\n      trackViewsManually: !!initConfiguration.trackViewsManually,\n      trackResources: initConfiguration.trackResources,\n      trackLongTasks: initConfiguration.trackLongTasks,\n      defaultPrivacyLevel: objectHasValue(DefaultPrivacyLevel, initConfiguration.defaultPrivacyLevel)\n        ? initConfiguration.defaultPrivacyLevel\n        : DefaultPrivacyLevel.MASK_USER_INPUT,\n    },\n    baseConfiguration\n  )\n}\n\nexport function serializeRumConfiguration(configuration: RumInitConfiguration): RawTelemetryConfiguration {\n  const baseSerializedConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      premium_sample_rate: configuration.premiumSampleRate,\n      replay_sample_rate: configuration.replaySampleRate,\n      session_replay_sample_rate: configuration.sessionReplaySampleRate,\n      trace_sample_rate: configuration.tracingSampleRate,\n      action_name_attribute: configuration.actionNameAttribute,\n      use_allowed_tracing_origins:\n        Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0,\n      default_privacy_level: configuration.defaultPrivacyLevel,\n      use_excluded_activity_urls:\n        Array.isArray(configuration.allowedTracingOrigins) && configuration.allowedTracingOrigins.length > 0,\n      track_frustrations: configuration.trackFrustrations,\n      track_views_manually: configuration.trackViewsManually,\n      track_interactions: configuration.trackInteractions,\n    },\n    baseSerializedConfiguration\n  )\n}\n","import type { Observable, TelemetryEvent, RawError } from '@datadog/browser-core'\nimport {\n  TelemetryService,\n  addTelemetryConfiguration,\n  startTelemetry,\n  canUseEventBridge,\n  getEventBridge,\n} from '@datadog/browser-core'\nimport { createDOMMutationObservable } from '../browser/domMutationObservable'\nimport { startPerformanceCollection } from '../browser/performanceCollection'\nimport { startRumAssembly } from '../domain/assembly'\nimport { startForegroundContexts } from '../domain/contexts/foregroundContexts'\nimport { startInternalContext } from '../domain/contexts/internalContext'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startViewContexts } from '../domain/contexts/viewContexts'\nimport { startRequestCollection } from '../domain/requestCollection'\nimport { startActionCollection } from '../domain/rumEventsCollection/action/actionCollection'\nimport { startErrorCollection } from '../domain/rumEventsCollection/error/errorCollection'\nimport { startLongTaskCollection } from '../domain/rumEventsCollection/longTask/longTaskCollection'\nimport { startResourceCollection } from '../domain/rumEventsCollection/resource/resourceCollection'\nimport { startViewCollection } from '../domain/rumEventsCollection/view/viewCollection'\nimport type { RumSessionManager } from '../domain/rumSessionManager'\nimport { startRumSessionManager, startRumSessionManagerStub } from '../domain/rumSessionManager'\nimport type { CommonContext } from '../rawRumEvent.types'\nimport { startRumBatch } from '../transport/startRumBatch'\nimport { startRumEventBridge } from '../transport/startRumEventBridge'\nimport { startUrlContexts } from '../domain/contexts/urlContexts'\nimport type { LocationChange } from '../browser/locationChangeObservable'\nimport { createLocationChangeObservable } from '../browser/locationChangeObservable'\nimport type { RumConfiguration, RumInitConfiguration } from '../domain/configuration'\nimport { serializeRumConfiguration } from '../domain/configuration'\nimport type { ViewOptions } from '../domain/rumEventsCollection/view/trackViews'\nimport type { RecorderApi } from './rumPublicApi'\n\nexport function startRum(\n  initConfiguration: RumInitConfiguration,\n  configuration: RumConfiguration,\n  getCommonContext: () => CommonContext,\n  recorderApi: RecorderApi,\n  initialViewOptions?: ViewOptions\n) {\n  const lifeCycle = new LifeCycle()\n\n  const telemetry = startRumTelemetry(configuration)\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: configuration.applicationId,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: viewContexts.findView()?.id,\n    },\n    action: {\n      id: actionContexts.findActionId(),\n    },\n  }))\n\n  const reportError = (error: RawError) => {\n    lifeCycle.notify(LifeCycleEventType.RAW_ERROR_COLLECTED, { error })\n  }\n  if (!canUseEventBridge()) {\n    startRumBatch(configuration, lifeCycle, telemetry.observable, reportError)\n  } else {\n    startRumEventBridge(lifeCycle)\n  }\n\n  const session = !canUseEventBridge() ? startRumSessionManager(configuration, lifeCycle) : startRumSessionManagerStub()\n  const domMutationObservable = createDOMMutationObservable()\n  const locationChangeObservable = createLocationChangeObservable(location)\n\n  const { viewContexts, foregroundContexts, urlContexts, actionContexts, addAction } = startRumEventCollection(\n    lifeCycle,\n    configuration,\n    location,\n    session,\n    locationChangeObservable,\n    domMutationObservable,\n    getCommonContext,\n    reportError\n  )\n  addTelemetryConfiguration(serializeRumConfiguration(initConfiguration))\n\n  startLongTaskCollection(lifeCycle, session)\n  startResourceCollection(lifeCycle, configuration, session)\n  const { addTiming, startView } = startViewCollection(\n    lifeCycle,\n    configuration,\n    location,\n    domMutationObservable,\n    locationChangeObservable,\n    foregroundContexts,\n    recorderApi,\n    initialViewOptions\n  )\n  const { addError } = startErrorCollection(lifeCycle, foregroundContexts)\n\n  startRequestCollection(lifeCycle, configuration, session)\n  startPerformanceCollection(lifeCycle, configuration)\n\n  const internalContext = startInternalContext(\n    configuration.applicationId,\n    session,\n    viewContexts,\n    actionContexts,\n    urlContexts\n  )\n\n  return {\n    addAction,\n    addError,\n    addTiming,\n    startView,\n    lifeCycle,\n    viewContexts,\n    session,\n    getInternalContext: internalContext.get,\n  }\n}\n\nfunction startRumTelemetry(configuration: RumConfiguration) {\n  const telemetry = startTelemetry(TelemetryService.RUM, configuration)\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n  }\n  return telemetry\n}\n\nexport function startRumEventCollection(\n  lifeCycle: LifeCycle,\n  configuration: RumConfiguration,\n  location: Location,\n  sessionManager: RumSessionManager,\n  locationChangeObservable: Observable<LocationChange>,\n  domMutationObservable: Observable<void>,\n  getCommonContext: () => CommonContext,\n  reportError: (error: RawError) => void\n) {\n  const viewContexts = startViewContexts(lifeCycle)\n  const urlContexts = startUrlContexts(lifeCycle, locationChangeObservable, location)\n  const foregroundContexts = startForegroundContexts()\n  const { addAction, actionContexts } = startActionCollection(\n    lifeCycle,\n    domMutationObservable,\n    configuration,\n    foregroundContexts\n  )\n\n  startRumAssembly(\n    configuration,\n    lifeCycle,\n    sessionManager,\n    viewContexts,\n    urlContexts,\n    actionContexts,\n    getCommonContext,\n    reportError\n  )\n\n  return {\n    viewContexts,\n    foregroundContexts,\n    urlContexts,\n    addAction,\n    actionContexts,\n    stop: () => {\n      viewContexts.stop()\n      foregroundContexts.stop()\n    },\n  }\n}\n","import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { RumEvent } from '../rumEvent.types'\n\nexport function startRumEventBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'rum', RumEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.RUM_EVENT_COLLECTED, (serverRumEvent: RumEvent & Context) => {\n    bridge.send('rum', serverRumEvent)\n  })\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, ContextHistory } from '@datadog/browser-core'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\nimport type { ViewCreatedEvent } from '../rumEventsCollection/view/trackViews'\n\nexport const VIEW_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface ViewContext {\n  service?: string\n  version?: string\n  id: string\n  name?: string\n}\n\nexport interface ViewContexts {\n  findView: (startTime?: RelativeTime) => ViewContext | undefined\n  stop: () => void\n}\n\nexport function startViewContexts(lifeCycle: LifeCycle): ViewContexts {\n  const viewContextHistory = new ContextHistory<ViewContext>(VIEW_CONTEXT_TIME_OUT_DELAY)\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, (view) => {\n    viewContextHistory.add(buildViewContext(view), view.startClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    viewContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.SESSION_RENEWED, () => {\n    viewContextHistory.reset()\n  })\n\n  function buildViewContext(view: ViewCreatedEvent) {\n    return {\n      service: view.service,\n      version: view.version,\n      id: view.id,\n      name: view.name,\n    }\n  }\n\n  return {\n    findView: (startTime) => viewContextHistory.find(startTime),\n    stop: () => {\n      viewContextHistory.stop()\n    },\n  }\n}\n","import type { RelativeTime, Observable } from '@datadog/browser-core'\nimport { SESSION_TIME_OUT_DELAY, relativeNow, ContextHistory } from '@datadog/browser-core'\nimport type { LocationChange } from '../../browser/locationChangeObservable'\nimport type { LifeCycle } from '../lifeCycle'\nimport { LifeCycleEventType } from '../lifeCycle'\n\n/**\n * We want to attach to an event:\n * - the url corresponding to its start\n * - the referrer corresponding to the previous view url (or document referrer for initial view)\n */\n\nexport const URL_CONTEXT_TIME_OUT_DELAY = SESSION_TIME_OUT_DELAY\n\nexport interface UrlContext {\n  url: string\n  referrer: string\n}\n\nexport interface UrlContexts {\n  findUrl: (startTime?: RelativeTime) => UrlContext | undefined\n  stop: () => void\n}\n\nexport function startUrlContexts(\n  lifeCycle: LifeCycle,\n  locationChangeObservable: Observable<LocationChange>,\n  location: Location\n) {\n  const urlContextHistory = new ContextHistory<UrlContext>(URL_CONTEXT_TIME_OUT_DELAY)\n\n  let previousViewUrl: string | undefined\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_ENDED, ({ endClocks }) => {\n    urlContextHistory.closeActive(endClocks.relative)\n  })\n\n  lifeCycle.subscribe(LifeCycleEventType.VIEW_CREATED, ({ startClocks }) => {\n    const viewUrl = location.href\n    urlContextHistory.add(\n      buildUrlContext({\n        url: viewUrl,\n        referrer: !previousViewUrl ? document.referrer : previousViewUrl,\n      }),\n      startClocks.relative\n    )\n    previousViewUrl = viewUrl\n  })\n\n  const locationChangeSubscription = locationChangeObservable.subscribe(({ newLocation }) => {\n    const current = urlContextHistory.find()\n    if (current) {\n      const changeTime = relativeNow()\n      urlContextHistory.closeActive(changeTime)\n      urlContextHistory.add(\n        buildUrlContext({\n          url: newLocation.href,\n          referrer: current.referrer,\n        }),\n        changeTime\n      )\n    }\n  })\n\n  function buildUrlContext({ url, referrer }: { url: string; referrer: string }) {\n    return {\n      url,\n      referrer,\n    }\n  }\n\n  return {\n    findUrl: (startTime?: RelativeTime) => urlContextHistory.find(startTime),\n    stop: () => {\n      locationChangeSubscription.unsubscribe()\n      urlContextHistory.stop()\n    },\n  }\n}\n","import { toServerDuration, relativeToClocks, generateUUID } from '@datadog/browser-core'\nimport type { RawRumLongTaskEvent } from '../../../rawRumEvent.types'\nimport { RumEventType } from '../../../rawRumEvent.types'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { RumSessionManager } from '../../rumSessionManager'\n\nexport function startLongTaskCollection(lifeCycle: LifeCycle, sessionManager: RumSessionManager) {\n  lifeCycle.subscribe(LifeCycleEventType.PERFORMANCE_ENTRIES_COLLECTED, (entries) => {\n    for (const entry of entries) {\n      if (entry.entryType !== 'longtask') {\n        break\n      }\n      const session = sessionManager.findTrackedSession(entry.startTime)\n      if (!session || !session.longTaskAllowed) {\n        break\n      }\n      const startClocks = relativeToClocks(entry.startTime)\n      const rawRumEvent: RawRumLongTaskEvent = {\n        date: startClocks.timeStamp,\n        long_task: {\n          id: generateUUID(),\n          duration: toServerDuration(entry.duration),\n        },\n        type: RumEventType.LONG_TASK,\n        _dd: {\n          discarded: false,\n        },\n      }\n      lifeCycle.notify(LifeCycleEventType.RAW_RUM_EVENT_COLLECTED, {\n        rawRumEvent,\n        startTime: startClocks.relative,\n        domainContext: { performanceEntry: entry.toJSON() },\n      })\n    }\n  })\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport type { ActionContexts } from '../rumEventsCollection/action/actionCollection'\nimport type { RumSessionManager } from '../rumSessionManager'\nimport type { ViewContexts } from './viewContexts'\nimport type { UrlContexts } from './urlContexts'\n\nexport interface InternalContext {\n  application_id: string\n  session_id: string | undefined\n  view?: {\n    id: string\n    url: string\n    referrer: string\n    name?: string\n  }\n  user_action?: {\n    id: string | string[]\n  }\n}\n\n/**\n * Internal context keep returning v1 format\n * to not break compatibility with logs data format\n */\nexport function startInternalContext(\n  applicationId: string,\n  sessionManager: RumSessionManager,\n  viewContexts: ViewContexts,\n  actionContexts: ActionContexts,\n  urlContexts: UrlContexts\n) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const viewContext = viewContexts.findView(startTime as RelativeTime)\n      const urlContext = urlContexts.findUrl(startTime as RelativeTime)\n      const session = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (session && viewContext && urlContext) {\n        const actionId = actionContexts.findActionId(startTime as RelativeTime)\n        return {\n          application_id: applicationId,\n          session_id: session.id,\n          user_action: actionId ? { id: actionId } : undefined,\n          view: { id: viewContext.id, name: viewContext.name, referrer: urlContext.referrer, url: urlContext.url },\n        }\n      }\n    },\n  }\n}\n"],"sourceRoot":""}