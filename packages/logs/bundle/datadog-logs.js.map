{"version":3,"sources":["webpack:///../core/src/tools/display.ts","webpack:///../core/src/tools/catchUserErrors.ts","webpack:///../core/src/tools/monitor.ts","webpack:///../core/src/tools/utils.ts","webpack:///../core/src/tools/contextManager.ts","webpack:///../core/src/tools/boundedBuffer.ts","webpack:///../core/src/tools/timeUtils.ts","webpack:///../core/src/transport/eventBridge.ts","webpack:///../core/src/browser/cookie.ts","webpack:///../core/src/domain/configuration/experimentalFeatures.ts","webpack:///../core/src/tools/urlPolyfill.ts","webpack:///../core/src/domain/configuration/intakeSites.ts","webpack:///../core/src/domain/configuration/endpointBuilder.ts","webpack:///../core/src/domain/configuration/tags.ts","webpack:///../core/src/domain/configuration/transportConfiguration.ts","webpack:///../core/src/domain/configuration/configuration.ts","webpack:///../core/src/domain/tracekit/computeStackTrace.ts","webpack:///../core/src/tools/error.ts","webpack:///../core/src/tools/observable.ts","webpack:///../core/src/domain/report/reportObservable.ts","webpack:///./src/domain/configuration.ts","webpack:///./src/domain/logger.ts","webpack:///../core/src/domain/synthetics/syntheticsWorkerValues.ts","webpack:///../core/src/domain/telemetry/rawTelemetryEvent.types.ts","webpack:///../core/src/domain/telemetry/telemetry.ts","webpack:///../core/src/transport/batch.ts","webpack:///../core/src/transport/sendWithRetryStrategy.ts","webpack:///../core/src/transport/httpRequest.ts","webpack:///../core/src/transport/startBatchWithReplica.ts","webpack:///../core/src/tools/contextHistory.ts","webpack:///../core/src/domain/session/sessionConstants.ts","webpack:///../core/src/domain/session/sessionCookieStore.ts","webpack:///../core/src/tools/browserDetection.ts","webpack:///../core/src/domain/session/sessionStore.ts","webpack:///../core/src/domain/session/sessionManager.ts","webpack:///../core/src/domain/session/oldCookiesMigration.ts","webpack:///./src/domain/logsSessionManager.ts","webpack:///./src/domain/logsCollection/logger/loggerCollection.ts","webpack:///./src/domain/assembly.ts","webpack:///../core/src/tools/createEventRateLimiter.ts","webpack:///../core/src/domain/console/consoleObservable.ts","webpack:///./src/domain/logsCollection/console/consoleCollection.ts","webpack:///./src/domain/logsCollection/report/reportCollection.ts","webpack:///../core/src/browser/xhrObservable.ts","webpack:///../core/src/tools/instrumentMethod.ts","webpack:///../core/src/browser/fetchObservable.ts","webpack:///./src/domain/logsCollection/networkError/networkErrorCollection.ts","webpack:///../core/src/domain/tracekit/tracekit.ts","webpack:///../core/src/domain/error/trackRuntimeError.ts","webpack:///./src/domain/lifeCycle.ts","webpack:///./src/entries/main.ts","webpack:///../core/src/boot/init.ts","webpack:///./src/boot/logsPublicApi.ts","webpack:///./src/boot/startLogs.ts","webpack:///./src/domain/logsCollection/runtimeError/runtimeErrorCollection.ts","webpack:///./src/domain/internalContext.ts","webpack:///./src/transport/startLogsBridge.ts","webpack:///./src/transport/startLogsBatch.ts"],"names":["ConsoleApiName","log","debug","info","warn","error","api","Object","prototype","hasOwnProperty","call","args","catchUserErrors","fn","errorMsg","err","console","bind","onMonitorErrorCollected","debugMode","setDebugMode","newDebugMode","monitored","_","__","descriptor","originalMethod","value","decorated","apply","this","callMonitored","arguments","context","e","displayIfDebugEnabled","ONE_SECOND","ONE_MINUTE","throttle","wait","options","pendingExecutionWithParameters","pendingTimeoutId","needLeadingExecution","undefined","leading","needTrailingExecution","trailing","inWaitPeriod","throttled","parameters","setTimeout","cancel","clearTimeout","target","toAssign","forEach","source","key","generateUUID","placeholder","parseInt","Math","random","toString","replace","performDraw","threshold","jsonStringify","space","JSON","stringify","circularReferenceChecker","restoreObjectPrototypeToJson","detachToJsonMethod","restoreArrayPrototypeToJson","Array","restoreValuePrototypeToJson","getPrototypeOf","restoreValueToJson","createCircularReferenceChecker","_key","type","getType","hasAlreadyBeenSeen","object","objectToJson","toJSON","includes","candidate","search","indexOf","arrayFrom","arrayLike","from","array","Set","item","push","i","length","isPercentage","objectValues","keys","map","startsWith","slice","getGlobalObject","globalThis","defineProperty","get","configurable","globalObject","_dd_temp_","self","window","safeTruncate","suffix","lastChar","charCodeAt","correctedLength","addEventListener","emitter","event","listener","addEventListeners","events","once","capture","passive","wrappedListener","stop","removeEventListener","isArray","WeakMap","has","set","mergeInto","destination","Date","getTime","RegExp","flags","global","ignoreCase","multiline","sticky","unicode","join","merged","deepClone","combine","sources","createContextManager","add","remove","newContext","getContext","setContext","setContextProperty","property","removeContextProperty","clearContext","navigationStart","buffer","callback","splice","drain","dateNow","timeStampNow","relativeNow","performance","now","clocksNow","relative","timeStamp","elapsed","start","end","getNavigationStart","timing","getEventBridge","eventBridgeGlobal","DatadogEventBridge","getAllowedWebViewHosts","parse","send","eventType","canUseEventBridge","currentHost","location","hostname","bridge","some","allowedHost","getCookieOverride","setCookieOverride","getCurrentSiteCache","enabledExperimentalFeatures","isURLSupported","setCookieHandling","getCookie","setCookie","name","expireDelay","date","setTime","expires","toUTCString","sameSite","crossSite","domain","secure","document","cookie","rawString","matches","exec","findCommaSeparatedValue","deleteCookie","getExperimentalFeatures","normalizeUrl","url","buildUrl","element","origin","sanitizedHost","host","protocol","href","base","URL","checkURLSupported","test","Error","doc","anchorElement","createElement","baseElement","implementation","createHTMLDocument","head","appendChild","body","INTAKE_SITE_US1","ENDPOINTS","logs","rum","sessionReplay","INTAKE_TRACKS","createEndpointBuilder","initConfiguration","endpointType","tags","site","clientToken","domainParts","split","extension","pop","baseUrl","proxyUrl","build","encodeURIComponent","concat","endpointUrl","buildIntakeUrl","FORBIDDEN_CHARACTERS","buildTag","rawValue","valueSizeLimit","sanitizedValue","computeTransportConfiguration","configuration","env","service","version","datacenter","buildTags","endpointBuilders","logsEndpointBuilder","rumEndpointBuilder","sessionReplayEndpointBuilder","computeEndpointBuilders","intakeEndpoints","builder","replicaConfiguration","replica","replicaEndpointBuilders","applicationId","computeReplicaConfiguration","isIntakeUrl","intakeEndpoint","validateAndBuildConfiguration","sampleRate","telemetrySampleRate","telemetryConfigurationSampleRate","enabledFeatures","enableExperimentalFeatures","filter","flag","beforeSend","cookieOptions","buildCookieOptions","silentMultipleInit","batchBytesLimit","eventRateLimiterThreshold","maxTelemetryEventsPerPage","flushTimeout","batchMessagesLimit","messageBytesLimit","useSecureSessionCookie","useCrossSiteSessionCookie","mustUseSecureCookie","trackSessionAcrossSubdomains","testCookieName","domainLevels","candidateDomain","getCurrentSite","UNKNOWN_FUNCTION","computeStackTrace","ex","stack","stackProperty","tryToGetString","exString","String","line","stackFrame","parts","CHROME_LINE_RE","isNative","isEval","submatch","CHROME_EVAL_RE","column","func","parseChromeLine","CHROME_ANONYMOUS_FUNCTION_RE","parseChromeAnonymousLine","WINJS_LINE_RE","parseWinLine","GECKO_LINE_RE","GECKO_EVAL_RE","parseGeckoLine","message","fileUrl","filePosition","ErrorSource","toStackTraceString","result","formatErrorMessage","frame","createHandlingStack","formattedStack","stackTrace","flattenErrorCauses","parentSource","currentError","causes","cause","onFirstSubscribe","observers","subscribe","f","onLastUnsubscribe","unsubscribe","other","notify","data","observer","mergeObservables","globalObservable","Observable","subscriptions","observables","observable","subscription","RawReportType","intervention","deprecation","cspViolation","initReportObservable","apis","handleCspViolation","blockedURI","effectiveDirective","subtype","buildStack","originalPolicy","sourceFile","lineNumber","columnNumber","buildRawReportFromCspViolation","reportTypes","ReportingObserver","handleReports","reports","report","id","buildRawReportFromReport","types","buffered","observe","disconnect","createReportObservable","validateAndBuildForwardOption","option","allowedValues","label","every","StatusType","HandlerType","STATUSES","handleLogStrategy","handlerType","level","loggerContext","contextManager","logger","messageContext","status","errorOrigin","addContext","removeContext","setHandler","handler","getHandler","setLevel","getLevel","willSyntheticsInjectRum","Boolean","_DATADOG_SYNTHETICS_INJECTS_RUM","getSyntheticsResultId","_DATADOG_SYNTHETICS_RESULT_ID","onRawTelemetryEventCollected","TelemetryType","ALLOWED_FRAME_URLS","TELEMETRY_EXCLUDED_SITES","telemetryConfiguration","maxEventsPerPage","sentEventCount","telemetryEnabled","telemetryConfigurationEnabled","startTelemetry","telemetryService","contextProvider","_dd","format_version","telemetry","experimental_features","toTelemetryEvent","addTelemetryError","setContextProvider","provider","addTelemetry","kind","scrubCustomerFrames","formatError","allowedFrameUrl","HAS_MULTI_BYTES_CHARACTERS","request","beforeUnloadCallback","pushOnlyBuffer","upsertBuffer","bufferBytesCount","bufferMessagesCount","setupFlushOnExit","flushPeriodically","addOrUpdate","upsert","flush","sendFn","messages","bytesCount","flushOnExit","sendOnExit","computeBytesCount","TextEncoder","encode","Blob","size","process","processedMessage","messageBytesCount","hasMessageFor","willReachedBytesLimitWith","isFull","removedMessage","navigator","sendBeacon","visibilityState","MAX_QUEUE_BYTES_COUNT","sendWithRetryStrategy","payload","state","sendStrategy","reportError","transportStatus","queuedPayloads","bandwidthMonitor","canHandle","onSuccess","retryQueuedPayloads","onFailure","enqueue","scheduleRetry","first","dequeue","currentBackoffTime","min","response","shouldRetryRequest","ongoingRequestCount","reason","queueFullReported","startClocks","previousQueue","newPayloadQueue","queue","shift","createHttpRequest","endpointBuilder","bytesLimit","retryState","ongoingByteCount","sendStrategyForRetry","onResponse","Request","isKeepAliveSupported","fetch","method","keepalive","then","sendXHR","fetchKeepAliveStrategy","hasReportedBeaconError","reportBeaconError","sendBeaconStrategy","XMLHttpRequest","onLoadEnd","open","startBatchWithReplica","endpoint","replicaEndpoint","replicaBatch","primaryBatch","createBatch","Batch","replicated","END_OF_TIMES","Infinity","entries","clearOldContextsInterval","setInterval","clearOldContexts","startTime","entry","endTime","index","close","unshift","find","closeActive","latestEntry","findAll","reset","clearInterval","oldTimeThreshold","ongoingOperations","SESSION_TIME_OUT_DELAY","SESSION_EXPIRATION_DELAY","SESSION_ENTRY_REGEXP","SESSION_ENTRY_SEPARATOR","SESSION_COOKIE_NAME","bufferedOperations","withCookieLockAccess","operations","numberOfRetries","next","currentLock","currentSession","retrieveSession","isCookieLockEnabled","lock","retryLater","setSession","processedSession","persistSession","isExpiredState","after","chrome","userAgent","currentNumberOfRetries","nextOperations","session","clearSession","expire","toSessionString","sessionString","isValidSessionString","startSessionStore","productKey","computeSessionState","renewObservable","expireObservable","watchSessionTimeoutId","cookieSession","isActiveSession","synchronizeSession","sessionCache","retrieveActiveSession","hasSessionInCache","isSessionInCacheOutdated","created","Number","expandOrRenewSession","isTracked","synchronizedSession","trackingType","expandOrRenewCookie","renewSession","expandSession","getSession","stopCallbacks","startSessionManager","oldSessionId","oldRumType","oldLogsType","tryOldCookiesMigration","sessionStore","sessionContextHistory","ContextHistory","buildSessionContext","clocksOrigin","expandSessionWhenVisible","visibilityCheckInterval","trackVisibility","findActiveSession","startLogsSessionManager","sessionManager","rawTrackingType","rawSessionType","hasValidLoggerSession","computeTrackingType","findTrackedSession","STATUS_PRIORITIES","isAuthorized","loggerHandler","sanitizedHandlerType","startLogsAssembly","lifeCycle","getCommonContext","mainLogger","statusWithCustom","logRateLimiters","limit","onLimitReached","eventCount","allowNextEvent","isLimitReached","rawLogsEvent","savedCommonContext","commonContext","session_id","view","getRUMInternalContext","logsSentBeforeRumInjectionTelemetryAdded","browserWindow","getInternalContextFromRumGlobal","DD_RUM_SYNTHETICS","addTelemetryDebug","testId","_DATADOG_SYNTHETICS_PUBLIC_ID","resultId","DD_RUM","rumGlobal","getInternalContext","consoleObservablesByApi","initConsoleObservable","consoleObservables","originalConsoleApi","params","handlingStack","buildConsoleLog","createConsoleObservable","param","formatConsoleParameters","firstErrorParam","predicate","LogStatusForApi","xhrObservable","LogStatusForReport","instrumentMethod","instrumentationFactory","original","instrumentation","instrumentationWrapper","instrumentMethodAndCallOriginal","before","fetchObservable","xhrContexts","initXhrObservable","stopInstrumentingStart","openXhr","stopInstrumentingSend","sendXhr","stopInstrumentingAbort","abortXhr","startContext","isAborted","xhr","hasBeenReported","stopInstrumentingOnReadyStateChange","readyState","DONE","onEnd","completeContext","duration","initFetchObservable","originalFetch","input","init","responsePromise","afterSend","reportFetch","DOMException","code","ABORT_ERR","responseType","startNetworkErrorCollection","forwardErrorsToLogs","xhrSubscription","handleCompleteRequest","fetchSubscription","onResponseDataAvailable","responseData","format","http","status_code","isRejected","isServerError","truncateResponseText","computeXhrResponseData","TextDecoder","stream","reader","getReader","chunks","readBytesCount","readMore","read","done","onDone","completeBuffer","catch","Uint8Array","chunk","readLimitedAmountOfBytes","bytes","limitExceeded","responseText","decode","truncateResponseStream","clone","requestErrorResponseLengthLimit","text","computeFetchResponseText","computeFetchErrorText","substring","ERROR_TYPES_RE","startUnhandledErrorCollection","stopInstrumentingOnError","lineNo","columnNo","errorObj","msg","groups","instrumentOnError","stopInstrumentingOnUnhandledRejection","instrumentUnhandledRejection","trackRuntimeError","errorObservable","originalError","nonErrorPrefix","handling","computeRawError","callbacks","eventCallbacks","existingGlobalVariable","datadogLogs","startLogsImpl","stub","publicApi","isAlreadyInitialized","globalContextManager","customLoggers","getInternalContextStrategy","beforeInitLoggerLog","BoundedBuffer","logsMessage","getInitConfigurationStrategy","Logger","referrer","overrideInitConfigurationForBridge","canInitLogs","baseConfiguration","forwardConsoleLogs","forwardReports","validateAndBuildLogsConfiguration","getLoggerGlobalContext","getGlobalContext","setLoggerGlobalContext","setGlobalContext","addLoggerGlobalContext","setGlobalContextProperty","removeLoggerGlobalContext","removeGlobalContextProperty","clearGlobalContext","createLogger","conf","getLogger","getInitConfiguration","onReady","enumerable","makeLogsPublicApi","LifeCycle","isTelemetryReplicationAllowed","startLogsTelemetry","application","application_id","action","user_action","rawErrorObservable","stopRuntimeErrorTracking","rawErrorSubscription","rawError","startRuntimeErrorCollection","consoleSubscription","startConsoleCollection","reportSubscription","getFileFromStackTraceString","startReportCollection","handleLog","savedDate","startLoggerCollection","testCookieValue","isCookieCorrectlySet","areCookiesAuthorized","startLogsSessionManagerStub","serverLogsEvent","startLogsBridge","batch","startLogsBatch","addTelemetryConfiguration","baseSerializedInitConfiguration","session_sample_rate","telemetry_sample_rate","telemetry_configuration_sample_rate","use_before_send","use_cross_site_session_cookie","use_secure_session_cookie","use_proxy","silent_multiple_init","track_session_across_subdomains","serializeConfiguration","forward_errors_to_logs","forward_console_logs","forward_reports","serializeLogsConfiguration","trackedSession","q"],"mappings":"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","file":"datadog-logs.js","sourcesContent":["/* eslint-disable no-console, local-rules/disallow-side-effects */\n/**\n * Keep references on console methods to avoid triggering patched behaviors\n *\n * NB: in some setup, console could already be patched by another SDK.\n * In this case, some display messages can be sent by the other SDK\n * but we should be safe from infinite loop nonetheless.\n */\n\nexport const ConsoleApiName = {\n  log: 'log',\n  debug: 'debug',\n  info: 'info',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nexport type ConsoleApiName = typeof ConsoleApiName[keyof typeof ConsoleApiName]\n\ninterface Display {\n  (api: ConsoleApiName, ...args: any[]): void\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n}\n\nexport const display: Display = (api, ...args) => {\n  if (!Object.prototype.hasOwnProperty.call(ConsoleApiName, api)) {\n    api = ConsoleApiName.log\n  }\n  display[api](...args)\n}\n\ndisplay.debug = console.debug.bind(console)\ndisplay.log = console.log.bind(console)\ndisplay.info = console.info.bind(console)\ndisplay.warn = console.warn.bind(console)\ndisplay.error = console.error.bind(console)\n","import { display } from './display'\n\nexport function catchUserErrors<Args extends any[], R>(fn: (...args: Args) => R, errorMsg: string) {\n  return (...args: Args) => {\n    try {\n      return fn(...args)\n    } catch (err) {\n      display.error(errorMsg, err)\n    }\n  }\n}\n","import { ConsoleApiName, display } from './display'\n\nlet onMonitorErrorCollected: undefined | ((error: unknown) => void)\nlet debugMode = false\n\nexport function startMonitorErrorCollection(newOnMonitorErrorCollected: (error: unknown) => void) {\n  onMonitorErrorCollected = newOnMonitorErrorCollected\n}\n\nexport function setDebugMode(newDebugMode: boolean) {\n  debugMode = newDebugMode\n}\n\nexport function resetMonitor() {\n  onMonitorErrorCollected = undefined\n  debugMode = false\n}\n\nexport function monitored<T extends (...params: any[]) => unknown>(\n  _: any,\n  __: string,\n  descriptor: TypedPropertyDescriptor<T>\n) {\n  const originalMethod = descriptor.value!\n  descriptor.value = function (this: any, ...args: Parameters<T>) {\n    const decorated = onMonitorErrorCollected ? monitor(originalMethod) : originalMethod\n    return decorated.apply(this, args) as ReturnType<T>\n  } as T\n}\n\nexport function monitor<T extends (...args: any[]) => any>(fn: T): T {\n  return function (this: any) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return callMonitored(fn, this, arguments as unknown as Parameters<T>)\n  } as unknown as T // consider output type has input type\n}\n\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context: ThisParameterType<T>,\n  args: Parameters<T>\n): ReturnType<T> | undefined\nexport function callMonitored<T extends (this: void) => any>(fn: T): ReturnType<T> | undefined\nexport function callMonitored<T extends (...args: any[]) => any>(\n  fn: T,\n  context?: any,\n  args?: any\n): ReturnType<T> | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return fn.apply(context, args)\n  } catch (e) {\n    displayIfDebugEnabled(ConsoleApiName.error, e)\n    if (onMonitorErrorCollected) {\n      try {\n        onMonitorErrorCollected(e)\n      } catch (e) {\n        displayIfDebugEnabled(ConsoleApiName.error, e)\n      }\n    }\n  }\n}\n\nexport function displayIfDebugEnabled(api: ConsoleApiName, ...args: any[]) {\n  if (debugMode) {\n    display(api, '[MONITOR]', ...args)\n  }\n}\n","import { display } from './display'\nimport { monitor } from './monitor'\n\nexport const ONE_SECOND = 1000\nexport const ONE_MINUTE = 60 * ONE_SECOND\nexport const ONE_HOUR = 60 * ONE_MINUTE\nexport const ONE_DAY = 24 * ONE_HOUR\nexport const ONE_YEAR = 365 * ONE_DAY\nexport const ONE_KIBI_BYTE = 1024\nexport const ONE_MEBI_BYTE = 1024 * ONE_KIBI_BYTE\n\nexport const enum DOM_EVENT {\n  BEFORE_UNLOAD = 'beforeunload',\n  CLICK = 'click',\n  DBL_CLICK = 'dblclick',\n  KEY_DOWN = 'keydown',\n  LOAD = 'load',\n  POP_STATE = 'popstate',\n  SCROLL = 'scroll',\n  TOUCH_START = 'touchstart',\n  TOUCH_END = 'touchend',\n  TOUCH_MOVE = 'touchmove',\n  VISIBILITY_CHANGE = 'visibilitychange',\n  DOM_CONTENT_LOADED = 'DOMContentLoaded',\n  POINTER_DOWN = 'pointerdown',\n  POINTER_UP = 'pointerup',\n  POINTER_CANCEL = 'pointercancel',\n  HASH_CHANGE = 'hashchange',\n  PAGE_HIDE = 'pagehide',\n  MOUSE_DOWN = 'mousedown',\n  MOUSE_UP = 'mouseup',\n  MOUSE_MOVE = 'mousemove',\n  FOCUS = 'focus',\n  BLUR = 'blur',\n  CONTEXT_MENU = 'contextmenu',\n  RESIZE = 'resize',\n  CHANGE = 'change',\n  INPUT = 'input',\n  PLAY = 'play',\n  PAUSE = 'pause',\n  SECURITY_POLICY_VIOLATION = 'securitypolicyviolation',\n  SELECTION_CHANGE = 'selectionchange',\n}\n\nexport const enum ResourceType {\n  DOCUMENT = 'document',\n  XHR = 'xhr',\n  BEACON = 'beacon',\n  FETCH = 'fetch',\n  CSS = 'css',\n  JS = 'js',\n  IMAGE = 'image',\n  FONT = 'font',\n  MEDIA = 'media',\n  OTHER = 'other',\n}\n\nexport const enum RequestType {\n  FETCH = ResourceType.FETCH,\n  XHR = ResourceType.XHR,\n}\n\n// use lodash API\nexport function throttle<T extends (...args: any[]) => void>(\n  fn: T,\n  wait: number,\n  options?: { leading?: boolean; trailing?: boolean }\n) {\n  const needLeadingExecution = options && options.leading !== undefined ? options.leading : true\n  const needTrailingExecution = options && options.trailing !== undefined ? options.trailing : true\n  let inWaitPeriod = false\n  let pendingExecutionWithParameters: Parameters<T> | undefined\n  let pendingTimeoutId: TimeoutId\n\n  return {\n    throttled: (...parameters: Parameters<T>) => {\n      if (inWaitPeriod) {\n        pendingExecutionWithParameters = parameters\n        return\n      }\n      if (needLeadingExecution) {\n        fn(...parameters)\n      } else {\n        pendingExecutionWithParameters = parameters\n      }\n      inWaitPeriod = true\n      pendingTimeoutId = setTimeout(() => {\n        if (needTrailingExecution && pendingExecutionWithParameters) {\n          fn(...pendingExecutionWithParameters)\n        }\n        inWaitPeriod = false\n        pendingExecutionWithParameters = undefined\n      }, wait)\n    },\n    cancel: () => {\n      clearTimeout(pendingTimeoutId)\n      inWaitPeriod = false\n      pendingExecutionWithParameters = undefined\n    },\n  }\n}\n\ninterface Assignable {\n  [key: string]: any\n}\n\nexport function assign<T, U>(target: T, source: U): T & U\nexport function assign<T, U, V>(target: T, source1: U, source2: V): T & U & V\nexport function assign<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W\nexport function assign(target: Assignable, ...toAssign: Assignable[]) {\n  toAssign.forEach((source: Assignable) => {\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key]\n      }\n    }\n  })\n  return target\n}\n\nexport function shallowClone<T>(object: T): T & Record<string, never> {\n  return assign({}, object)\n}\n\n/**\n * UUID v4\n * from https://gist.github.com/jed/982883\n */\nexport function generateUUID(placeholder?: string): string {\n  return placeholder\n    ? // eslint-disable-next-line  no-bitwise\n      (parseInt(placeholder, 10) ^ ((Math.random() * 16) >> (parseInt(placeholder, 10) / 4))).toString(16)\n    : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, generateUUID)\n}\n\n/**\n * Return true if the draw is successful\n * @param threshold between 0 and 100\n */\nexport function performDraw(threshold: number): boolean {\n  return threshold !== 0 && Math.random() * 100 <= threshold\n}\n\nexport function round(num: number, decimals: 0 | 1 | 2 | 3 | 4) {\n  return +num.toFixed(decimals)\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop() {}\n\n/**\n * Custom implementation of JSON.stringify that ignores some toJSON methods. We need to do that\n * because some sites badly override toJSON on certain objects. Removing all toJSON methods from\n * nested values would be too costly, so we just detach them from the root value, and native classes\n * used to build JSON values (Array and Object).\n *\n * Note: this still assumes that JSON.stringify is correct.\n */\nexport function jsonStringify(value: unknown, space?: string | number): string | undefined {\n  if (typeof value !== 'object' || value === null) {\n    return JSON.stringify(value)\n  }\n\n  // Note: The order matters here. We need to detach toJSON methods on parent classes before their\n  // subclasses.\n  const restoreObjectPrototypeToJson = detachToJsonMethod(Object.prototype)\n  const restoreArrayPrototypeToJson = detachToJsonMethod(Array.prototype)\n  const restoreValuePrototypeToJson = detachToJsonMethod(Object.getPrototypeOf(value))\n  const restoreValueToJson = detachToJsonMethod(value)\n\n  try {\n    return JSON.stringify(value, getCyclicReplacer(), space)\n  } catch {\n    return '<error: unable to serialize object>'\n  } finally {\n    restoreObjectPrototypeToJson()\n    restoreArrayPrototypeToJson()\n    restoreValuePrototypeToJson()\n    restoreValueToJson()\n  }\n}\n\ninterface ObjectWithToJsonMethod {\n  toJSON: unknown\n}\nfunction detachToJsonMethod(value: object) {\n  const object = value as ObjectWithToJsonMethod\n  const objectToJson = object.toJSON\n  if (objectToJson) {\n    delete object.toJSON\n    return () => {\n      object.toJSON = objectToJson\n    }\n  }\n  return noop\n}\n\nexport function includes(candidate: string, search: string): boolean\nexport function includes<T>(candidate: T[], search: T): boolean\nexport function includes(candidate: string | unknown[], search: any) {\n  return candidate.indexOf(search) !== -1\n}\n\nexport function arrayFrom<T>(arrayLike: ArrayLike<T> | Set<T>): T[] {\n  if (Array.from) {\n    return Array.from(arrayLike)\n  }\n\n  const array = []\n\n  if (arrayLike instanceof Set) {\n    arrayLike.forEach((item) => array.push(item))\n  } else {\n    for (let i = 0; i < arrayLike.length; i++) {\n      array.push(arrayLike[i])\n    }\n  }\n\n  return array\n}\n\nexport function find<T, S extends T>(\n  array: ArrayLike<T>,\n  predicate: (item: T, index: number) => item is S\n): S | undefined\nexport function find<T>(array: ArrayLike<T>, predicate: (item: T, index: number) => boolean): T | undefined\nexport function find(\n  array: ArrayLike<unknown>,\n  predicate: (item: unknown, index: number) => boolean\n): unknown | undefined {\n  for (let i = 0; i < array.length; i += 1) {\n    const item = array[i]\n    if (predicate(item, i)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function findLast<T, S extends T>(\n  array: T[],\n  predicate: (item: T, index: number, array: T[]) => item is S\n): S | undefined {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    const item = array[i]\n    if (predicate(item, i, array)) {\n      return item\n    }\n  }\n  return undefined\n}\n\nexport function isPercentage(value: unknown) {\n  return isNumber(value) && value >= 0 && value <= 100\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n\nexport function objectValues<T = unknown>(object: { [key: string]: T }) {\n  return Object.keys(object).map((key) => object[key])\n}\n\nexport function objectHasValue<T extends { [key: string]: unknown }>(object: T, value: unknown): value is T[keyof T] {\n  return Object.keys(object).some((key) => object[key] === value)\n}\n\nexport function objectEntries(object: { [key: string]: unknown }): Array<[string, unknown]> {\n  return Object.keys(object).map((key) => [key, object[key]])\n}\n\nexport function isEmptyObject(object: object) {\n  return Object.keys(object).length === 0\n}\n\nexport function mapValues<A, B>(object: { [key: string]: A }, fn: (arg: A) => B) {\n  const newObject: { [key: string]: B } = {}\n  for (const key of Object.keys(object)) {\n    newObject[key] = fn(object[key])\n  }\n  return newObject\n}\n\nexport function startsWith(candidate: string, search: string) {\n  return candidate.slice(0, search.length) === search\n}\n\nexport function endsWith(candidate: string, search: string) {\n  return candidate.slice(-search.length) === search\n}\n\n/**\n * inspired by https://mathiasbynens.be/notes/globalthis\n */\nexport function getGlobalObject<T>(): T {\n  if (typeof globalThis === 'object') {\n    return globalThis as unknown as T\n  }\n  Object.defineProperty(Object.prototype, '_dd_temp_', {\n    get() {\n      return this as object\n    },\n    configurable: true,\n  })\n  // @ts-ignore _dd_temp is defined using defineProperty\n  let globalObject: unknown = _dd_temp_\n  // @ts-ignore _dd_temp is defined using defineProperty\n  delete Object.prototype._dd_temp_\n  if (typeof globalObject !== 'object') {\n    // on safari _dd_temp_ is available on window but not globally\n    // fallback on other browser globals check\n    if (typeof self === 'object') {\n      globalObject = self\n    } else if (typeof window === 'object') {\n      globalObject = window\n    } else {\n      globalObject = {}\n    }\n  }\n  return globalObject as T\n}\n\nexport function getLocationOrigin() {\n  return getLinkElementOrigin(window.location)\n}\n\n/**\n * IE fallback\n * https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/origin\n */\nexport function getLinkElementOrigin(element: Location | HTMLAnchorElement | URL) {\n  if (element.origin) {\n    return element.origin\n  }\n  const sanitizedHost = element.host.replace(/(:80|:443)$/, '')\n  return `${element.protocol}//${sanitizedHost}`\n}\n\nexport function findCommaSeparatedValue(rawString: string, name: string) {\n  const regex = new RegExp(`(?:^|;)\\\\s*${name}\\\\s*=\\\\s*([^;]+)`)\n  const matches = regex.exec(rawString)\n  return matches ? matches[1] : undefined\n}\n\nexport function safeTruncate(candidate: string, length: number, suffix = '') {\n  const lastChar = candidate.charCodeAt(length - 1)\n  const isLastCharSurrogatePair = lastChar >= 0xd800 && lastChar <= 0xdbff\n  const correctedLength = isLastCharSurrogatePair ? length + 1 : length\n\n  if (candidate.length <= correctedLength) return candidate\n\n  return `${candidate.slice(0, correctedLength)}${suffix}`\n}\n\nexport interface EventEmitter {\n  addEventListener(\n    event: DOM_EVENT,\n    listener: (event: Event) => void,\n    options?: boolean | { capture?: boolean; passive?: boolean }\n  ): void\n  removeEventListener(\n    event: DOM_EVENT,\n    listener: (event: Event) => void,\n    options?: boolean | { capture?: boolean; passive?: boolean }\n  ): void\n}\n\ninterface AddEventListenerOptions {\n  once?: boolean\n  capture?: boolean\n  passive?: boolean\n}\n\n/**\n * Add an event listener to an event emitter object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n */\nexport function addEventListener<E extends Event>(\n  emitter: EventEmitter,\n  event: DOM_EVENT,\n  listener: (event: E) => void,\n  options?: AddEventListenerOptions\n) {\n  return addEventListeners(emitter, [event], listener, options)\n}\n\n/**\n * Add event listeners to an event emitter object (Window, Element, mock object...).  This provides\n * a few conveniences compared to using `element.addEventListener` directly:\n *\n * * supports IE11 by: using an option object only if needed and emulating the `once` option\n *\n * * wraps the listener with a `monitor` function\n *\n * * returns a `stop` function to remove the listener\n *\n * * with `once: true`, the listener will be called at most once, even if different events are listened\n */\nexport function addEventListeners<E extends Event>(\n  emitter: EventEmitter,\n  events: DOM_EVENT[],\n  listener: (event: E) => void,\n  { once, capture, passive }: { once?: boolean; capture?: boolean; passive?: boolean } = {}\n) {\n  const wrappedListener = monitor(\n    once\n      ? (event: Event) => {\n          stop()\n          listener(event as E)\n        }\n      : (listener as (event: Event) => void)\n  )\n\n  const options = passive ? { capture, passive } : capture\n  events.forEach((event) => emitter.addEventListener(event, wrappedListener, options))\n  const stop = () => events.forEach((event) => emitter.removeEventListener(event, wrappedListener, options))\n\n  return {\n    stop,\n  }\n}\n\nexport function elementMatches(element: Element & { msMatchesSelector?(selector: string): boolean }, selector: string) {\n  if (element.matches) {\n    return element.matches(selector)\n  }\n  // IE11 support\n  if (element.msMatchesSelector) {\n    return element.msMatchesSelector(selector)\n  }\n  return false\n}\n\nexport function runOnReadyState(expectedReadyState: 'complete' | 'interactive', callback: () => void) {\n  if (document.readyState === expectedReadyState || document.readyState === 'complete') {\n    callback()\n  } else {\n    const eventName = expectedReadyState === 'complete' ? DOM_EVENT.LOAD : DOM_EVENT.DOM_CONTENT_LOADED\n    addEventListener(window, eventName, callback, { once: true })\n  }\n}\n\n/**\n * Similar to `typeof`, but distinguish plain objects from `null` and arrays\n */\nexport function getType(value: unknown) {\n  if (value === null) {\n    return 'null'\n  }\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  return typeof value\n}\n\ntype Merged<TDestination, TSource> =\n  // case 1 - source is undefined - return destination\n  TSource extends undefined\n    ? TDestination\n    : // case 2 - destination is undefined - return source\n    TDestination extends undefined\n    ? TSource\n    : // case 3 - source is an array - see if it merges or overwrites\n    TSource extends any[]\n    ? TDestination extends any[]\n      ? TDestination & TSource\n      : TSource\n    : // case 4 - source is an object - see if it merges or overwrites\n    TSource extends object\n    ? TDestination extends object\n      ? TDestination extends any[]\n        ? TSource\n        : TDestination & TSource\n      : TSource\n    : // case 5 - cannot merge - return source\n      TSource\n\ninterface CircularReferenceChecker {\n  hasAlreadyBeenSeen(value: any): boolean\n}\nfunction createCircularReferenceChecker(): CircularReferenceChecker {\n  // Using a weakmap instead of a weakset to support IE11\n  const map: WeakMap<any, boolean> = new WeakMap()\n  return {\n    hasAlreadyBeenSeen(value) {\n      const has = map.has(value)\n      if (!has) {\n        map.set(value, true)\n      }\n      return has\n    },\n  }\n}\n\n/**\n * Returns a replacer function that can be used with JSON.stringify\n * to remove cyclic references.\n */\nfunction getCyclicReplacer(): (key: string, value: unknown) => unknown {\n  const circularReferenceChecker = createCircularReferenceChecker()\n  return (_key: string, value: unknown) => {\n    const type = getType(value)\n    if ((type === 'object' || type === 'array') && circularReferenceChecker.hasAlreadyBeenSeen(value)) {\n      return '<warning: cyclic reference not serialized>'\n    }\n    return value\n  }\n}\n\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto<D, S>(\n  destination: D,\n  source: S,\n  circularReferenceChecker = createCircularReferenceChecker()\n): Merged<D, S> {\n  // ignore the source if it is undefined\n  if (source === undefined) {\n    return destination as Merged<D, S>\n  }\n\n  if (typeof source !== 'object' || source === null) {\n    // primitive values - just return source\n    return source as Merged<D, S>\n  } else if (source instanceof Date) {\n    return new Date(source.getTime()) as unknown as Merged<D, S>\n  } else if (source instanceof RegExp) {\n    const flags =\n      source.flags ||\n      // old browsers compatibility\n      [\n        source.global ? 'g' : '',\n        source.ignoreCase ? 'i' : '',\n        source.multiline ? 'm' : '',\n        source.sticky ? 'y' : '',\n        source.unicode ? 'u' : '',\n      ].join('')\n    return new RegExp(source.source, flags) as unknown as Merged<D, S>\n  }\n\n  if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n    // remove circular references\n    return undefined as unknown as Merged<D, S>\n  } else if (Array.isArray(source)) {\n    const merged: any[] = Array.isArray(destination) ? destination : []\n    for (let i = 0; i < source.length; ++i) {\n      merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker)\n    }\n    return merged as unknown as Merged<D, S>\n  }\n\n  const merged: Record<any, any> = getType(destination) === 'object' ? destination : {}\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker)\n    }\n  }\n  return merged as unknown as Merged<D, S>\n}\n\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone<T>(value: T): T {\n  return mergeInto(undefined, value) as T\n}\n\ntype Combined<A, B> = A extends null ? B : B extends null ? A : Merged<A, B>\n\n/*\n * Performs a deep merge of objects and arrays.\n * - Arguments won't be mutated\n * - Object and arrays in the output value are dereferenced (\"deep cloned\")\n * - Arrays values are merged index by index\n * - Objects are merged by keys\n * - Values get replaced, unless undefined\n */\nexport function combine<A, B>(a: A, b: B): Combined<A, B>\nexport function combine<A, B, C>(a: A, b: B, c: C): Combined<Combined<A, B>, C>\nexport function combine<A, B, C, D>(a: A, b: B, c: C, d: D): Combined<Combined<Combined<A, B>, C>, D>\nexport function combine<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E\n): Combined<Combined<Combined<Combined<A, B>, C>, D>, E>\nexport function combine<A, B, C, D, E, F>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F\n): Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>\nexport function combine<A, B, C, D, E, F, G>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G\n): Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>\nexport function combine<A, B, C, D, E, F, G, H>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n  f: F,\n  g: G,\n  h: H\n): Combined<Combined<Combined<Combined<Combined<Combined<Combined<A, B>, C>, D>, E>, F>, G>, H>\nexport function combine(...sources: any[]): unknown {\n  let destination: any\n\n  for (const source of sources) {\n    // Ignore any undefined or null sources.\n    if (source === undefined || source === null) {\n      continue\n    }\n\n    destination = mergeInto(destination, source)\n  }\n\n  return destination as unknown\n}\n\nexport type TimeoutId = ReturnType<typeof setTimeout>\n\nexport function requestIdleCallback(callback: () => void, opts?: { timeout?: number }) {\n  // Use 'requestIdleCallback' when available: it will throttle the mutation processing if the\n  // browser is busy rendering frames (ex: when frames are below 60fps). When not available, the\n  // fallback on 'requestAnimationFrame' will still ensure the mutations are processed after any\n  // browser rendering process (Layout, Recalculate Style, etc.), so we can serialize DOM nodes\n  // efficiently.\n  if (window.requestIdleCallback) {\n    const id = window.requestIdleCallback(monitor(callback), opts)\n    return () => window.cancelIdleCallback(id)\n  }\n  const id = window.requestAnimationFrame(monitor(callback))\n  return () => window.cancelAnimationFrame(id)\n}\n\nexport function removeDuplicates<T>(array: T[]) {\n  const set = new Set<T>()\n  array.forEach((item) => set.add(item))\n  return arrayFrom(set)\n}\n\nexport type MatchOption = string | RegExp | ((value: string) => boolean)\nexport function matchList(list: MatchOption[], value: string): boolean {\n  return list.some((item) => {\n    if (typeof item === 'function') {\n      try {\n        return item(value)\n      } catch (e) {\n        display.error(e)\n        return false\n      }\n    }\n    if (item instanceof RegExp) {\n      return item.test(value)\n    }\n    return item === value\n  })\n}\n\n// https://github.com/jquery/jquery/blob/a684e6ba836f7c553968d7d026ed7941e1a612d8/src/selector/escapeSelector.js\nexport function cssEscape(str: string) {\n  if (window.CSS && window.CSS.escape) {\n    return window.CSS.escape(str)\n  }\n\n  // eslint-disable-next-line no-control-regex\n  return str.replace(/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\x80-\\uFFFF\\w-]/g, function (ch, asCodePoint) {\n    if (asCodePoint) {\n      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n      if (ch === '\\0') {\n        return '\\uFFFD'\n      }\n      // Control characters and (dependent upon position) numbers get escaped as code points\n      return `${ch.slice(0, -1)}\\\\${ch.charCodeAt(ch.length - 1).toString(16)} `\n    }\n    // Other potentially-special ASCII characters get backslash-escaped\n    return `\\\\${ch}`\n  })\n}\n","import { deepClone } from './utils'\n\nimport type { Context, ContextValue } from './context'\n\nexport function createContextManager() {\n  let context: Context = {}\n\n  return {\n    /** @deprecated use getContext instead */\n    get: () => context,\n\n    /** @deprecated use setContextProperty instead */\n    add: (key: string, value: any) => {\n      context[key] = value as ContextValue\n    },\n\n    /** @deprecated renamed to removeContextProperty */\n    remove: (key: string) => {\n      delete context[key]\n    },\n\n    /** @deprecated use setContext instead */\n    set: (newContext: object) => {\n      context = newContext as Context\n    },\n\n    getContext: () => deepClone(context),\n\n    setContext: (newContext: Context) => {\n      context = deepClone(newContext)\n    },\n\n    setContextProperty: (key: string, property: any) => {\n      context[key] = deepClone(property)\n    },\n\n    removeContextProperty: (key: string) => {\n      delete context[key]\n    },\n\n    clearContext: () => {\n      context = {}\n    },\n  }\n}\n","const BUFFER_LIMIT = 500\n\nexport class BoundedBuffer {\n  private buffer: Array<() => void> = []\n\n  add(callback: () => void) {\n    const length = this.buffer.push(callback)\n    if (length > BUFFER_LIMIT) {\n      this.buffer.splice(0, 1)\n    }\n  }\n\n  drain() {\n    this.buffer.forEach((callback) => callback())\n    this.buffer.length = 0\n  }\n}\n","import { isNumber, ONE_YEAR, round } from './utils'\n\nexport type Duration = number & { d: 'Duration in ms' }\nexport type ServerDuration = number & { s: 'Duration in ns' }\nexport type TimeStamp = number & { t: 'Epoch time' }\nexport type RelativeTime = number & { r: 'Time relative to navigation start' } & { d: 'Duration in ms' }\nexport type ClocksState = { relative: RelativeTime; timeStamp: TimeStamp }\n\nexport function relativeToClocks(relative: RelativeTime) {\n  return { relative, timeStamp: getCorrectedTimeStamp(relative) }\n}\n\nfunction getCorrectedTimeStamp(relativeTime: RelativeTime) {\n  const correctedOrigin = (dateNow() - performance.now()) as TimeStamp\n  // apply correction only for positive drift\n  if (correctedOrigin > getNavigationStart()) {\n    return Math.round(addDuration(correctedOrigin, relativeTime)) as TimeStamp\n  }\n  return getTimeStamp(relativeTime)\n}\n\nexport function currentDrift() {\n  return Math.round(dateNow() - addDuration(getNavigationStart(), performance.now() as Duration))\n}\n\nexport function toServerDuration(duration: Duration): ServerDuration\nexport function toServerDuration(duration: Duration | undefined): ServerDuration | undefined\nexport function toServerDuration(duration: Duration | undefined) {\n  if (!isNumber(duration)) {\n    return duration\n  }\n  return round(duration * 1e6, 0) as ServerDuration\n}\n\nexport function dateNow() {\n  // Do not use `Date.now` because sometimes websites are wrongly \"polyfilling\" it. For example, we\n  // had some users using a very old version of `datejs`, which patched `Date.now` to return a Date\n  // instance instead of a timestamp[1]. Those users are unlikely to fix this, so let's handle this\n  // case ourselves.\n  // [1]: https://github.com/datejs/Datejs/blob/97f5c7c58c5bc5accdab8aa7602b6ac56462d778/src/core-debug.js#L14-L16\n  return new Date().getTime()\n}\n\nexport function timeStampNow() {\n  return dateNow() as TimeStamp\n}\n\nexport function relativeNow() {\n  return performance.now() as RelativeTime\n}\n\nexport function clocksNow() {\n  return { relative: relativeNow(), timeStamp: timeStampNow() }\n}\n\nexport function clocksOrigin() {\n  return { relative: 0 as RelativeTime, timeStamp: getNavigationStart() }\n}\n\nexport function elapsed(start: TimeStamp, end: TimeStamp): Duration\nexport function elapsed(start: RelativeTime, end: RelativeTime): Duration\nexport function elapsed(start: number, end: number) {\n  return (end - start) as Duration\n}\n\nexport function addDuration(a: TimeStamp, b: Duration): TimeStamp\nexport function addDuration(a: RelativeTime, b: Duration): RelativeTime\nexport function addDuration(a: Duration, b: Duration): Duration\nexport function addDuration(a: number, b: number) {\n  return a + b\n}\n\n/**\n * Get the time since the navigation was started.\n *\n * Note: this does not use `performance.timeOrigin` because it doesn't seem to reflect the actual\n * time on which the navigation has started: it may be much farther in the past, at least in Firefox 71.\n * Related issue in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1429926\n */\nexport function getRelativeTime(timestamp: TimeStamp) {\n  return (timestamp - getNavigationStart()) as RelativeTime\n}\n\nexport function getTimeStamp(relativeTime: RelativeTime) {\n  return Math.round(addDuration(getNavigationStart(), relativeTime)) as TimeStamp\n}\n\nexport function looksLikeRelativeTime(time: RelativeTime | TimeStamp): time is RelativeTime {\n  return time < ONE_YEAR\n}\n\n/**\n * Navigation start slightly change on some rare cases\n */\nlet navigationStart: TimeStamp | undefined\n\nfunction getNavigationStart() {\n  if (navigationStart === undefined) {\n    navigationStart = performance.timing.navigationStart as TimeStamp\n  }\n  return navigationStart\n}\n\nexport function resetNavigationStart() {\n  navigationStart = undefined\n}\n","import { endsWith, getGlobalObject } from '../tools/utils'\n\nexport interface BrowserWindowWithEventBridge extends Window {\n  DatadogEventBridge?: DatadogEventBridge\n}\n\nexport interface DatadogEventBridge {\n  getAllowedWebViewHosts(): string\n  send(msg: string): void\n}\n\nexport function getEventBridge<T, E>() {\n  const eventBridgeGlobal = getEventBridgeGlobal()\n\n  if (!eventBridgeGlobal) {\n    return\n  }\n\n  return {\n    getAllowedWebViewHosts() {\n      return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts()) as string[]\n    },\n    send(eventType: T, event: E) {\n      eventBridgeGlobal.send(JSON.stringify({ eventType, event }))\n    },\n  }\n}\n\nexport function canUseEventBridge(currentHost = getGlobalObject<Window>().location?.hostname): boolean {\n  const bridge = getEventBridge()\n  return (\n    !!bridge &&\n    bridge\n      .getAllowedWebViewHosts()\n      .some((allowedHost) => currentHost === allowedHost || endsWith(currentHost, `.${allowedHost}`))\n  )\n}\n\nfunction getEventBridgeGlobal() {\n  return getGlobalObject<BrowserWindowWithEventBridge>().DatadogEventBridge\n}\n","import { display } from '../tools/display'\nimport { findCommaSeparatedValue, generateUUID, ONE_SECOND } from '../tools/utils'\n\nexport const COOKIE_ACCESS_DELAY = ONE_SECOND\n\nexport type SetCookieOverride = (name: string, value: string, expireDelay: number) => void\nexport type GetCookieOverride = (name: string) => string | undefined\nexport interface CookieOptions {\n  secure?: boolean\n  crossSite?: boolean\n  domain?: string,\n  setCookie?: SetCookieOverride\n  getCookie?: GetCookieOverride\n}\n\n\nlet getCookieOverride: GetCookieOverride, setCookieOverride: SetCookieOverride\nexport function setCookieHandling(getCookie: GetCookieOverride, setCookie: SetCookieOverride): void {\n  getCookieOverride = getCookie\n  setCookieOverride = setCookie\n}\n\nexport function setCookie(name: string, value: string, expireDelay: number, options?: CookieOptions) {\n  if (setCookieOverride) {\n    setCookieOverride(name, value, expireDelay);\n    return\n  }\n  const date = new Date()\n  date.setTime(date.getTime() + expireDelay)\n  const expires = `expires=${date.toUTCString()}`\n  const sameSite = options && options.crossSite ? 'none' : 'strict'\n  const domain = options && options.domain ? `;domain=${options.domain}` : ''\n  const secure = options && options.secure ? ';secure' : ''\n  document.cookie = `${name}=${value};${expires};path=/;samesite=${sameSite}${domain}${secure}`\n}\n\nexport function getCookie(name: string): string | undefined {\n  if (getCookieOverride) {\n    return getCookieOverride(name)\n  }\n  return findCommaSeparatedValue(document.cookie, name)\n}\n\nexport function deleteCookie(name: string, options?: CookieOptions) {\n  setCookie(name, '', 0, options)\n}\n\nexport function areCookiesAuthorized(options: CookieOptions): boolean {\n  if (!!getCookieOverride && !!setCookieHandling) {\n    return true\n  }\n  if (document.cookie === undefined || document.cookie === null) {\n    return false\n  }\n  try {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_cookie_test_${generateUUID()}`\n    const testCookieValue = 'test'\n    setCookie(testCookieName, testCookieValue, ONE_SECOND, options)\n    const isCookieCorrectlySet = getCookie(testCookieName) === testCookieValue\n    deleteCookie(testCookieName, options)\n    return isCookieCorrectlySet\n  } catch (error) {\n    display.error(error)\n    return false\n  }\n}\n\n/**\n * No API to retrieve it, number of levels for subdomain and suffix are unknown\n * strategy: find the minimal domain on which cookies are allowed to be set\n * https://web.dev/same-site-same-origin/#site\n */\nlet getCurrentSiteCache: string | undefined\nexport function getCurrentSite() {\n  if (getCurrentSiteCache === undefined) {\n    // Use a unique cookie name to avoid issues when the SDK is initialized multiple times during\n    // the test cookie lifetime\n    const testCookieName = `dd_site_test_${generateUUID()}`\n    const testCookieValue = 'test'\n\n    const domainLevels = window.location.hostname.split('.')\n    let candidateDomain = domainLevels.pop()!\n    while (domainLevels.length && !getCookie(testCookieName)) {\n      candidateDomain = `${domainLevels.pop()!}.${candidateDomain}`\n      setCookie(testCookieName, testCookieValue, ONE_SECOND, { domain: candidateDomain })\n    }\n    deleteCookie(testCookieName, { domain: candidateDomain })\n    getCurrentSiteCache = candidateDomain\n  }\n  return getCurrentSiteCache\n}\n","/**\n * LIMITATION:\n * For NPM setup, this feature flag singleton is shared between RUM and Logs product.\n * This means that an experimental flag set on the RUM product will be set on the Logs product.\n * So keep in mind that in certain configurations, your experimental feature flag may affect other products.\n */\nimport { includes } from '../../tools/utils'\nimport { display } from '../../tools/display'\n\nlet enabledExperimentalFeatures: Set<string> | undefined\n\nexport function updateExperimentalFeatures(enabledFeatures: string[] | undefined): void {\n  // Safely handle external data\n  if (!Array.isArray(enabledFeatures)) {\n    return\n  }\n\n  if (!enabledExperimentalFeatures) {\n    enabledExperimentalFeatures = new Set(enabledFeatures)\n  }\n\n  enabledFeatures\n    .filter((flag) => typeof flag === 'string')\n    .forEach((flag: string) => {\n      if (includes(flag, '-')) {\n        display.warn(`please use snake case for '${flag}'`)\n      }\n      enabledExperimentalFeatures!.add(flag)\n    })\n}\n\nexport function isExperimentalFeatureEnabled(featureName: string): boolean {\n  return !!enabledExperimentalFeatures && enabledExperimentalFeatures.has(featureName)\n}\n\nexport function resetExperimentalFeatures(): void {\n  enabledExperimentalFeatures = new Set()\n}\n\nexport function getExperimentalFeatures(): Set<string> {\n  return enabledExperimentalFeatures || new Set()\n}\n","import { getLinkElementOrigin, getLocationOrigin } from './utils'\n\nexport function normalizeUrl(url: string) {\n  return buildUrl(url, getLocationOrigin()).href\n}\n\nexport function isValidUrl(url: string) {\n  try {\n    return !!buildUrl(url)\n  } catch {\n    return false\n  }\n}\n\nexport function haveSameOrigin(url1: string, url2: string) {\n  return getOrigin(url1) === getOrigin(url2)\n}\n\nexport function getOrigin(url: string) {\n  return getLinkElementOrigin(buildUrl(url))\n}\n\nexport function getPathName(url: string) {\n  const pathname = buildUrl(url).pathname\n  return pathname[0] === '/' ? pathname : `/${pathname}`\n}\n\nexport function getSearch(url: string) {\n  return buildUrl(url).search\n}\n\nexport function getHash(url: string) {\n  return buildUrl(url).hash\n}\n\nexport function buildUrl(url: string, base?: string) {\n  if (checkURLSupported()) {\n    return base !== undefined ? new URL(url, base) : new URL(url)\n  }\n  if (base === undefined && !/:/.test(url)) {\n    throw new Error(`Invalid URL: '${url}'`)\n  }\n  let doc = document\n  const anchorElement = doc.createElement('a')\n  if (base !== undefined) {\n    doc = document.implementation.createHTMLDocument('')\n    const baseElement = doc.createElement('base')\n    baseElement.href = base\n    doc.head.appendChild(baseElement)\n    doc.body.appendChild(anchorElement)\n  }\n  anchorElement.href = url\n  return anchorElement\n}\n\nlet isURLSupported: boolean | undefined\nfunction checkURLSupported() {\n  if (isURLSupported !== undefined) {\n    return isURLSupported\n  }\n  try {\n    const url = new URL('http://test/path')\n    isURLSupported = url.href === 'http://test/path'\n    return isURLSupported\n  } catch {\n    isURLSupported = false\n  }\n  return isURLSupported\n}\n","export const INTAKE_SITE_STAGING = 'datad0g.com'\nexport const INTAKE_SITE_US1 = 'datadoghq.com'\nexport const INTAKE_SITE_US1_FED = 'ddog-gov.com'\n","import { timeStampNow } from '../../tools/timeUtils'\nimport { normalizeUrl } from '../../tools/urlPolyfill'\nimport { generateUUID } from '../../tools/utils'\nimport type { InitConfiguration } from './configuration'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport const ENDPOINTS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'session-replay',\n} as const\n\nconst INTAKE_TRACKS = {\n  logs: 'logs',\n  rum: 'rum',\n  sessionReplay: 'replay',\n}\n\nexport type EndpointType = keyof typeof ENDPOINTS\n\nexport type EndpointBuilder = ReturnType<typeof createEndpointBuilder>\n\nexport function createEndpointBuilder(\n  initConfiguration: InitConfiguration,\n  endpointType: EndpointType,\n  tags: string[]\n) {\n  const { site = INTAKE_SITE_US1, clientToken } = initConfiguration\n\n  const domainParts = site.split('.')\n  const extension = domainParts.pop()\n  const host = `${ENDPOINTS[endpointType]}.browser-intake-${domainParts.join('-')}.${extension!}`\n  const baseUrl = `https://${host}/api/v2/${INTAKE_TRACKS[endpointType]}`\n  const proxyUrl = initConfiguration.proxyUrl && normalizeUrl(initConfiguration.proxyUrl)\n\n  return {\n    build() {\n      let parameters =\n        'ddsource=browser' +\n        `&ddtags=${encodeURIComponent([`sdk_version:${__BUILD_ENV__SDK_VERSION__}`].concat(tags).join(','))}` +\n        `&dd-api-key=${clientToken}` +\n        `&dd-evp-origin-version=${encodeURIComponent(__BUILD_ENV__SDK_VERSION__)}` +\n        '&dd-evp-origin=browser' +\n        `&dd-request-id=${generateUUID()}`\n\n      if (endpointType === 'rum') {\n        parameters += `&batch_time=${timeStampNow()}`\n      }\n      const endpointUrl = `${baseUrl}?${parameters}`\n\n      return proxyUrl ? `${proxyUrl}?ddforward=${encodeURIComponent(endpointUrl)}` : endpointUrl\n    },\n    buildIntakeUrl() {\n      return proxyUrl ? `${proxyUrl}?ddforward` : baseUrl\n    },\n    endpointType,\n  }\n}\n","import { display } from '../../tools/display'\nimport type { InitConfiguration } from './configuration'\n\nexport const TAG_SIZE_LIMIT = 200\n\nexport function buildTags(configuration: InitConfiguration): string[] {\n  const { env, service, version, datacenter } = configuration\n  const tags = []\n\n  if (env) {\n    tags.push(buildTag('env', env))\n  }\n  if (service) {\n    tags.push(buildTag('service', service))\n  }\n  if (version) {\n    tags.push(buildTag('version', version))\n  }\n  if (datacenter) {\n    tags.push(buildTag('datacenter', datacenter))\n  }\n\n  return tags\n}\n\nconst FORBIDDEN_CHARACTERS = /[^a-z0-9_:./-]/\n\nexport function buildTag(key: string, rawValue: string) {\n  // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n  // that the backend may not follow the exact same rules, so we only want to display an informal\n  // warning.\n  const valueSizeLimit = TAG_SIZE_LIMIT - key.length - 1\n\n  if (rawValue.length > valueSizeLimit || FORBIDDEN_CHARACTERS.test(rawValue)) {\n    display.warn(`${key} value doesn't meet tag requirements and will be sanitized`)\n  }\n\n  // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n  // by forging a value containing commas.\n  const sanitizedValue = rawValue.replace(/,/g, '_')\n\n  return `${key}:${sanitizedValue}`\n}\n","import { assign, objectValues } from '../../tools/utils'\nimport type { InitConfiguration } from './configuration'\nimport type { EndpointBuilder } from './endpointBuilder'\nimport { createEndpointBuilder } from './endpointBuilder'\nimport { buildTags } from './tags'\nimport { INTAKE_SITE_US1 } from './intakeSites'\n\nexport interface TransportConfiguration {\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n  sessionReplayEndpointBuilder: EndpointBuilder\n  isIntakeUrl: (url: string) => boolean\n  replica?: ReplicaConfiguration\n  site: string\n}\n\nexport interface ReplicaConfiguration {\n  applicationId?: string\n  logsEndpointBuilder: EndpointBuilder\n  rumEndpointBuilder: EndpointBuilder\n}\n\nexport function computeTransportConfiguration(initConfiguration: InitConfiguration): TransportConfiguration {\n  const tags = buildTags(initConfiguration)\n\n  const endpointBuilders = computeEndpointBuilders(initConfiguration, tags)\n  const intakeEndpoints = objectValues(endpointBuilders).map((builder) => builder.buildIntakeUrl())\n\n  const replicaConfiguration = computeReplicaConfiguration(initConfiguration, intakeEndpoints, tags)\n\n  return assign(\n    {\n      isIntakeUrl: (url: string) => intakeEndpoints.some((intakeEndpoint) => url.indexOf(intakeEndpoint) === 0),\n      replica: replicaConfiguration,\n      site: initConfiguration.site || INTAKE_SITE_US1,\n    },\n    endpointBuilders\n  )\n}\n\nfunction computeEndpointBuilders(initConfiguration: InitConfiguration, tags: string[]) {\n  return {\n    logsEndpointBuilder: createEndpointBuilder(initConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(initConfiguration, 'rum', tags),\n    sessionReplayEndpointBuilder: createEndpointBuilder(initConfiguration, 'sessionReplay', tags),\n  }\n}\n\nfunction computeReplicaConfiguration(\n  initConfiguration: InitConfiguration,\n  intakeEndpoints: string[],\n  tags: string[]\n): ReplicaConfiguration | undefined {\n  if (!initConfiguration.replica) {\n    return\n  }\n\n  const replicaConfiguration: InitConfiguration = assign({}, initConfiguration, {\n    site: INTAKE_SITE_US1,\n    clientToken: initConfiguration.replica.clientToken,\n  })\n\n  const replicaEndpointBuilders = {\n    logsEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'logs', tags),\n    rumEndpointBuilder: createEndpointBuilder(replicaConfiguration, 'rum', tags),\n  }\n\n  intakeEndpoints.push(...objectValues(replicaEndpointBuilders).map((builder) => builder.buildIntakeUrl()))\n\n  return assign({ applicationId: initConfiguration.replica.applicationId }, replicaEndpointBuilders)\n}\n","import { CookieOptions, GetCookieOverride, setCookieHandling, SetCookieOverride } from '../../browser/cookie'\nimport { getCurrentSite } from '../../browser/cookie'\nimport { catchUserErrors } from '../../tools/catchUserErrors'\nimport { display } from '../../tools/display'\nimport { assign, isPercentage, ONE_KIBI_BYTE, ONE_SECOND } from '../../tools/utils'\nimport type { RawTelemetryConfiguration } from '../telemetry'\nimport { updateExperimentalFeatures } from './experimentalFeatures'\nimport type { TransportConfiguration } from './transportConfiguration'\nimport { computeTransportConfiguration } from './transportConfiguration'\n\nexport const DefaultPrivacyLevel = {\n  ALLOW: 'allow',\n  MASK: 'mask',\n  MASK_USER_INPUT: 'mask-user-input',\n} as const\nexport type DefaultPrivacyLevel = typeof DefaultPrivacyLevel[keyof typeof DefaultPrivacyLevel]\n\nexport interface InitConfiguration {\n  // global options\n  clientToken: string\n  beforeSend?: GenericBeforeSendCallback | undefined\n  sampleRate?: number | undefined\n  telemetrySampleRate?: number | undefined\n  silentMultipleInit?: boolean | undefined\n\n  // transport options\n  proxyUrl?: string | undefined\n  site?: string | undefined\n\n  // tag and context options\n  service?: string | undefined\n  env?: string | undefined\n  version?: string | undefined\n\n  // cookie options\n  useCrossSiteSessionCookie?: boolean | undefined\n  useSecureSessionCookie?: boolean | undefined\n  trackSessionAcrossSubdomains?: boolean | undefined\n  getCookie?: GetCookieOverride\n  setCookie?: SetCookieOverride\n\n  // internal options\n  enableExperimentalFeatures?: string[] | undefined\n  replica?: ReplicaUserConfiguration | undefined\n  datacenter?: string\n  telemetryConfigurationSampleRate?: number\n}\n\n// This type is only used to build the core configuration. Logs and RUM SDKs are using a proper type\n// for this option.\ntype GenericBeforeSendCallback = (event: any, context?: any) => unknown\n\ninterface ReplicaUserConfiguration {\n  applicationId?: string\n  clientToken: string\n}\n\nexport interface Configuration extends TransportConfiguration {\n  // Built from init configuration\n  beforeSend: GenericBeforeSendCallback | undefined\n  cookieOptions: CookieOptions\n  sampleRate: number\n  telemetrySampleRate: number\n  telemetryConfigurationSampleRate: number\n  service: string | undefined\n  silentMultipleInit: boolean\n\n  // Event limits\n  eventRateLimiterThreshold: number // Limit the maximum number of actions, errors and logs per minutes\n  maxTelemetryEventsPerPage: number\n\n  // Batch configuration\n  batchBytesLimit: number\n  flushTimeout: number\n  batchMessagesLimit: number\n  messageBytesLimit: number\n}\n\nexport function validateAndBuildConfiguration(initConfiguration: InitConfiguration): Configuration | undefined {\n  if (!initConfiguration || !initConfiguration.clientToken) {\n    display.error('Client Token is not configured, we will not send any data.')\n    return\n  }\n\n  if (initConfiguration.sampleRate !== undefined && !isPercentage(initConfiguration.sampleRate)) {\n    display.error('Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (initConfiguration.telemetrySampleRate !== undefined && !isPercentage(initConfiguration.telemetrySampleRate)) {\n    display.error('Telemetry Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (\n    initConfiguration.telemetryConfigurationSampleRate !== undefined &&\n    !isPercentage(initConfiguration.telemetryConfigurationSampleRate)\n  ) {\n    display.error('Telemetry Configuration Sample Rate should be a number between 0 and 100')\n    return\n  }\n\n  if (!!initConfiguration.setCookie !== !!initConfiguration.getCookie) {\n    display.error('Both setCookie and getCookie must be set or undefined.')\n    return\n  }\n\n  // Set the experimental feature flags as early as possible, so we can use them in most places\n  updateExperimentalFeatures(initConfiguration.enableExperimentalFeatures)\n\n  return assign(\n    {\n      beforeSend:\n        initConfiguration.beforeSend && catchUserErrors(initConfiguration.beforeSend, 'beforeSend threw an error:'),\n      cookieOptions: buildCookieOptions(initConfiguration),\n      sampleRate: initConfiguration.sampleRate ?? 100,\n      telemetrySampleRate: initConfiguration.telemetrySampleRate ?? 20,\n      telemetryConfigurationSampleRate: initConfiguration.telemetryConfigurationSampleRate ?? 5,\n      service: initConfiguration.service,\n      silentMultipleInit: !!initConfiguration.silentMultipleInit,\n\n      /**\n       * beacon payload max queue size implementation is 64kb\n       * ensure that we leave room for logs, rum and potential other users\n       */\n      batchBytesLimit: 16 * ONE_KIBI_BYTE,\n\n      eventRateLimiterThreshold: 3000,\n      maxTelemetryEventsPerPage: 15,\n\n      /**\n       * flush automatically, aim to be lower than ALB connection timeout\n       * to maximize connection reuse.\n       */\n      flushTimeout: 30 * ONE_SECOND,\n\n      /**\n       * Logs intake limit\n       */\n      batchMessagesLimit: 50,\n      messageBytesLimit: 256 * ONE_KIBI_BYTE,\n    },\n    computeTransportConfiguration(initConfiguration)\n  )\n}\n\nexport function buildCookieOptions(initConfiguration: InitConfiguration) {\n  const cookieOptions: CookieOptions = {}\n\n  setCookieHandling(initConfiguration.getCookie!, initConfiguration.setCookie!);\n  \n  cookieOptions.secure = mustUseSecureCookie(initConfiguration)\n  cookieOptions.crossSite = !!initConfiguration.useCrossSiteSessionCookie\n\n  if (initConfiguration.trackSessionAcrossSubdomains) {\n    cookieOptions.domain = getCurrentSite()\n  }\n\n  return cookieOptions\n}\n\nfunction mustUseSecureCookie(initConfiguration: InitConfiguration) {\n  return !!initConfiguration.useSecureSessionCookie || !!initConfiguration.useCrossSiteSessionCookie\n}\n\nexport function serializeConfiguration(configuration: InitConfiguration): Partial<RawTelemetryConfiguration> {\n  return {\n    session_sample_rate: configuration.sampleRate,\n    telemetry_sample_rate: configuration.telemetrySampleRate,\n    telemetry_configuration_sample_rate: configuration.telemetryConfigurationSampleRate,\n    use_before_send: !!configuration.beforeSend,\n    use_cross_site_session_cookie: configuration.useCrossSiteSessionCookie,\n    use_secure_session_cookie: configuration.useSecureSessionCookie,\n    use_proxy: configuration.proxyUrl !== undefined ? !!configuration.proxyUrl : undefined,\n    silent_multiple_init: configuration.silentMultipleInit,\n    track_session_across_subdomains: configuration.trackSessionAcrossSubdomains,\n  }\n}\n","import { startsWith } from '../../tools/utils'\nimport type { StackTrace, StackFrame } from './types'\n\nconst UNKNOWN_FUNCTION = '?'\n\n/**\n * Computes a stack trace for an exception.\n */\nexport function computeStackTrace(ex: unknown): StackTrace {\n  const stack: StackFrame[] = []\n\n  let stackProperty = tryToGetString(ex, 'stack')\n  const exString = String(ex)\n  if (stackProperty && startsWith(stackProperty, exString)) {\n    stackProperty = stackProperty.slice(exString.length)\n  }\n  if (stackProperty) {\n    stackProperty.split('\\n').forEach((line) => {\n      const stackFrame =\n        parseChromeLine(line) || parseChromeAnonymousLine(line) || parseWinLine(line) || parseGeckoLine(line)\n      if (stackFrame) {\n        if (!stackFrame.func && stackFrame.line) {\n          stackFrame.func = UNKNOWN_FUNCTION\n        }\n\n        stack.push(stackFrame)\n      }\n    })\n  }\n\n  return {\n    message: tryToGetString(ex, 'message'),\n    name: tryToGetString(ex, 'name'),\n    stack,\n  }\n}\nconst fileUrl = '((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\\\w+\\\\.|\\\\/).*?)'\nconst filePosition = '(?::(\\\\d+))'\nconst CHROME_LINE_RE = new RegExp(`^\\\\s*at (.*?) ?\\\\(${fileUrl}${filePosition}?${filePosition}?\\\\)?\\\\s*$`, 'i')\n\nconst CHROME_EVAL_RE = new RegExp(`\\\\((\\\\S*)${filePosition}${filePosition}\\\\)`)\n\nfunction parseChromeLine(line: string): StackFrame | undefined {\n  const parts = CHROME_LINE_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  const isNative = parts[2] && parts[2].indexOf('native') === 0 // start of line\n  const isEval = parts[2] && parts[2].indexOf('eval') === 0 // start of line\n  const submatch = CHROME_EVAL_RE.exec(parts[2])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1] // url\n    parts[3] = submatch[2] // line\n    parts[4] = submatch[3] // column\n  }\n\n  return {\n    args: isNative ? [parts[2]] : [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[3] ? +parts[3] : undefined,\n    url: !isNative ? parts[2] : undefined,\n  }\n}\n\nconst CHROME_ANONYMOUS_FUNCTION_RE = new RegExp(`^\\\\s*at ?${fileUrl}${filePosition}?${filePosition}??\\\\s*$`, 'i')\n\nfunction parseChromeAnonymousLine(line: string): StackFrame | undefined {\n  const parts = CHROME_ANONYMOUS_FUNCTION_RE.exec(line)\n\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[3] ? +parts[3] : undefined,\n    func: UNKNOWN_FUNCTION,\n    line: parts[2] ? +parts[2] : undefined,\n    url: parts[1],\n  }\n}\n\nconst WINJS_LINE_RE =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i\n\nfunction parseWinLine(line: string): StackFrame | undefined {\n  const parts = WINJS_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  return {\n    args: [],\n    column: parts[4] ? +parts[4] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: +parts[3],\n    url: parts[2],\n  }\n}\n\nconst GECKO_LINE_RE =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|capacitor|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i\nconst GECKO_EVAL_RE = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i\n\nfunction parseGeckoLine(line: string): StackFrame | undefined {\n  const parts = GECKO_LINE_RE.exec(line)\n  if (!parts) {\n    return\n  }\n\n  const isEval = parts[3] && parts[3].indexOf(' > eval') > -1\n  const submatch = GECKO_EVAL_RE.exec(parts[3])\n\n  if (isEval && submatch) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1]\n    parts[4] = submatch[2]\n    parts[5] = undefined! // no column when eval\n  }\n\n  return {\n    args: parts[2] ? parts[2].split(',') : [],\n    column: parts[5] ? +parts[5] : undefined,\n    func: parts[1] || UNKNOWN_FUNCTION,\n    line: parts[4] ? +parts[4] : undefined,\n    url: parts[3],\n  }\n}\n\nfunction tryToGetString(candidate: unknown, property: string) {\n  if (typeof candidate !== 'object' || !candidate || !(property in candidate)) {\n    return undefined\n  }\n  const value = (candidate as { [k: string]: unknown })[property]\n  return typeof value === 'string' ? value : undefined\n}\n","import type { StackTrace } from '../domain/tracekit'\nimport { computeStackTrace } from '../domain/tracekit'\nimport { callMonitored } from './monitor'\nimport type { ClocksState } from './timeUtils'\nimport { jsonStringify, noop } from './utils'\n\nexport interface ErrorWithCause extends Error {\n  cause?: Error\n}\n\nexport type RawErrorCause = {\n  message: string\n  source: string\n  type?: string\n  stack?: string\n}\n\nexport interface RawError {\n  startClocks: ClocksState\n  message: string\n  type?: string\n  stack?: string\n  source: ErrorSource\n  originalError?: unknown\n  handling?: ErrorHandling\n  handlingStack?: string\n  causes?: RawErrorCause[]\n}\n\nexport const ErrorSource = {\n  AGENT: 'agent',\n  CONSOLE: 'console',\n  CUSTOM: 'custom',\n  LOGGER: 'logger',\n  NETWORK: 'network',\n  SOURCE: 'source',\n  REPORT: 'report',\n} as const\n\nexport const enum ErrorHandling {\n  HANDLED = 'handled',\n  UNHANDLED = 'unhandled',\n}\n\nexport type ErrorSource = typeof ErrorSource[keyof typeof ErrorSource]\n\ntype RawErrorParams = {\n  stackTrace?: StackTrace\n  originalError: unknown\n\n  handlingStack?: string\n  startClocks: ClocksState\n  nonErrorPrefix: string\n  source: ErrorSource\n  handling: ErrorHandling\n}\n\nexport function computeRawError({\n  stackTrace,\n  originalError,\n  handlingStack,\n  startClocks,\n  nonErrorPrefix,\n  source,\n  handling,\n}: RawErrorParams): RawError {\n  if (!stackTrace || (stackTrace.message === undefined && !(originalError instanceof Error))) {\n    return {\n      startClocks,\n      source,\n      handling,\n      originalError,\n      message: `${nonErrorPrefix} ${jsonStringify(originalError)!}`,\n      stack: 'No stack, consider using an instance of Error',\n      handlingStack,\n      type: stackTrace && stackTrace.name,\n    }\n  }\n\n  return {\n    startClocks,\n    source,\n    handling,\n    originalError,\n    message: stackTrace.message || 'Empty message',\n    stack: toStackTraceString(stackTrace),\n    handlingStack,\n    type: stackTrace.name,\n    causes: flattenErrorCauses(originalError as ErrorWithCause, source),\n  }\n}\n\nexport function toStackTraceString(stack: StackTrace) {\n  let result = formatErrorMessage(stack)\n  stack.stack.forEach((frame) => {\n    const func = frame.func === '?' ? '<anonymous>' : frame.func\n    const args = frame.args && frame.args.length > 0 ? `(${frame.args.join(', ')})` : ''\n    const line = frame.line ? `:${frame.line}` : ''\n    const column = frame.line && frame.column ? `:${frame.column}` : ''\n    result += `\\n  at ${func!}${args} @ ${frame.url!}${line}${column}`\n  })\n  return result\n}\n\nexport function getFileFromStackTraceString(stack: string) {\n  return /@ (.+)/.exec(stack)?.[1]\n}\n\nexport function formatErrorMessage(stack: StackTrace) {\n  return `${stack.name || 'Error'}: ${stack.message!}`\n}\n\n/**\n Creates a stacktrace without SDK internal frames.\n \n Constraints:\n - Has to be called at the utmost position of the call stack.\n - No monitored function should encapsulate it, that is why we need to use callMonitored inside it.\n */\nexport function createHandlingStack(): string {\n  /**\n   * Skip the two internal frames:\n   * - SDK API (console.error, ...)\n   * - this function\n   * in order to keep only the user calls\n   */\n  const internalFramesToSkip = 2\n  const error = new Error()\n  let formattedStack: string\n\n  // IE needs to throw the error to fill in the stack trace\n  if (!error.stack) {\n    try {\n      throw error\n    } catch (e) {\n      noop()\n    }\n  }\n\n  callMonitored(() => {\n    const stackTrace = computeStackTrace(error)\n    stackTrace.stack = stackTrace.stack.slice(internalFramesToSkip)\n    formattedStack = toStackTraceString(stackTrace)\n  })\n\n  return formattedStack!\n}\n\nexport function flattenErrorCauses(error: ErrorWithCause, parentSource: ErrorSource): RawErrorCause[] | undefined {\n  let currentError = error\n  const causes: RawErrorCause[] = []\n  while (currentError?.cause instanceof Error && causes.length < 10) {\n    const stackTrace = computeStackTrace(currentError.cause)\n    causes.push({\n      message: currentError.cause.message,\n      source: parentSource,\n      type: stackTrace?.name,\n      stack: stackTrace && toStackTraceString(stackTrace),\n    })\n    currentError = currentError.cause\n  }\n  return causes.length ? causes : undefined\n}\n","export interface Subscription {\n  unsubscribe: () => void\n}\n\nexport class Observable<T> {\n  private observers: Array<(data: T) => void> = []\n  private onLastUnsubscribe?: () => void\n\n  constructor(private onFirstSubscribe?: () => (() => void) | void) {}\n\n  subscribe(f: (data: T) => void): Subscription {\n    if (!this.observers.length && this.onFirstSubscribe) {\n      this.onLastUnsubscribe = this.onFirstSubscribe() || undefined\n    }\n    this.observers.push(f)\n    return {\n      unsubscribe: () => {\n        this.observers = this.observers.filter((other) => f !== other)\n        if (!this.observers.length && this.onLastUnsubscribe) {\n          this.onLastUnsubscribe()\n        }\n      },\n    }\n  }\n\n  notify(data: T) {\n    this.observers.forEach((observer) => observer(data))\n  }\n}\n\nexport function mergeObservables<T>(...observables: Array<Observable<T>>) {\n  const globalObservable = new Observable<T>(() => {\n    const subscriptions: Subscription[] = observables.map((observable) =>\n      observable.subscribe((data) => globalObservable.notify(data))\n    )\n    return () => subscriptions.forEach((subscription) => subscription.unsubscribe())\n  })\n\n  return globalObservable\n}\n","import { toStackTraceString } from '../../tools/error'\nimport { monitor } from '../../tools/monitor'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { DOM_EVENT, includes, addEventListener, safeTruncate } from '../../tools/utils'\nimport type { Report, BrowserWindow, ReportType } from './browser.types'\n\nexport const RawReportType = {\n  intervention: 'intervention',\n  deprecation: 'deprecation',\n  cspViolation: 'csp_violation',\n} as const\n\nexport type RawReportType = typeof RawReportType[keyof typeof RawReportType]\n\nexport interface RawReport {\n  type: RawReportType\n  subtype: string\n  message: string\n  stack?: string\n}\n\nexport function initReportObservable(apis: RawReportType[]) {\n  const observables: Array<Observable<RawReport>> = []\n\n  if (includes(apis, RawReportType.cspViolation)) {\n    observables.push(createCspViolationReportObservable())\n  }\n\n  const reportTypes = apis.filter((api: RawReportType): api is ReportType => api !== RawReportType.cspViolation)\n  if (reportTypes.length) {\n    observables.push(createReportObservable(reportTypes))\n  }\n\n  return mergeObservables<RawReport>(...observables)\n}\n\nfunction createReportObservable(reportTypes: ReportType[]) {\n  const observable = new Observable<RawReport>(() => {\n    if (!(window as BrowserWindow).ReportingObserver) {\n      return\n    }\n\n    const handleReports = monitor((reports: Report[]) =>\n      reports.forEach((report) => {\n        observable.notify(buildRawReportFromReport(report))\n      })\n    )\n\n    const observer = new (window as BrowserWindow).ReportingObserver!(handleReports, {\n      types: reportTypes,\n      buffered: true,\n    })\n\n    observer.observe()\n    return () => {\n      observer.disconnect()\n    }\n  })\n\n  return observable\n}\n\nfunction createCspViolationReportObservable() {\n  const observable = new Observable<RawReport>(() => {\n    const handleCspViolation = monitor((event: SecurityPolicyViolationEvent) => {\n      observable.notify(buildRawReportFromCspViolation(event))\n    })\n\n    const { stop } = addEventListener(document, DOM_EVENT.SECURITY_POLICY_VIOLATION, handleCspViolation)\n\n    return stop\n  })\n  return observable\n}\n\nfunction buildRawReportFromReport({ type, body }: Report): RawReport {\n  return {\n    type,\n    subtype: body.id,\n    message: `${type}: ${body.message}`,\n    stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n  }\n}\n\nfunction buildRawReportFromCspViolation(event: SecurityPolicyViolationEvent): RawReport {\n  const type = RawReportType.cspViolation\n  const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`\n  return {\n    type: RawReportType.cspViolation,\n    subtype: event.effectiveDirective,\n    message: `${type}: ${message}`,\n    stack: buildStack(\n      event.effectiveDirective,\n      event.originalPolicy\n        ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n        : 'no policy',\n      event.sourceFile,\n      event.lineNumber,\n      event.columnNumber\n    ),\n  }\n}\n\nfunction buildStack(\n  name: string,\n  message: string,\n  sourceFile: string | undefined,\n  lineNumber: number | undefined,\n  columnNumber: number | undefined\n): string | undefined {\n  return (\n    sourceFile &&\n    toStackTraceString({\n      name,\n      message,\n      stack: [\n        {\n          func: '?',\n          url: sourceFile,\n          line: lineNumber,\n          column: columnNumber,\n        },\n      ],\n    })\n  )\n}\n","import type { Configuration, InitConfiguration, RawTelemetryConfiguration } from '@datadog/browser-core'\nimport {\n  serializeConfiguration,\n  assign,\n  ONE_KIBI_BYTE,\n  validateAndBuildConfiguration,\n  display,\n  removeDuplicates,\n  ConsoleApiName,\n  RawReportType,\n  includes,\n  objectValues,\n} from '@datadog/browser-core'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport interface LogsInitConfiguration extends InitConfiguration {\n  beforeSend?: ((event: LogsEvent) => void | boolean) | undefined\n  forwardErrorsToLogs?: boolean | undefined\n  forwardConsoleLogs?: ConsoleApiName[] | 'all' | undefined\n  forwardReports?: RawReportType[] | 'all' | undefined\n}\n\nexport type HybridInitConfiguration = Omit<LogsInitConfiguration, 'clientToken'>\n\nexport interface LogsConfiguration extends Configuration {\n  forwardErrorsToLogs: boolean\n  forwardConsoleLogs: ConsoleApiName[]\n  forwardReports: RawReportType[]\n  requestErrorResponseLengthLimit: number\n}\n\n/**\n * arbitrary value, byte precision not needed\n */\nexport const DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT = 32 * ONE_KIBI_BYTE\n\nexport function validateAndBuildLogsConfiguration(\n  initConfiguration: LogsInitConfiguration\n): LogsConfiguration | undefined {\n  const baseConfiguration = validateAndBuildConfiguration(initConfiguration)\n\n  const forwardConsoleLogs = validateAndBuildForwardOption<ConsoleApiName>(\n    initConfiguration.forwardConsoleLogs,\n    objectValues(ConsoleApiName),\n    'Forward Console Logs'\n  )\n\n  const forwardReports = validateAndBuildForwardOption<RawReportType>(\n    initConfiguration.forwardReports,\n    objectValues(RawReportType),\n    'Forward Reports'\n  )\n\n  if (!baseConfiguration || !forwardConsoleLogs || !forwardReports) {\n    return\n  }\n\n  if (initConfiguration.forwardErrorsToLogs && !includes(forwardConsoleLogs, ConsoleApiName.error)) {\n    forwardConsoleLogs.push(ConsoleApiName.error)\n  }\n\n  return assign(\n    {\n      forwardErrorsToLogs: initConfiguration.forwardErrorsToLogs !== false,\n      forwardConsoleLogs,\n      forwardReports,\n      requestErrorResponseLengthLimit: DEFAULT_REQUEST_ERROR_RESPONSE_LENGTH_LIMIT,\n    },\n    baseConfiguration\n  )\n}\n\nexport function validateAndBuildForwardOption<T>(\n  option: readonly T[] | 'all' | undefined,\n  allowedValues: T[],\n  label: string\n): T[] | undefined {\n  if (option === undefined) {\n    return []\n  }\n\n  if (!(option === 'all' || (Array.isArray(option) && option.every((api) => includes(allowedValues, api))))) {\n    display.error(`${label} should be \"all\" or an array with allowed values \"${allowedValues.join('\", \"')}\"`)\n    return\n  }\n\n  return option === 'all' ? allowedValues : removeDuplicates<T>(option)\n}\n\nexport function serializeLogsConfiguration(configuration: LogsInitConfiguration): RawTelemetryConfiguration {\n  const baseSerializedInitConfiguration = serializeConfiguration(configuration)\n\n  return assign(\n    {\n      forward_errors_to_logs: configuration.forwardErrorsToLogs,\n      forward_console_logs: configuration.forwardConsoleLogs,\n      forward_reports: configuration.forwardReports,\n    },\n    baseSerializedInitConfiguration\n  )\n}\n","import type { Context } from '@datadog/browser-core'\nimport { deepClone, assign, combine, createContextManager, ErrorSource, monitored } from '@datadog/browser-core'\n\nexport interface LogsMessage {\n  message: string\n  status: StatusType\n  context?: Context\n}\n\nexport const StatusType = {\n  debug: 'debug',\n  error: 'error',\n  info: 'info',\n  warn: 'warn',\n} as const\n\nexport type StatusType = typeof StatusType[keyof typeof StatusType]\n\nexport const HandlerType = {\n  console: 'console',\n  http: 'http',\n  silent: 'silent',\n} as const\n\nexport type HandlerType = typeof HandlerType[keyof typeof HandlerType]\nexport const STATUSES = Object.keys(StatusType) as StatusType[]\n\nexport class Logger {\n  private contextManager = createContextManager()\n\n  constructor(\n    private handleLogStrategy: (logsMessage: LogsMessage, logger: Logger) => void,\n    name?: string,\n    private handlerType: HandlerType | HandlerType[] = HandlerType.http,\n    private level: StatusType = StatusType.debug,\n    loggerContext: object = {}\n  ) {\n    this.contextManager.set(assign({}, loggerContext, name ? { logger: { name } } : undefined))\n  }\n\n  @monitored\n  log(message: string, messageContext?: object, status: StatusType = StatusType.info) {\n    this.handleLogStrategy({ message, context: deepClone(messageContext) as Context, status }, this)\n  }\n\n  debug(message: string, messageContext?: object) {\n    this.log(message, messageContext, StatusType.debug)\n  }\n\n  info(message: string, messageContext?: object) {\n    this.log(message, messageContext, StatusType.info)\n  }\n\n  warn(message: string, messageContext?: object) {\n    this.log(message, messageContext, StatusType.warn)\n  }\n\n  error(message: string, messageContext?: object) {\n    const errorOrigin = {\n      error: {\n        origin: ErrorSource.LOGGER,\n      },\n    }\n    this.log(message, combine(errorOrigin, messageContext), StatusType.error)\n  }\n\n  setContext(context: object) {\n    this.contextManager.set(context)\n  }\n\n  getContext() {\n    return this.contextManager.get()\n  }\n\n  addContext(key: string, value: any) {\n    this.contextManager.add(key, value)\n  }\n\n  removeContext(key: string) {\n    this.contextManager.remove(key)\n  }\n\n  setHandler(handler: HandlerType | HandlerType[]) {\n    this.handlerType = handler\n  }\n\n  getHandler() {\n    return this.handlerType\n  }\n\n  setLevel(level: StatusType) {\n    this.level = level\n  }\n\n  getLevel() {\n    return this.level\n  }\n}\n","import { getCookie } from '../../browser/cookie'\n\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id'\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id'\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum'\n\nexport interface BrowserWindow extends Window {\n  _DATADOG_SYNTHETICS_PUBLIC_ID?: unknown\n  _DATADOG_SYNTHETICS_RESULT_ID?: unknown\n  _DATADOG_SYNTHETICS_INJECTS_RUM?: unknown\n}\n\nexport function willSyntheticsInjectRum(): boolean {\n  return Boolean(\n    (window as BrowserWindow)._DATADOG_SYNTHETICS_INJECTS_RUM || getCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME)\n  )\n}\n\nexport function getSyntheticsTestId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_PUBLIC_ID || getCookie(SYNTHETICS_TEST_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n\nexport function getSyntheticsResultId(): string | undefined {\n  const value = (window as BrowserWindow)._DATADOG_SYNTHETICS_RESULT_ID || getCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME)\n  return typeof value === 'string' ? value : undefined\n}\n","import type { TelemetryEvent, TelemetryConfigurationEvent } from './telemetryEvent.types'\n\nexport const TelemetryType = {\n  log: 'log',\n  configuration: 'configuration',\n} as const\n\nexport const enum StatusType {\n  debug = 'debug',\n  error = 'error',\n}\n\nexport type RawTelemetryEvent = TelemetryEvent['telemetry']\nexport type RawTelemetryConfiguration = TelemetryConfigurationEvent['telemetry']['configuration']\n","import type { Context } from '../../tools/context'\nimport { ConsoleApiName } from '../../tools/display'\nimport { toStackTraceString } from '../../tools/error'\nimport { assign, combine, jsonStringify, performDraw, includes, startsWith, arrayFrom } from '../../tools/utils'\nimport type { Configuration } from '../configuration'\nimport { getExperimentalFeatures, INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../configuration'\nimport type { StackTrace } from '../tracekit'\nimport { computeStackTrace } from '../tracekit'\nimport { Observable } from '../../tools/observable'\nimport { timeStampNow } from '../../tools/timeUtils'\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor'\nimport type { TelemetryEvent } from './telemetryEvent.types'\nimport type { RawTelemetryConfiguration, RawTelemetryEvent } from './rawTelemetryEvent.types'\nimport { StatusType, TelemetryType } from './rawTelemetryEvent.types'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nconst ALLOWED_FRAME_URLS = [\n  'https://www.datadoghq-browser-agent.com',\n  'https://www.datad0g-browser-agent.com',\n  'http://localhost',\n  '<anonymous>',\n]\n\nexport const enum TelemetryService {\n  LOGS = 'browser-logs-sdk',\n  RUM = 'browser-rum-sdk',\n}\n\nexport interface Telemetry {\n  setContextProvider: (provider: () => Context) => void\n  observable: Observable<TelemetryEvent & Context>\n}\n\nconst TELEMETRY_EXCLUDED_SITES: string[] = [INTAKE_SITE_US1_FED]\n\nconst telemetryConfiguration: {\n  maxEventsPerPage: number\n  sentEventCount: number\n  telemetryEnabled: boolean\n  telemetryConfigurationEnabled: boolean\n} = { maxEventsPerPage: 0, sentEventCount: 0, telemetryEnabled: false, telemetryConfigurationEnabled: false }\n\nlet onRawTelemetryEventCollected: ((event: RawTelemetryEvent) => void) | undefined\n\nexport function startTelemetry(telemetryService: TelemetryService, configuration: Configuration): Telemetry {\n  let contextProvider: () => Context\n  const observable = new Observable<TelemetryEvent & Context>()\n\n  telemetryConfiguration.telemetryEnabled = performDraw(configuration.telemetrySampleRate)\n  telemetryConfiguration.telemetryConfigurationEnabled =\n    telemetryConfiguration.telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate)\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    if (!includes(TELEMETRY_EXCLUDED_SITES, configuration.site) && telemetryConfiguration.telemetryEnabled) {\n      observable.notify(toTelemetryEvent(telemetryService, event))\n    }\n  }\n  startMonitorErrorCollection(addTelemetryError)\n\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: configuration.maxTelemetryEventsPerPage,\n    sentEventCount: 0,\n  })\n\n  function toTelemetryEvent(telemetryService: TelemetryService, event: RawTelemetryEvent): TelemetryEvent & Context {\n    return combine(\n      {\n        type: 'telemetry' as const,\n        date: timeStampNow(),\n        service: telemetryService,\n        version: __BUILD_ENV__SDK_VERSION__,\n        source: 'browser' as const,\n        _dd: {\n          format_version: 2 as const,\n        },\n        telemetry: event as any, // https://github.com/microsoft/TypeScript/issues/48457\n        experimental_features: arrayFrom(getExperimentalFeatures()),\n      },\n      contextProvider !== undefined ? contextProvider() : {}\n    )\n  }\n\n  return {\n    setContextProvider: (provider: () => Context) => {\n      contextProvider = provider\n    },\n    observable,\n  }\n}\n\nexport function startFakeTelemetry() {\n  const events: RawTelemetryEvent[] = []\n  assign(telemetryConfiguration, {\n    maxEventsPerPage: Infinity,\n    sentEventCount: 0,\n  })\n\n  onRawTelemetryEventCollected = (event: RawTelemetryEvent) => {\n    events.push(event)\n  }\n\n  return events\n}\n\nexport function resetTelemetry() {\n  onRawTelemetryEventCollected = undefined\n}\n\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nexport function isTelemetryReplicationAllowed(configuration: Configuration) {\n  return configuration.site === INTAKE_SITE_STAGING\n}\n\nexport function addTelemetryDebug(message: string, context?: Context) {\n  displayIfDebugEnabled(ConsoleApiName.debug, message, context)\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        message,\n        status: StatusType.debug,\n      },\n      context\n    )\n  )\n}\n\nexport function addTelemetryError(e: unknown) {\n  addTelemetry(\n    assign(\n      {\n        type: TelemetryType.log,\n        status: StatusType.error,\n      },\n      formatError(e)\n    )\n  )\n}\n\nexport function addTelemetryConfiguration(configuration: RawTelemetryConfiguration) {\n  if (telemetryConfiguration.telemetryConfigurationEnabled) {\n    addTelemetry({\n      type: TelemetryType.configuration,\n      configuration,\n    })\n  }\n}\n\nfunction addTelemetry(event: RawTelemetryEvent) {\n  if (onRawTelemetryEventCollected && telemetryConfiguration.sentEventCount < telemetryConfiguration.maxEventsPerPage) {\n    telemetryConfiguration.sentEventCount += 1\n    onRawTelemetryEventCollected(event)\n  }\n}\n\nexport function formatError(e: unknown) {\n  if (e instanceof Error) {\n    const stackTrace = computeStackTrace(e)\n    return {\n      error: {\n        kind: stackTrace.name,\n        stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n      },\n      message: stackTrace.message!,\n    }\n  }\n  return {\n    error: {\n      stack: 'Not an instance of error',\n    },\n    message: `Uncaught ${jsonStringify(e)!}`,\n  }\n}\n\nexport function scrubCustomerFrames(stackTrace: StackTrace) {\n  stackTrace.stack = stackTrace.stack.filter(\n    (frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => startsWith(frame.url!, allowedFrameUrl))\n  )\n  return stackTrace\n}\n","import { display } from '../tools/display'\nimport type { Context } from '../tools/context'\nimport { addEventListener, DOM_EVENT, jsonStringify, noop, objectValues } from '../tools/utils'\nimport { monitor } from '../tools/monitor'\nimport type { HttpRequest } from './httpRequest'\n\n// https://en.wikipedia.org/wiki/UTF-8\n// eslint-disable-next-line no-control-regex\nconst HAS_MULTI_BYTES_CHARACTERS = /[^\\u0000-\\u007F]/\n\nexport class Batch {\n  private pushOnlyBuffer: string[] = []\n  private upsertBuffer: { [key: string]: string } = {}\n  private bufferBytesCount = 0\n  private bufferMessagesCount = 0\n\n  constructor(\n    private request: HttpRequest,\n    private batchMessagesLimit: number,\n    private batchBytesLimit: number,\n    private messageBytesLimit: number,\n    private flushTimeout: number,\n    private beforeUnloadCallback: () => void = noop\n  ) {\n    this.setupFlushOnExit()\n    this.flushPeriodically()\n  }\n\n  add(message: Context) {\n    this.addOrUpdate(message)\n  }\n\n  upsert(message: Context, key: string) {\n    this.addOrUpdate(message, key)\n  }\n\n  flush(sendFn = this.request.send) {\n    if (this.bufferMessagesCount !== 0) {\n      const messages = this.pushOnlyBuffer.concat(objectValues(this.upsertBuffer))\n      const bytesCount = this.bufferBytesCount\n\n      this.pushOnlyBuffer = []\n      this.upsertBuffer = {}\n      this.bufferBytesCount = 0\n      this.bufferMessagesCount = 0\n\n      sendFn({ data: messages.join('\\n'), bytesCount })\n    }\n  }\n\n  flushOnExit() {\n    this.flush(this.request.sendOnExit)\n  }\n\n  computeBytesCount(candidate: string) {\n    // Accurate bytes count computations can degrade performances when there is a lot of events to process\n    if (!HAS_MULTI_BYTES_CHARACTERS.test(candidate)) {\n      return candidate.length\n    }\n\n    if (window.TextEncoder !== undefined) {\n      return new TextEncoder().encode(candidate).length\n    }\n\n    return new Blob([candidate]).size\n  }\n\n  private addOrUpdate(message: Context, key?: string) {\n    const { processedMessage, messageBytesCount } = this.process(message)\n    if (messageBytesCount >= this.messageBytesLimit) {\n      display.warn(\n        `Discarded a message whose size was bigger than the maximum allowed size ${this.messageBytesLimit}KB.`\n      )\n      return\n    }\n    if (this.hasMessageFor(key)) {\n      this.remove(key)\n    }\n    if (this.willReachedBytesLimitWith(messageBytesCount)) {\n      this.flush()\n    }\n\n    this.push(processedMessage, messageBytesCount, key)\n    if (this.isFull()) {\n      this.flush()\n    }\n  }\n\n  private process(message: Context) {\n    const processedMessage = jsonStringify(message)!\n    const messageBytesCount = this.computeBytesCount(processedMessage)\n    return { processedMessage, messageBytesCount }\n  }\n\n  private push(processedMessage: string, messageBytesCount: number, key?: string) {\n    if (this.bufferMessagesCount > 0) {\n      // \\n separator at serialization\n      this.bufferBytesCount += 1\n    }\n    if (key !== undefined) {\n      this.upsertBuffer[key] = processedMessage\n    } else {\n      this.pushOnlyBuffer.push(processedMessage)\n    }\n    this.bufferBytesCount += messageBytesCount\n    this.bufferMessagesCount += 1\n  }\n\n  private remove(key: string) {\n    const removedMessage = this.upsertBuffer[key]\n    delete this.upsertBuffer[key]\n    const messageBytesCount = this.computeBytesCount(removedMessage)\n    this.bufferBytesCount -= messageBytesCount\n    this.bufferMessagesCount -= 1\n    if (this.bufferMessagesCount > 0) {\n      this.bufferBytesCount -= 1\n    }\n  }\n\n  private hasMessageFor(key?: string): key is string {\n    return key !== undefined && this.upsertBuffer[key] !== undefined\n  }\n\n  private willReachedBytesLimitWith(messageBytesCount: number) {\n    // byte of the separator at the end of the message\n    return this.bufferBytesCount + messageBytesCount + 1 >= this.batchBytesLimit\n  }\n\n  private isFull() {\n    return this.bufferMessagesCount === this.batchMessagesLimit || this.bufferBytesCount >= this.batchBytesLimit\n  }\n\n  private flushPeriodically() {\n    setTimeout(\n      monitor(() => {\n        this.flush()\n        this.flushPeriodically()\n      }),\n      this.flushTimeout\n    )\n  }\n\n  private setupFlushOnExit() {\n    /**\n     * With sendBeacon, requests are guaranteed to be successfully sent during document unload\n     */\n    // @ts-ignore this function is not always defined\n    if (navigator.sendBeacon) {\n      /**\n       * beforeunload is called before visibilitychange\n       * register first to be sure to be called before flush on beforeunload\n       * caveat: unload can still be canceled by another listener\n       */\n      addEventListener(window, DOM_EVENT.BEFORE_UNLOAD, this.beforeUnloadCallback)\n\n      /**\n       * Only event that guarantee to fire on mobile devices when the page transitions to background state\n       * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n       */\n      addEventListener(document, DOM_EVENT.VISIBILITY_CHANGE, () => {\n        if (document.visibilityState === 'hidden') {\n          this.flushOnExit()\n        }\n      })\n      /**\n       * Safari does not support yet to send a request during:\n       * - a visibility change during doc unload (cf: https://bugs.webkit.org/show_bug.cgi?id=194897)\n       * - a page hide transition (cf: https://bugs.webkit.org/show_bug.cgi?id=188329)\n       */\n      addEventListener(window, DOM_EVENT.BEFORE_UNLOAD, () => this.flushOnExit())\n    }\n  }\n}\n","import type { EndpointType } from '../domain/configuration'\nimport { monitor } from '../tools/monitor'\nimport type { RawError } from '../tools/error'\nimport { clocksNow } from '../tools/timeUtils'\nimport { ONE_KIBI_BYTE, ONE_MEBI_BYTE, ONE_SECOND, ONE_MINUTE } from '../tools/utils'\nimport { ErrorSource } from '../tools/error'\nimport type { Payload, HttpResponse } from './httpRequest'\n\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE\nexport const MAX_ONGOING_REQUESTS = 32\nexport const MAX_QUEUE_BYTES_COUNT = 3 * ONE_MEBI_BYTE\nexport const MAX_BACKOFF_TIME = ONE_MINUTE\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND\n\nconst enum TransportStatus {\n  UP,\n  FAILURE_DETECTED,\n  DOWN,\n}\n\nconst enum RetryReason {\n  AFTER_SUCCESS,\n  AFTER_RESUME,\n}\n\nexport interface RetryState {\n  transportStatus: TransportStatus\n  currentBackoffTime: number\n  bandwidthMonitor: ReturnType<typeof newBandwidthMonitor>\n  queuedPayloads: ReturnType<typeof newPayloadQueue>\n  queueFullReported: boolean\n}\n\ntype SendStrategy = (payload: Payload, onResponse: (r: HttpResponse) => void) => void\n\nexport function sendWithRetryStrategy(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (\n    state.transportStatus === TransportStatus.UP &&\n    state.queuedPayloads.size() === 0 &&\n    state.bandwidthMonitor.canHandle(payload)\n  ) {\n    send(payload, state, sendStrategy, {\n      onSuccess: () => retryQueuedPayloads(RetryReason.AFTER_SUCCESS, state, sendStrategy, endpointType, reportError),\n      onFailure: () => {\n        state.queuedPayloads.enqueue(payload)\n        scheduleRetry(state, sendStrategy, endpointType, reportError)\n      },\n    })\n  } else {\n    state.queuedPayloads.enqueue(payload)\n  }\n}\n\nfunction scheduleRetry(\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (state.transportStatus !== TransportStatus.DOWN) {\n    return\n  }\n  setTimeout(\n    monitor(() => {\n      const payload = state.queuedPayloads.first()\n      send(payload, state, sendStrategy, {\n        onSuccess: () => {\n          state.queuedPayloads.dequeue()\n          state.currentBackoffTime = INITIAL_BACKOFF_TIME\n          retryQueuedPayloads(RetryReason.AFTER_RESUME, state, sendStrategy, endpointType, reportError)\n        },\n        onFailure: () => {\n          state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2)\n          scheduleRetry(state, sendStrategy, endpointType, reportError)\n        },\n      })\n    }),\n    state.currentBackoffTime\n  )\n}\n\nfunction send(\n  payload: Payload,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  { onSuccess, onFailure }: { onSuccess: () => void; onFailure: () => void }\n) {\n  state.bandwidthMonitor.add(payload)\n  sendStrategy(payload, (response) => {\n    state.bandwidthMonitor.remove(payload)\n    if (!shouldRetryRequest(response)) {\n      state.transportStatus = TransportStatus.UP\n      onSuccess()\n    } else {\n      // do not consider transport down if another ongoing request could succeed\n      state.transportStatus =\n        state.bandwidthMonitor.ongoingRequestCount > 0 ? TransportStatus.FAILURE_DETECTED : TransportStatus.DOWN\n      onFailure()\n    }\n  })\n}\n\nfunction retryQueuedPayloads(\n  reason: RetryReason,\n  state: RetryState,\n  sendStrategy: SendStrategy,\n  endpointType: EndpointType,\n  reportError: (error: RawError) => void\n) {\n  if (reason === RetryReason.AFTER_SUCCESS && state.queuedPayloads.isFull() && !state.queueFullReported) {\n    reportError({\n      message: `Reached max ${endpointType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n      source: ErrorSource.AGENT,\n      startClocks: clocksNow(),\n    })\n    state.queueFullReported = true\n  }\n  const previousQueue = state.queuedPayloads\n  state.queuedPayloads = newPayloadQueue()\n  while (previousQueue.size() > 0) {\n    sendWithRetryStrategy(previousQueue.dequeue()!, state, sendStrategy, endpointType, reportError)\n  }\n}\n\nfunction shouldRetryRequest(response: HttpResponse) {\n  return response.status === 0 || response.status === 408 || response.status === 429 || response.status >= 500\n}\n\nexport function newRetryState(): RetryState {\n  return {\n    transportStatus: TransportStatus.UP,\n    currentBackoffTime: INITIAL_BACKOFF_TIME,\n    bandwidthMonitor: newBandwidthMonitor(),\n    queuedPayloads: newPayloadQueue(),\n    queueFullReported: false,\n  }\n}\n\nfunction newPayloadQueue() {\n  const queue: Payload[] = []\n  return {\n    bytesCount: 0,\n    enqueue(payload: Payload) {\n      if (this.isFull()) {\n        return\n      }\n      queue.push(payload)\n      this.bytesCount += payload.bytesCount\n    },\n    first() {\n      return queue[0]\n    },\n    dequeue() {\n      const payload = queue.shift()\n      if (payload) {\n        this.bytesCount -= payload.bytesCount\n      }\n      return payload\n    },\n    size() {\n      return queue.length\n    },\n    isFull() {\n      return this.bytesCount >= MAX_QUEUE_BYTES_COUNT\n    },\n  }\n}\n\nfunction newBandwidthMonitor() {\n  return {\n    ongoingRequestCount: 0,\n    ongoingByteCount: 0,\n    canHandle(payload: Payload) {\n      return (\n        this.ongoingRequestCount === 0 ||\n        (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n          this.ongoingRequestCount < MAX_ONGOING_REQUESTS)\n      )\n    },\n    add(payload: Payload) {\n      this.ongoingRequestCount += 1\n      this.ongoingByteCount += payload.bytesCount\n    },\n    remove(payload: Payload) {\n      this.ongoingRequestCount -= 1\n      this.ongoingByteCount -= payload.bytesCount\n    },\n  }\n}\n","import type { EndpointBuilder } from '../domain/configuration'\nimport { addTelemetryError } from '../domain/telemetry'\nimport type { Context } from '../tools/context'\nimport { monitor } from '../tools/monitor'\nimport type { RawError } from '../tools/error'\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy'\n\n/**\n * Use POST request without content type to:\n * - avoid CORS preflight requests\n * - allow usage of sendBeacon\n *\n * multiple elements are sent separated by \\n in order\n * to be parsed correctly without content type header\n */\n\nexport type HttpRequest = ReturnType<typeof createHttpRequest>\n\nexport interface HttpResponse extends Context {\n  status: number\n}\n\nexport interface Payload {\n  data: string | FormData\n  bytesCount: number\n}\n\nexport function createHttpRequest(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  reportError: (error: RawError) => void\n) {\n  const retryState = newRetryState()\n  const sendStrategyForRetry = (payload: Payload, onResponse: (r: HttpResponse) => void) =>\n    fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse)\n\n  return {\n    send: (payload: Payload) => {\n      sendWithRetryStrategy(payload, retryState, sendStrategyForRetry, endpointBuilder.endpointType, reportError)\n    },\n    /**\n     * Since fetch keepalive behaves like regular fetch on Firefox,\n     * keep using sendBeaconStrategy on exit\n     */\n    sendOnExit: (payload: Payload) => {\n      sendBeaconStrategy(endpointBuilder, bytesLimit, payload)\n    },\n  }\n}\n\nfunction sendBeaconStrategy(endpointBuilder: EndpointBuilder, bytesLimit: number, { data, bytesCount }: Payload) {\n  const url = endpointBuilder.build()\n  const canUseBeacon = !!navigator.sendBeacon && bytesCount < bytesLimit\n  if (canUseBeacon) {\n    try {\n      const isQueued = navigator.sendBeacon(url, data)\n\n      if (isQueued) {\n        return\n      }\n    } catch (e) {\n      reportBeaconError(e)\n    }\n  }\n\n  sendXHR(url, data)\n}\n\nlet hasReportedBeaconError = false\n\nfunction reportBeaconError(e: unknown) {\n  if (!hasReportedBeaconError) {\n    hasReportedBeaconError = true\n    addTelemetryError(e)\n  }\n}\n\nexport function fetchKeepAliveStrategy(\n  endpointBuilder: EndpointBuilder,\n  bytesLimit: number,\n  { data, bytesCount }: Payload,\n  onResponse?: (r: HttpResponse) => void\n) {\n  const url = endpointBuilder.build()\n  const canUseKeepAlive = isKeepAliveSupported() && bytesCount < bytesLimit\n  if (canUseKeepAlive) {\n    fetch(url, { method: 'POST', body: data, keepalive: true }).then(\n      monitor((response: Response) => onResponse?.({ status: response.status })),\n      monitor(() => {\n        // failed to queue the request\n        sendXHR(url, data, onResponse)\n      })\n    )\n  } else {\n    sendXHR(url, data, onResponse)\n  }\n}\n\nfunction isKeepAliveSupported() {\n  // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n  try {\n    return window.Request && 'keepalive' in new Request('http://a')\n  } catch {\n    return false\n  }\n}\n\nexport function sendXHR(url: string, data: Payload['data'], onResponse?: (r: HttpResponse) => void) {\n  const request = new XMLHttpRequest()\n  const onLoadEnd = monitor(() => {\n    // prevent multiple onResponse callbacks\n    // if the xhr instance is reused by a third party\n    request.removeEventListener('loadend', onLoadEnd)\n    onResponse?.({ status: request.status })\n  })\n  request.open('POST', url, true)\n  request.addEventListener('loadend', onLoadEnd)\n  request.send(data)\n}\n","import type { Configuration, EndpointBuilder } from '../domain/configuration'\nimport type { RawError } from '../tools/error'\nimport type { Context } from '../tools/context'\nimport { Batch } from './batch'\nimport { createHttpRequest } from './httpRequest'\n\nexport function startBatchWithReplica<T extends Context>(\n  configuration: Configuration,\n  endpoint: EndpointBuilder,\n  reportError: (error: RawError) => void,\n  replicaEndpoint?: EndpointBuilder\n) {\n  const primaryBatch = createBatch(endpoint)\n  let replicaBatch: Batch | undefined\n  if (replicaEndpoint) {\n    replicaBatch = createBatch(replicaEndpoint)\n  }\n\n  function createBatch(endpointBuilder: EndpointBuilder) {\n    return new Batch(\n      createHttpRequest(endpointBuilder, configuration.batchBytesLimit, reportError),\n      configuration.batchMessagesLimit,\n      configuration.batchBytesLimit,\n      configuration.messageBytesLimit,\n      configuration.flushTimeout\n    )\n  }\n\n  return {\n    add(message: T, replicated = true) {\n      primaryBatch.add(message)\n      if (replicaBatch && replicated) {\n        replicaBatch.add(message)\n      }\n    },\n  }\n}\n","import type { RelativeTime } from './timeUtils'\nimport { relativeNow } from './timeUtils'\nimport type { TimeoutId } from './utils'\nimport { ONE_MINUTE } from './utils'\n\nconst END_OF_TIMES = Infinity as RelativeTime\n\nexport interface ContextHistoryEntry<T> {\n  startTime: RelativeTime\n  endTime: RelativeTime\n  context: T\n  remove(): void\n  close(endTime: RelativeTime): void\n}\n\nexport const CLEAR_OLD_CONTEXTS_INTERVAL = ONE_MINUTE\n\n/**\n * Store and keep track of contexts spans. This whole class assumes that contexts are added in\n * chronological order (i.e. all entries have an increasing start time).\n */\nexport class ContextHistory<Context> {\n  private entries: Array<ContextHistoryEntry<Context>> = []\n  private clearOldContextsInterval: TimeoutId\n\n  constructor(private expireDelay: number) {\n    this.clearOldContextsInterval = setInterval(() => this.clearOldContexts(), CLEAR_OLD_CONTEXTS_INTERVAL)\n  }\n\n  /**\n   * Add a context to the history associated with a start time. Returns a reference to this newly\n   * added entry that can be removed or closed.\n   */\n  add(context: Context, startTime: RelativeTime): ContextHistoryEntry<Context> {\n    const entry: ContextHistoryEntry<Context> = {\n      context,\n      startTime,\n      endTime: END_OF_TIMES,\n      remove: () => {\n        const index = this.entries.indexOf(entry)\n        if (index >= 0) {\n          this.entries.splice(index, 1)\n        }\n      },\n      close: (endTime: RelativeTime) => {\n        entry.endTime = endTime\n      },\n    }\n    this.entries.unshift(entry)\n    return entry\n  }\n\n  /**\n   * Return the latest context that was active during `startTime`, or the currently active context\n   * if no `startTime` is provided. This method assumes that entries are not overlapping.\n   */\n  find(startTime: RelativeTime = END_OF_TIMES): Context | undefined {\n    for (const entry of this.entries) {\n      if (entry.startTime <= startTime) {\n        if (startTime <= entry.endTime) {\n          return entry.context\n        }\n        break\n      }\n    }\n  }\n\n  /**\n   * Helper function to close the currently active context, if any. This method assumes that entries\n   * are not overlapping.\n   */\n  closeActive(endTime: RelativeTime) {\n    const latestEntry = this.entries[0]\n    if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n      latestEntry.close(endTime)\n    }\n  }\n\n  /**\n   * Return all contexts that were active during `startTime`, or all currently active contexts if no\n   * `startTime` is provided.\n   */\n  findAll(startTime: RelativeTime = END_OF_TIMES): Context[] {\n    return this.entries\n      .filter((entry) => entry.startTime <= startTime && startTime <= entry.endTime)\n      .map((entry) => entry.context)\n  }\n\n  /**\n   * Remove all entries from this collection.\n   */\n  reset() {\n    this.entries = []\n  }\n\n  /**\n   * Stop internal garbage collection of past entries.\n   */\n  stop() {\n    clearInterval(this.clearOldContextsInterval)\n  }\n\n  private clearOldContexts() {\n    const oldTimeThreshold = relativeNow() - this.expireDelay\n    while (this.entries.length > 0 && this.entries[this.entries.length - 1].endTime < oldTimeThreshold) {\n      this.entries.pop()\n    }\n  }\n}\n","import { ONE_HOUR, ONE_MINUTE } from '../../tools/utils'\n\nexport const SESSION_TIME_OUT_DELAY = 4 * ONE_HOUR\nexport const SESSION_EXPIRATION_DELAY = 15 * ONE_MINUTE\n","import type { CookieOptions } from '../../browser/cookie'\nimport { getCookie, setCookie } from '../../browser/cookie'\nimport { isChromium } from '../../tools/browserDetection'\nimport { monitor } from '../../tools/monitor'\nimport { dateNow } from '../../tools/timeUtils'\nimport * as utils from '../../tools/utils'\nimport { SESSION_EXPIRATION_DELAY } from './sessionConstants'\nimport type { SessionState } from './sessionStore'\n\nconst SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/\nconst SESSION_ENTRY_SEPARATOR = '&'\n\nexport const SESSION_COOKIE_NAME = '_dd_s'\n\n// arbitrary values\nexport const LOCK_RETRY_DELAY = 10\nexport const MAX_NUMBER_OF_LOCK_RETRIES = 100\n\ntype Operations = {\n  options: CookieOptions\n  process: (cookieSession: SessionState) => SessionState | undefined\n  after?: (cookieSession: SessionState) => void\n}\n\nconst bufferedOperations: Operations[] = []\nlet ongoingOperations: Operations | undefined\n\nexport function withCookieLockAccess(operations: Operations, numberOfRetries = 0) {\n  if (!ongoingOperations) {\n    ongoingOperations = operations\n  }\n  if (operations !== ongoingOperations) {\n    bufferedOperations.push(operations)\n    return\n  }\n  if (numberOfRetries >= MAX_NUMBER_OF_LOCK_RETRIES) {\n    next()\n    return\n  }\n  let currentLock: string\n  let currentSession = retrieveSession()\n  if (isCookieLockEnabled()) {\n    // if someone has lock, retry later\n    if (currentSession.lock) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n    // acquire lock\n    currentLock = utils.generateUUID()\n    currentSession.lock = currentLock\n    setSession(currentSession, operations.options)\n    // if lock is not acquired, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n  }\n  let processedSession = operations.process(currentSession)\n  if (isCookieLockEnabled()) {\n    // if lock corrupted after process, retry later\n    currentSession = retrieveSession()\n    if (currentSession.lock !== currentLock!) {\n      retryLater(operations, numberOfRetries)\n      return\n    }\n  }\n  if (processedSession) {\n    persistSession(processedSession, operations.options)\n  }\n  if (isCookieLockEnabled()) {\n    // correctly handle lock around expiration would require to handle this case properly at several levels\n    // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it\n    if (!(processedSession && isExpiredState(processedSession))) {\n      // if lock corrupted after persist, retry later\n      currentSession = retrieveSession()\n      if (currentSession.lock !== currentLock!) {\n        retryLater(operations, numberOfRetries)\n        return\n      }\n      delete currentSession.lock\n      setSession(currentSession, operations.options)\n      processedSession = currentSession\n    }\n  }\n  // call after even if session is not persisted in order to perform operations on\n  // up-to-date cookie value, the value could have been modified by another tab\n  operations.after?.(processedSession || currentSession)\n  next()\n}\n\n/**\n * Cookie lock strategy allows mitigating issues due to concurrent access to cookie.\n * This issue concerns only chromium browsers and enabling this on firefox increase cookie write failures.\n */\nfunction isCookieLockEnabled() {\n  return isChromium()\n}\n\nfunction retryLater(operations: Operations, currentNumberOfRetries: number) {\n  setTimeout(\n    monitor(() => {\n      withCookieLockAccess(operations, currentNumberOfRetries + 1)\n    }),\n    LOCK_RETRY_DELAY\n  )\n}\n\nfunction next() {\n  ongoingOperations = undefined\n  const nextOperations = bufferedOperations.shift()\n  if (nextOperations) {\n    withCookieLockAccess(nextOperations)\n  }\n}\n\nexport function persistSession(session: SessionState, options: CookieOptions) {\n  if (isExpiredState(session)) {\n    clearSession(options)\n    return\n  }\n  session.expire = String(dateNow() + SESSION_EXPIRATION_DELAY)\n  setSession(session, options)\n}\n\nfunction setSession(session: SessionState, options: CookieOptions) {\n  setCookie(SESSION_COOKIE_NAME, toSessionString(session), SESSION_EXPIRATION_DELAY, options)\n}\n\nexport function toSessionString(session: SessionState) {\n  return utils\n    .objectEntries(session)\n    .map(([key, value]) => `${key}=${value as string}`)\n    .join(SESSION_ENTRY_SEPARATOR)\n}\n\nexport function retrieveSession(): SessionState {\n  const sessionString = getCookie(SESSION_COOKIE_NAME)\n  const session: SessionState = {}\n  if (isValidSessionString(sessionString)) {\n    sessionString.split(SESSION_ENTRY_SEPARATOR).forEach((entry) => {\n      const matches = SESSION_ENTRY_REGEXP.exec(entry)\n      if (matches !== null) {\n        const [, key, value] = matches\n        session[key] = value\n      }\n    })\n  }\n  return session\n}\n\nfunction isValidSessionString(sessionString: string | undefined): sessionString is string {\n  return (\n    sessionString !== undefined &&\n    (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString))\n  )\n}\n\nfunction isExpiredState(session: SessionState) {\n  return utils.isEmptyObject(session)\n}\n\nfunction clearSession(options: CookieOptions) {\n  setCookie(SESSION_COOKIE_NAME, '', 0, options)\n}\n","export function isIE() {\n  return Boolean((document as any).documentMode)\n}\n\nexport function isChromium() {\n  return !!(window as any).chrome || /HeadlessChrome/.test(window.navigator.userAgent)\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport { COOKIE_ACCESS_DELAY } from '../../browser/cookie'\nimport { monitor } from '../../tools/monitor'\nimport { Observable } from '../../tools/observable'\nimport { dateNow } from '../../tools/timeUtils'\nimport * as utils from '../../tools/utils'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\nimport { retrieveSession, withCookieLockAccess } from './sessionCookieStore'\n\nexport interface SessionStore {\n  expandOrRenewSession: () => void\n  expandSession: () => void\n  getSession: () => SessionState\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n  stop: () => void\n}\n\nexport interface SessionState {\n  id?: string\n  created?: string\n  expire?: string\n  lock?: string\n\n  [key: string]: string | undefined\n}\n\n/**\n * Different session concepts:\n * - tracked, the session has an id and is updated along the user navigation\n * - not tracked, the session does not have an id but it is updated along the user navigation\n * - inactive, no session in store or session expired, waiting for a renew session\n */\nexport function startSessionStore<TrackingType extends string>(\n  options: CookieOptions,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionStore {\n  const renewObservable = new Observable<void>()\n  const expireObservable = new Observable<void>()\n\n  const watchSessionTimeoutId = setInterval(monitor(watchSession), COOKIE_ACCESS_DELAY)\n  let sessionCache: SessionState = retrieveActiveSession()\n\n  function expandOrRenewSession() {\n    let isTracked: boolean\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => {\n        const synchronizedSession = synchronizeSession(cookieSession)\n        isTracked = expandOrRenewCookie(synchronizedSession)\n        return synchronizedSession\n      },\n      after: (cookieSession) => {\n        if (isTracked && !hasSessionInCache()) {\n          renewSession(cookieSession)\n        }\n        sessionCache = cookieSession\n      },\n    })\n  }\n\n  function expandSession() {\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => (hasSessionInCache() ? synchronizeSession(cookieSession) : undefined),\n    })\n  }\n\n  /**\n   * allows two behaviors:\n   * - if the session is active, synchronize the session cache without updating the session cookie\n   * - if the session is not active, clear the session cookie and expire the session cache\n   */\n  function watchSession() {\n    withCookieLockAccess({\n      options,\n      process: (cookieSession) => (!isActiveSession(cookieSession) ? {} : undefined),\n      after: synchronizeSession,\n    })\n  }\n\n  function synchronizeSession(cookieSession: SessionState) {\n    if (!isActiveSession(cookieSession)) {\n      cookieSession = {}\n    }\n    if (hasSessionInCache()) {\n      if (isSessionInCacheOutdated(cookieSession)) {\n        expireSession()\n      } else {\n        sessionCache = cookieSession\n      }\n    }\n    return cookieSession\n  }\n\n  function expandOrRenewCookie(cookieSession: SessionState) {\n    const { trackingType, isTracked } = computeSessionState(cookieSession[productKey])\n    cookieSession[productKey] = trackingType\n    if (isTracked && !cookieSession.id) {\n      cookieSession.id = utils.generateUUID()\n      cookieSession.created = String(dateNow())\n    }\n    return isTracked\n  }\n\n  function hasSessionInCache() {\n    return sessionCache[productKey] !== undefined\n  }\n\n  function isSessionInCacheOutdated(cookieSession: SessionState) {\n    return sessionCache.id !== cookieSession.id || sessionCache[productKey] !== cookieSession[productKey]\n  }\n\n  function expireSession() {\n    sessionCache = {}\n    expireObservable.notify()\n  }\n\n  function renewSession(cookieSession: SessionState) {\n    sessionCache = cookieSession\n    renewObservable.notify()\n  }\n\n  function retrieveActiveSession(): SessionState {\n    const session = retrieveSession()\n    if (isActiveSession(session)) {\n      return session\n    }\n    return {}\n  }\n\n  function isActiveSession(session: SessionState) {\n    // created and expire can be undefined for versions which was not storing them\n    // these checks could be removed when older versions will not be available/live anymore\n    return (\n      (session.created === undefined || dateNow() - Number(session.created) < SESSION_TIME_OUT_DELAY) &&\n      (session.expire === undefined || dateNow() < Number(session.expire))\n    )\n  }\n\n  return {\n    expandOrRenewSession: utils.throttle(monitor(expandOrRenewSession), COOKIE_ACCESS_DELAY).throttled,\n    expandSession,\n    getSession: () => sessionCache,\n    renewObservable,\n    expireObservable,\n    stop: () => {\n      clearInterval(watchSessionTimeoutId)\n    },\n  }\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport type { Observable } from '../../tools/observable'\nimport * as utils from '../../tools/utils'\nimport type { Context } from '../../tools/context'\nimport { ContextHistory } from '../../tools/contextHistory'\nimport type { RelativeTime } from '../../tools/timeUtils'\nimport { relativeNow, clocksOrigin } from '../../tools/timeUtils'\nimport { monitor } from '../../tools/monitor'\nimport { tryOldCookiesMigration } from './oldCookiesMigration'\nimport { startSessionStore } from './sessionStore'\nimport { SESSION_TIME_OUT_DELAY } from './sessionConstants'\n\nexport interface SessionManager<TrackingType extends string> {\n  findActiveSession: (startTime?: RelativeTime) => SessionContext<TrackingType> | undefined\n  renewObservable: Observable<void>\n  expireObservable: Observable<void>\n}\n\nexport interface SessionContext<TrackingType extends string> extends Context {\n  id: string\n  trackingType: TrackingType\n}\n\nexport const VISIBILITY_CHECK_DELAY = utils.ONE_MINUTE\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY\nlet stopCallbacks: Array<() => void> = []\n\nexport function startSessionManager<TrackingType extends string>(\n  options: CookieOptions,\n  productKey: string,\n  computeSessionState: (rawTrackingType?: string) => { trackingType: TrackingType; isTracked: boolean }\n): SessionManager<TrackingType> {\n  tryOldCookiesMigration(options)\n  const sessionStore = startSessionStore(options, productKey, computeSessionState)\n  stopCallbacks.push(() => sessionStore.stop())\n\n  const sessionContextHistory = new ContextHistory<SessionContext<TrackingType>>(SESSION_CONTEXT_TIMEOUT_DELAY)\n  stopCallbacks.push(() => sessionContextHistory.stop())\n\n  sessionStore.renewObservable.subscribe(() => {\n    sessionContextHistory.add(buildSessionContext(), relativeNow())\n  })\n  sessionStore.expireObservable.subscribe(() => {\n    sessionContextHistory.closeActive(relativeNow())\n  })\n\n  sessionStore.expandOrRenewSession()\n  sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative)\n\n  trackActivity(() => sessionStore.expandOrRenewSession())\n  trackVisibility(() => sessionStore.expandSession())\n\n  function buildSessionContext() {\n    return {\n      id: sessionStore.getSession().id!,\n      trackingType: sessionStore.getSession()[productKey] as TrackingType,\n    }\n  }\n\n  return {\n    findActiveSession: (startTime) => sessionContextHistory.find(startTime),\n    renewObservable: sessionStore.renewObservable,\n    expireObservable: sessionStore.expireObservable,\n  }\n}\n\nexport function stopSessionManager() {\n  stopCallbacks.forEach((e) => e())\n  stopCallbacks = []\n}\n\nfunction trackActivity(expandOrRenewSession: () => void) {\n  const { stop } = utils.addEventListeners(\n    window,\n    [utils.DOM_EVENT.CLICK, utils.DOM_EVENT.TOUCH_START, utils.DOM_EVENT.KEY_DOWN, utils.DOM_EVENT.SCROLL],\n    expandOrRenewSession,\n    { capture: true, passive: true }\n  )\n  stopCallbacks.push(stop)\n}\n\nfunction trackVisibility(expandSession: () => void) {\n  const expandSessionWhenVisible = monitor(() => {\n    if (document.visibilityState === 'visible') {\n      expandSession()\n    }\n  })\n\n  const { stop } = utils.addEventListener(document, utils.DOM_EVENT.VISIBILITY_CHANGE, expandSessionWhenVisible)\n  stopCallbacks.push(stop)\n\n  const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY)\n  stopCallbacks.push(() => {\n    clearInterval(visibilityCheckInterval)\n  })\n}\n","import type { CookieOptions } from '../../browser/cookie'\nimport { getCookie } from '../../browser/cookie'\nimport type { SessionState } from './sessionStore'\nimport { SESSION_COOKIE_NAME, persistSession } from './sessionCookieStore'\n\nexport const OLD_SESSION_COOKIE_NAME = '_dd'\nexport const OLD_RUM_COOKIE_NAME = '_dd_r'\nexport const OLD_LOGS_COOKIE_NAME = '_dd_l'\n\n// duplicate values to avoid dependency issues\nexport const RUM_SESSION_KEY = 'rum'\nexport const LOGS_SESSION_KEY = 'logs'\n\n/**\n * This migration should remain in the codebase as long as older versions are available/live\n * to allow older sdk versions to be upgraded to newer versions without compatibility issues.\n */\nexport function tryOldCookiesMigration(options: CookieOptions) {\n  const sessionString = getCookie(SESSION_COOKIE_NAME)\n  const oldSessionId = getCookie(OLD_SESSION_COOKIE_NAME)\n  const oldRumType = getCookie(OLD_RUM_COOKIE_NAME)\n  const oldLogsType = getCookie(OLD_LOGS_COOKIE_NAME)\n  if (!sessionString) {\n    const session: SessionState = {}\n    if (oldSessionId) {\n      session.id = oldSessionId\n    }\n    if (oldLogsType && /^[01]$/.test(oldLogsType)) {\n      session[LOGS_SESSION_KEY] = oldLogsType\n    }\n    if (oldRumType && /^[012]$/.test(oldRumType)) {\n      session[RUM_SESSION_KEY] = oldRumType\n    }\n    persistSession(session, options)\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport { performDraw, startSessionManager } from '@datadog/browser-core'\nimport type { LogsConfiguration } from './configuration'\n\nexport const LOGS_SESSION_KEY = 'logs'\n\nexport interface LogsSessionManager {\n  findTrackedSession: (startTime?: RelativeTime) => LogsSession | undefined\n}\n\nexport type LogsSession = {\n  id?: string // session can be tracked without id\n}\n\nexport const enum LoggerTrackingType {\n  NOT_TRACKED = '0',\n  TRACKED = '1',\n}\n\nexport function startLogsSessionManager(configuration: LogsConfiguration): LogsSessionManager {\n  const sessionManager = startSessionManager(configuration.cookieOptions, LOGS_SESSION_KEY, (rawTrackingType) =>\n    computeSessionState(configuration, rawTrackingType)\n  )\n  return {\n    findTrackedSession: (startTime) => {\n      const session = sessionManager.findActiveSession(startTime)\n      return session && session.trackingType === LoggerTrackingType.TRACKED\n        ? {\n            id: session.id,\n          }\n        : undefined\n    },\n  }\n}\n\nexport function startLogsSessionManagerStub(configuration: LogsConfiguration): LogsSessionManager {\n  const isTracked = computeTrackingType(configuration) === LoggerTrackingType.TRACKED\n  const session = isTracked ? {} : undefined\n  return {\n    findTrackedSession: () => session,\n  }\n}\n\nfunction computeTrackingType(configuration: LogsConfiguration) {\n  if (!performDraw(configuration.sampleRate)) {\n    return LoggerTrackingType.NOT_TRACKED\n  }\n  return LoggerTrackingType.TRACKED\n}\n\nfunction computeSessionState(configuration: LogsConfiguration, rawSessionType?: string) {\n  const trackingType = hasValidLoggerSession(rawSessionType) ? rawSessionType : computeTrackingType(configuration)\n  return {\n    trackingType,\n    isTracked: trackingType === LoggerTrackingType.TRACKED,\n  }\n}\n\nfunction hasValidLoggerSession(trackingType?: string): trackingType is LoggerTrackingType {\n  return trackingType === LoggerTrackingType.NOT_TRACKED || trackingType === LoggerTrackingType.TRACKED\n}\n","import type { TimeStamp } from '@datadog/browser-core'\nimport { includes, display, combine, ErrorSource, timeStampNow } from '@datadog/browser-core'\nimport type { CommonContext, RawLoggerLogsEvent } from '../../../rawLogsEvent.types'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport type { Logger, LogsMessage } from '../../logger'\nimport { StatusType, HandlerType } from '../../logger'\n\nexport const STATUS_PRIORITIES: { [key in StatusType]: number } = {\n  [StatusType.debug]: 0,\n  [StatusType.info]: 1,\n  [StatusType.warn]: 2,\n  [StatusType.error]: 3,\n}\n\nexport function startLoggerCollection(lifeCycle: LifeCycle) {\n  function handleLog(\n    logsMessage: LogsMessage,\n    logger: Logger,\n    savedCommonContext?: CommonContext,\n    savedDate?: TimeStamp\n  ) {\n    const messageContext = logsMessage.context\n\n    if (isAuthorized(logsMessage.status, HandlerType.console, logger)) {\n      display(logsMessage.status, logsMessage.message, combine(logger.getContext(), messageContext))\n    }\n\n    lifeCycle.notify<RawLoggerLogsEvent>(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        date: savedDate || timeStampNow(),\n        message: logsMessage.message,\n        status: logsMessage.status,\n        origin: ErrorSource.LOGGER,\n      },\n      messageContext,\n      savedCommonContext,\n      logger,\n    })\n  }\n\n  return {\n    handleLog,\n  }\n}\n\nexport function isAuthorized(status: StatusType, handlerType: HandlerType, logger: Logger) {\n  const loggerHandler = logger.getHandler()\n  const sanitizedHandlerType = Array.isArray(loggerHandler) ? loggerHandler : [loggerHandler]\n  return (\n    STATUS_PRIORITIES[status] >= STATUS_PRIORITIES[logger.getLevel()] && includes(sanitizedHandlerType, handlerType)\n  )\n}\n","import type { Context, EventRateLimiter, RawError, RelativeTime } from '@datadog/browser-core'\nimport {\n  getSyntheticsResultId,\n  getSyntheticsTestId,\n  addTelemetryDebug,\n  willSyntheticsInjectRum,\n  ErrorSource,\n  combine,\n  createEventRateLimiter,\n  getRelativeTime,\n} from '@datadog/browser-core'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport type { LogsConfiguration } from './configuration'\nimport type { LifeCycle } from './lifeCycle'\nimport { LifeCycleEventType } from './lifeCycle'\nimport type { Logger } from './logger'\nimport { STATUSES, HandlerType } from './logger'\nimport { isAuthorized } from './logsCollection/logger/loggerCollection'\nimport type { LogsSessionManager } from './logsSessionManager'\n\nexport function startLogsAssembly(\n  sessionManager: LogsSessionManager,\n  configuration: LogsConfiguration,\n  lifeCycle: LifeCycle,\n  getCommonContext: () => CommonContext,\n  mainLogger: Logger, // Todo: [RUMF-1230] Remove this parameter in the next major release\n  reportError: (error: RawError) => void\n) {\n  const statusWithCustom = (STATUSES as string[]).concat(['custom'])\n  const logRateLimiters: { [key: string]: EventRateLimiter } = {}\n  statusWithCustom.forEach((status) => {\n    logRateLimiters[status] = createEventRateLimiter(status, configuration.eventRateLimiterThreshold, reportError)\n  })\n\n  lifeCycle.subscribe(\n    LifeCycleEventType.RAW_LOG_COLLECTED,\n    ({ rawLogsEvent, messageContext = undefined, savedCommonContext = undefined, logger = mainLogger }) => {\n      const startTime = getRelativeTime(rawLogsEvent.date)\n      const session = sessionManager.findTrackedSession(startTime)\n\n      if (!session) {\n        return\n      }\n\n      const commonContext = savedCommonContext || getCommonContext()\n      const log = combine(\n        { service: configuration.service, session_id: session.id, view: commonContext.view },\n        commonContext.context,\n        getRUMInternalContext(startTime),\n        rawLogsEvent,\n        logger.getContext(),\n        messageContext\n      )\n\n      if (\n        // Todo: [RUMF-1230] Move this check to the logger collection in the next major release\n        !isAuthorized(rawLogsEvent.status, HandlerType.http, logger) ||\n        configuration.beforeSend?.(log) === false ||\n        (log.error?.origin !== ErrorSource.AGENT &&\n          (logRateLimiters[log.status] ?? logRateLimiters['custom']).isLimitReached())\n      ) {\n        return\n      }\n\n      lifeCycle.notify(LifeCycleEventType.LOG_COLLECTED, log)\n    }\n  )\n}\n\ninterface Rum {\n  getInternalContext?: (startTime?: RelativeTime) => Context | undefined\n}\n\ninterface BrowserWindow {\n  DD_RUM?: Rum\n  DD_RUM_SYNTHETICS?: Rum\n}\n\nlet logsSentBeforeRumInjectionTelemetryAdded = false\n\nexport function getRUMInternalContext(startTime?: RelativeTime): Context | undefined {\n  const browserWindow = window as BrowserWindow\n\n  if (willSyntheticsInjectRum()) {\n    const context = getInternalContextFromRumGlobal(browserWindow.DD_RUM_SYNTHETICS)\n    if (!context && !logsSentBeforeRumInjectionTelemetryAdded) {\n      logsSentBeforeRumInjectionTelemetryAdded = true\n      addTelemetryDebug('Logs sent before RUM is injected by the synthetics worker', {\n        testId: getSyntheticsTestId(),\n        resultId: getSyntheticsResultId(),\n      })\n    }\n    return context\n  }\n\n  return getInternalContextFromRumGlobal(browserWindow.DD_RUM)\n\n  function getInternalContextFromRumGlobal(rumGlobal?: Rum): Context | undefined {\n    if (rumGlobal && rumGlobal.getInternalContext) {\n      return rumGlobal.getInternalContext(startTime)\n    }\n  }\n}\n\nexport function resetRUMInternalContext() {\n  logsSentBeforeRumInjectionTelemetryAdded = false\n}\n","import type { RawError } from './error'\nimport { ErrorSource } from './error'\nimport { clocksNow } from './timeUtils'\nimport { ONE_MINUTE } from './utils'\n\nexport type EventRateLimiter = ReturnType<typeof createEventRateLimiter>\n\nexport function createEventRateLimiter(\n  eventType: string,\n  limit: number,\n  onLimitReached: (limitError: RawError) => void\n) {\n  let eventCount = 0\n  let allowNextEvent = false\n\n  return {\n    isLimitReached() {\n      if (eventCount === 0) {\n        setTimeout(() => {\n          eventCount = 0\n        }, ONE_MINUTE)\n      }\n\n      eventCount += 1\n      if (eventCount <= limit || allowNextEvent) {\n        allowNextEvent = false\n        return false\n      }\n\n      if (eventCount === limit + 1) {\n        allowNextEvent = true\n        try {\n          onLimitReached({\n            message: `Reached max number of ${eventType}s by minute: ${limit}`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n          })\n        } finally {\n          allowNextEvent = false\n        }\n      }\n\n      return true\n    },\n  }\n}\n","import { computeStackTrace } from '../tracekit'\nimport { createHandlingStack, formatErrorMessage, toStackTraceString } from '../../tools/error'\nimport { mergeObservables, Observable } from '../../tools/observable'\nimport { find, jsonStringify } from '../../tools/utils'\nimport { ConsoleApiName } from '../../tools/display'\nimport { callMonitored } from '../../tools/monitor'\n\nexport interface ConsoleLog {\n  message: string\n  api: ConsoleApiName\n  stack?: string\n  handlingStack?: string\n}\n\nconst consoleObservablesByApi: { [k in ConsoleApiName]?: Observable<ConsoleLog> } = {}\n\nexport function initConsoleObservable(apis: ConsoleApiName[]) {\n  const consoleObservables = apis.map((api) => {\n    if (!consoleObservablesByApi[api]) {\n      consoleObservablesByApi[api] = createConsoleObservable(api)\n    }\n    return consoleObservablesByApi[api]!\n  })\n\n  return mergeObservables<ConsoleLog>(...consoleObservables)\n}\n\n/* eslint-disable no-console */\nfunction createConsoleObservable(api: ConsoleApiName) {\n  const observable = new Observable<ConsoleLog>(() => {\n    const originalConsoleApi = console[api]\n\n    console[api] = (...params: unknown[]) => {\n      originalConsoleApi.apply(console, params)\n      const handlingStack = createHandlingStack()\n\n      callMonitored(() => {\n        observable.notify(buildConsoleLog(params, api, handlingStack))\n      })\n    }\n\n    return () => {\n      console[api] = originalConsoleApi\n    }\n  })\n\n  return observable\n}\n\nfunction buildConsoleLog(params: unknown[], api: ConsoleApiName, handlingStack: string): ConsoleLog {\n  // Todo: remove console error prefix in the next major version\n  let message = params.map((param) => formatConsoleParameters(param)).join(' ')\n  let stack\n\n  if (api === ConsoleApiName.error) {\n    const firstErrorParam = find(params, (param: unknown): param is Error => param instanceof Error)\n    stack = firstErrorParam ? toStackTraceString(computeStackTrace(firstErrorParam)) : undefined\n    message = `console error: ${message}`\n  }\n\n  return {\n    api,\n    message,\n    stack,\n    handlingStack,\n  }\n}\n\nfunction formatConsoleParameters(param: unknown) {\n  if (typeof param === 'string') {\n    return param\n  }\n  if (param instanceof Error) {\n    return formatErrorMessage(computeStackTrace(param))\n  }\n  return jsonStringify(param, 2)\n}\n","import type { Context, ClocksState, ConsoleLog } from '@datadog/browser-core'\nimport { timeStampNow, ConsoleApiName, ErrorSource, initConsoleObservable } from '@datadog/browser-core'\nimport type { RawConsoleLogsEvent } from '../../../rawLogsEvent.types'\nimport type { LogsConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { StatusType } from '../../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nconst LogStatusForApi = {\n  [ConsoleApiName.log]: StatusType.info,\n  [ConsoleApiName.debug]: StatusType.debug,\n  [ConsoleApiName.info]: StatusType.info,\n  [ConsoleApiName.warn]: StatusType.warn,\n  [ConsoleApiName.error]: StatusType.error,\n}\nexport function startConsoleCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  const consoleSubscription = initConsoleObservable(configuration.forwardConsoleLogs).subscribe((log: ConsoleLog) => {\n    lifeCycle.notify<RawConsoleLogsEvent>(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        date: timeStampNow(),\n        message: log.message,\n        origin: ErrorSource.CONSOLE,\n        error:\n          log.api === ConsoleApiName.error\n            ? {\n                origin: ErrorSource.CONSOLE, // Todo: Remove in the next major release\n                stack: log.stack,\n              }\n            : undefined,\n        status: LogStatusForApi[log.api],\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      consoleSubscription.unsubscribe()\n    },\n  }\n}\n","import type { Context, ClocksState, RawReport } from '@datadog/browser-core'\nimport {\n  timeStampNow,\n  ErrorSource,\n  RawReportType,\n  getFileFromStackTraceString,\n  initReportObservable,\n} from '@datadog/browser-core'\nimport type { RawReportLogsEvent } from '../../../rawLogsEvent.types'\nimport type { LogsConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { StatusType } from '../../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nconst LogStatusForReport = {\n  [RawReportType.cspViolation]: StatusType.error,\n  [RawReportType.intervention]: StatusType.error,\n  [RawReportType.deprecation]: StatusType.warn,\n}\n\nexport function startReportCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  const reportSubscription = initReportObservable(configuration.forwardReports).subscribe((report: RawReport) => {\n    let message = report.message\n    const status = LogStatusForReport[report.type]\n    let error\n    if (status === StatusType.error) {\n      error = {\n        kind: report.subtype,\n        origin: ErrorSource.REPORT, // Todo: Remove in the next major release\n        stack: report.stack,\n      }\n    } else if (report.stack) {\n      message += ` Found in ${getFileFromStackTraceString(report.stack)!}`\n    }\n\n    lifeCycle.notify<RawReportLogsEvent>(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        date: timeStampNow(),\n        message,\n        origin: ErrorSource.REPORT,\n        error,\n        status,\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      reportSubscription.unsubscribe()\n    },\n  }\n}\n","import { instrumentMethodAndCallOriginal } from '../tools/instrumentMethod'\nimport { monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { Duration, RelativeTime, ClocksState } from '../tools/timeUtils'\nimport { elapsed, relativeNow, clocksNow, timeStampNow } from '../tools/timeUtils'\nimport { normalizeUrl } from '../tools/urlPolyfill'\nimport { shallowClone } from '../tools/utils'\n\nexport interface XhrOpenContext {\n  state: 'open'\n  method: string\n  url: string\n}\n\nexport interface XhrStartContext extends Omit<XhrOpenContext, 'state'> {\n  state: 'start'\n  startTime: RelativeTime // deprecated\n  startClocks: ClocksState\n  isAborted: boolean\n  xhr: XMLHttpRequest\n}\n\nexport interface XhrCompleteContext extends Omit<XhrStartContext, 'state'> {\n  state: 'complete'\n  duration: Duration\n  status: number\n}\n\nexport type XhrContext = XhrOpenContext | XhrStartContext | XhrCompleteContext\n\nlet xhrObservable: Observable<XhrContext> | undefined\nconst xhrContexts = new WeakMap<XMLHttpRequest, XhrContext>()\n\nexport function initXhrObservable() {\n  if (!xhrObservable) {\n    xhrObservable = createXhrObservable()\n  }\n  return xhrObservable\n}\n\nfunction createXhrObservable() {\n  const observable = new Observable<XhrContext>(() => {\n    const { stop: stopInstrumentingStart } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'open', {\n      before: openXhr,\n    })\n\n    const { stop: stopInstrumentingSend } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'send', {\n      before() {\n        sendXhr.call(this, observable)\n      },\n    })\n\n    const { stop: stopInstrumentingAbort } = instrumentMethodAndCallOriginal(XMLHttpRequest.prototype, 'abort', {\n      before: abortXhr,\n    })\n\n    return () => {\n      stopInstrumentingStart()\n      stopInstrumentingSend()\n      stopInstrumentingAbort()\n    }\n  })\n  return observable\n}\n\nfunction openXhr(this: XMLHttpRequest, method: string, url: string | URL | undefined | null) {\n  xhrContexts.set(this, {\n    state: 'open',\n    method,\n    url: normalizeUrl(String(url)),\n  })\n}\n\nfunction sendXhr(this: XMLHttpRequest, observable: Observable<XhrContext>) {\n  const context = xhrContexts.get(this)\n  if (!context) {\n    return\n  }\n\n  const startContext = context as XhrStartContext\n  startContext.state = 'start'\n  startContext.startTime = relativeNow()\n  startContext.startClocks = clocksNow()\n  startContext.isAborted = false\n  startContext.xhr = this\n\n  let hasBeenReported = false\n\n  const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethodAndCallOriginal(this, 'onreadystatechange', {\n    before() {\n      if (this.readyState === XMLHttpRequest.DONE) {\n        // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n        // application during a future event. For example, Angular is calling .abort() on\n        // completed requests during a onreadystatechange event, so the status becomes '0'\n        // before the request is collected.\n        onEnd()\n      }\n    },\n  })\n\n  const onEnd = monitor(() => {\n    this.removeEventListener('loadend', onEnd)\n    stopInstrumentingOnReadyStateChange()\n    if (hasBeenReported) {\n      return\n    }\n    hasBeenReported = true\n\n    const completeContext = context as XhrCompleteContext\n    completeContext.state = 'complete'\n    completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow())\n    completeContext.status = this.status\n    observable.notify(shallowClone(completeContext))\n  })\n  this.addEventListener('loadend', onEnd)\n  observable.notify(startContext)\n}\n\nfunction abortXhr(this: XMLHttpRequest) {\n  const context = xhrContexts.get(this) as XhrStartContext | undefined\n  if (context) {\n    context.isAborted = true\n  }\n}\n","import { callMonitored, monitor } from './monitor'\nimport { noop } from './utils'\n\nexport function instrumentMethod<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  instrumentationFactory: (\n    original: OBJECT[METHOD]\n  ) => (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => ReturnType<OBJECT[METHOD]>\n) {\n  const original = object[method]\n\n  let instrumentation = instrumentationFactory(original)\n\n  const instrumentationWrapper = function (this: OBJECT): ReturnType<OBJECT[METHOD]> | undefined {\n    if (typeof instrumentation !== 'function') {\n      return undefined\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return instrumentation.apply(this, arguments as unknown as Parameters<OBJECT[METHOD]>)\n  }\n  object[method] = instrumentationWrapper as OBJECT[METHOD]\n\n  return {\n    stop: () => {\n      if (object[method] === instrumentationWrapper) {\n        object[method] = original\n      } else {\n        instrumentation = original\n      }\n    },\n  }\n}\n\nexport function instrumentMethodAndCallOriginal<OBJECT extends { [key: string]: any }, METHOD extends keyof OBJECT>(\n  object: OBJECT,\n  method: METHOD,\n  {\n    before,\n    after,\n  }: {\n    before?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n    after?: (this: OBJECT, ...args: Parameters<OBJECT[METHOD]>) => void\n  }\n) {\n  return instrumentMethod(\n    object,\n    method,\n    (original) =>\n      function () {\n        const args = arguments as unknown as Parameters<OBJECT[METHOD]>\n        let result\n\n        if (before) {\n          callMonitored(before, this as ThisParameterType<OBJECT[METHOD]>, args)\n        }\n\n        if (typeof original === 'function') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          result = original.apply(this, args)\n        }\n\n        if (after) {\n          callMonitored(after, this as ThisParameterType<OBJECT[METHOD]>, args)\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result\n      }\n  )\n}\n\nexport function instrumentSetter<OBJECT extends { [key: string]: any }, PROPERTY extends keyof OBJECT>(\n  object: OBJECT,\n  property: PROPERTY,\n  after: (thisObject: OBJECT, value: OBJECT[PROPERTY]) => void\n) {\n  const originalDescriptor = Object.getOwnPropertyDescriptor(object, property)\n  if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n    return { stop: noop }\n  }\n\n  let instrumentation = (thisObject: OBJECT, value: OBJECT[PROPERTY]) => {\n    // put hooked setter into event loop to avoid of set latency\n    setTimeout(\n      monitor(() => {\n        after(thisObject, value)\n      }),\n      0\n    )\n  }\n\n  const instrumentationWrapper = function (this: OBJECT, value: OBJECT[PROPERTY]) {\n    originalDescriptor.set!.call(this, value)\n    instrumentation(this, value)\n  }\n\n  Object.defineProperty(object, property, {\n    set: instrumentationWrapper,\n  })\n\n  return {\n    stop: () => {\n      if (Object.getOwnPropertyDescriptor(object, property)?.set === instrumentationWrapper) {\n        Object.defineProperty(object, property, originalDescriptor)\n      } else {\n        instrumentation = noop\n      }\n    },\n  }\n}\n","import { instrumentMethod } from '../tools/instrumentMethod'\nimport { callMonitored, monitor } from '../tools/monitor'\nimport { Observable } from '../tools/observable'\nimport type { Duration, ClocksState } from '../tools/timeUtils'\nimport { elapsed, clocksNow, timeStampNow } from '../tools/timeUtils'\nimport { normalizeUrl } from '../tools/urlPolyfill'\n\ninterface FetchContextBase {\n  method: string\n  startClocks: ClocksState\n  input: RequestInfo\n  init?: RequestInit\n  url: string\n}\n\nexport interface FetchStartContext extends FetchContextBase {\n  state: 'start'\n}\n\nexport interface FetchCompleteContext extends FetchContextBase {\n  state: 'complete'\n  duration: Duration\n  status: number\n  response?: Response\n  responseType?: string\n  isAborted: boolean\n  error?: Error\n}\n\nexport type FetchContext = FetchStartContext | FetchCompleteContext\n\nlet fetchObservable: Observable<FetchContext> | undefined\n\nexport function initFetchObservable() {\n  if (!fetchObservable) {\n    fetchObservable = createFetchObservable()\n  }\n  return fetchObservable\n}\n\nfunction createFetchObservable() {\n  const observable = new Observable<FetchContext>(() => {\n    if (!window.fetch) {\n      return\n    }\n\n    const { stop } = instrumentMethod(\n      window,\n      'fetch',\n      (originalFetch) =>\n        function (input, init) {\n          let responsePromise: Promise<Response>\n\n          const context = callMonitored(beforeSend, null, [observable, input, init])\n          if (context) {\n            responsePromise = originalFetch.call(this, context.input, context.init)\n            callMonitored(afterSend, null, [observable, responsePromise, context])\n          } else {\n            responsePromise = originalFetch.call(this, input, init)\n          }\n\n          return responsePromise\n        }\n    )\n\n    return stop\n  })\n\n  return observable\n}\n\nfunction beforeSend(observable: Observable<FetchContext>, input: RequestInfo, init?: RequestInit) {\n  const method = (init && init.method) || (typeof input === 'object' && input.method) || 'GET'\n  const url = normalizeUrl((typeof input === 'object' && input.url) || (input as string))\n  const startClocks = clocksNow()\n\n  const context: FetchStartContext = {\n    state: 'start',\n    init,\n    input,\n    method,\n    startClocks,\n    url,\n  }\n\n  observable.notify(context)\n\n  return context\n}\n\nfunction afterSend(\n  observable: Observable<FetchContext>,\n  responsePromise: Promise<Response>,\n  startContext: FetchStartContext\n) {\n  const reportFetch = (response: Response | Error) => {\n    const context = startContext as unknown as FetchCompleteContext\n    context.state = 'complete'\n    context.duration = elapsed(context.startClocks.timeStamp, timeStampNow())\n\n    if ('stack' in response || response instanceof Error) {\n      context.status = 0\n      context.isAborted = response instanceof DOMException && response.code === DOMException.ABORT_ERR\n      context.error = response\n\n      observable.notify(context)\n    } else if ('status' in response) {\n      context.response = response\n      context.responseType = response.type\n      context.status = response.status\n      context.isAborted = false\n\n      observable.notify(context)\n    }\n  }\n  responsePromise.then(monitor(reportFetch), monitor(reportFetch))\n}\n","import type { FetchCompleteContext, XhrCompleteContext } from '@datadog/browser-core'\nimport {\n  ErrorSource,\n  initXhrObservable,\n  RequestType,\n  initFetchObservable,\n  computeStackTrace,\n  toStackTraceString,\n  monitor,\n  noop,\n} from '@datadog/browser-core'\nimport type { RawNetworkLogsEvent } from '../../../rawLogsEvent.types'\nimport type { LogsConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { StatusType } from '../../logger'\n\nexport function startNetworkErrorCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  if (!configuration.forwardErrorsToLogs) {\n    return { stop: noop }\n  }\n\n  const xhrSubscription = initXhrObservable().subscribe((context) => {\n    if (context.state === 'complete') {\n      handleCompleteRequest(RequestType.XHR, context)\n    }\n  })\n  const fetchSubscription = initFetchObservable().subscribe((context) => {\n    if (context.state === 'complete') {\n      handleCompleteRequest(RequestType.FETCH, context)\n    }\n  })\n\n  function handleCompleteRequest(type: RequestType, request: XhrCompleteContext | FetchCompleteContext) {\n    if (!configuration.isIntakeUrl(request.url) && (isRejected(request) || isServerError(request))) {\n      if ('xhr' in request) {\n        computeXhrResponseData(request.xhr, configuration, onResponseDataAvailable)\n      } else if (request.response) {\n        computeFetchResponseText(request.response, configuration, onResponseDataAvailable)\n      } else if (request.error) {\n        computeFetchErrorText(request.error, configuration, onResponseDataAvailable)\n      }\n    }\n\n    function onResponseDataAvailable(responseData: unknown) {\n      lifeCycle.notify<RawNetworkLogsEvent>(LifeCycleEventType.RAW_LOG_COLLECTED, {\n        rawLogsEvent: {\n          message: `${format(type)} error ${request.method} ${request.url}`,\n          date: request.startClocks.timeStamp,\n          error: {\n            origin: ErrorSource.NETWORK, // Todo: Remove in the next major release\n            stack: (responseData as string) || 'Failed to load',\n          },\n          http: {\n            method: request.method as any, // Cast resource method because of case mismatch cf issue RUMF-1152\n            status_code: request.status,\n            url: request.url,\n          },\n          status: StatusType.error,\n          origin: ErrorSource.NETWORK,\n        },\n      })\n    }\n  }\n\n  return {\n    stop: () => {\n      xhrSubscription.unsubscribe()\n      fetchSubscription.unsubscribe()\n    },\n  }\n}\n\n// TODO: ideally, computeXhrResponseData should always call the callback with a string instead of\n// `unknown`. But to keep backward compatibility, in the case of XHR with a `responseType` different\n// than \"text\", the response data should be whatever `xhr.response` is. This is a bit confusing as\n// Logs event 'stack' is expected to be a string. This should be changed in a future major version\n// as it could be a breaking change.\nexport function computeXhrResponseData(\n  xhr: XMLHttpRequest,\n  configuration: LogsConfiguration,\n  callback: (responseData: unknown) => void\n) {\n  if (typeof xhr.response === 'string') {\n    callback(truncateResponseText(xhr.response, configuration))\n  } else {\n    callback(xhr.response)\n  }\n}\n\nexport function computeFetchErrorText(\n  error: Error,\n  configuration: LogsConfiguration,\n  callback: (errorText: string) => void\n) {\n  callback(truncateResponseText(toStackTraceString(computeStackTrace(error)), configuration))\n}\n\nexport function computeFetchResponseText(\n  response: Response,\n  configuration: LogsConfiguration,\n  callback: (responseText?: string) => void\n) {\n  if (!window.TextDecoder) {\n    // If the browser doesn't support TextDecoder, let's read the whole response then truncate it.\n    //\n    // This should only be the case on early versions of Edge (before they migrated to Chromium).\n    // Even if it could be possible to implement a workaround for the missing TextDecoder API (using\n    // a Blob and FileReader), we found another issue preventing us from reading only the first\n    // bytes from the response: contrary to other browsers, when reading from the cloned response,\n    // if the original response gets canceled, the cloned response is also canceled and we can't\n    // know about it.  In the following illustration, the promise returned by `reader.read()` may\n    // never be fulfilled:\n    //\n    // fetch('/').then((response) => {\n    //   const reader = response.clone().body.getReader()\n    //   readMore()\n    //   function readMore() {\n    //     reader.read().then(\n    //       (result) => {\n    //         if (result.done) {\n    //           console.log('done')\n    //         } else {\n    //           readMore()\n    //         }\n    //       },\n    //       () => console.log('error')\n    //     )\n    //   }\n    //   response.body.getReader().cancel()\n    // })\n    response\n      .clone()\n      .text()\n      .then(\n        monitor((text) => callback(truncateResponseText(text, configuration))),\n        monitor((error) => callback(`Unable to retrieve response: ${error as string}`))\n      )\n  } else if (!response.body) {\n    callback()\n  } else {\n    truncateResponseStream(\n      response.clone().body!,\n      configuration.requestErrorResponseLengthLimit,\n      (error, responseText) => {\n        if (error) {\n          callback(`Unable to retrieve response: ${error as unknown as string}`)\n        } else {\n          callback(responseText)\n        }\n      }\n    )\n  }\n}\n\nfunction isRejected(request: { status: number; responseType?: string }) {\n  return request.status === 0 && request.responseType !== 'opaque'\n}\n\nfunction isServerError(request: { status: number }) {\n  return request.status >= 500\n}\n\nfunction truncateResponseText(responseText: string, configuration: LogsConfiguration) {\n  if (responseText.length > configuration.requestErrorResponseLengthLimit) {\n    return `${responseText.substring(0, configuration.requestErrorResponseLengthLimit)}...`\n  }\n  return responseText\n}\n\nfunction format(type: RequestType) {\n  if (RequestType.XHR === type) {\n    return 'XHR'\n  }\n  return 'Fetch'\n}\n\nfunction truncateResponseStream(\n  stream: ReadableStream<Uint8Array>,\n  limit: number,\n  callback: (error?: Error, responseText?: string) => void\n) {\n  readLimitedAmountOfBytes(stream, limit, (error, bytes, limitExceeded) => {\n    if (error) {\n      callback(error)\n    } else {\n      let responseText = new TextDecoder().decode(bytes)\n      if (limitExceeded) {\n        responseText += '...'\n      }\n      callback(undefined, responseText)\n    }\n  })\n}\n\n/**\n * Read bytes from a ReadableStream until at least `limit` bytes have been read (or until the end of\n * the stream). The callback is invoked with the at most `limit` bytes, and indicates that the limit\n * has been exceeded if more bytes were available.\n */\nfunction readLimitedAmountOfBytes(\n  stream: ReadableStream<Uint8Array>,\n  limit: number,\n  callback: (error?: Error, bytes?: Uint8Array, limitExceeded?: boolean) => void\n) {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n  let readBytesCount = 0\n\n  readMore()\n\n  function readMore() {\n    reader.read().then(\n      monitor((result: ReadableStreamDefaultReadResult<Uint8Array>) => {\n        if (result.done) {\n          onDone()\n          return\n        }\n\n        chunks.push(result.value)\n        readBytesCount += result.value.length\n\n        if (readBytesCount > limit) {\n          onDone()\n        } else {\n          readMore()\n        }\n      }),\n      monitor((error) => callback(error))\n    )\n  }\n\n  function onDone() {\n    reader.cancel().catch(\n      // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n      // as an unhandled rejection\n      noop\n    )\n\n    let completeBuffer: Uint8Array\n    if (chunks.length === 1) {\n      // optim: if the response is small enough to fit in a single buffer (provided by the browser), just\n      // use it directly.\n      completeBuffer = chunks[0]\n    } else {\n      // else, we need to copy buffers into a larger buffer to concatenate them.\n      completeBuffer = new Uint8Array(readBytesCount)\n      let offset = 0\n      chunks.forEach((chunk) => {\n        completeBuffer.set(chunk, offset)\n        offset += chunk.length\n      })\n    }\n\n    callback(undefined, completeBuffer.slice(0, limit), completeBuffer.length > limit)\n  }\n}\n","import { instrumentMethodAndCallOriginal } from '../../tools/instrumentMethod'\nimport { computeStackTrace } from './computeStackTrace'\nimport type { UnhandledErrorCallback, StackTrace } from './types'\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nconst ERROR_TYPES_RE =\n  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/\n\n/**\n * Cross-browser collection of unhandled errors\n *\n * Supports:\n * - Firefox: full stack trace with line numbers, plus column number\n * on top frame; column number is not guaranteed\n * - Opera: full stack trace with line and column numbers\n * - Chrome: full stack trace with line and column numbers\n * - Safari: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n * - IE: line and column number for the top frame only; some frames\n * may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n * - IE5.5+ (only 8.0 tested)\n * - Firefox 0.9+ (only 3.5+ tested)\n * - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n * Exceptions Have Stacktrace to be enabled in opera:config)\n * - Safari 3+ (only 4+ tested)\n * - Chrome 1+ (only 5+ tested)\n * - Konqueror 3.5+ (untested)\n *\n * Tries to catch all unhandled errors and report them to the\n * callback.\n *\n * Callbacks receive a StackTrace object as described in the\n * computeStackTrace docs.\n *\n * @memberof TraceKit\n * @namespace\n */\n\nexport function startUnhandledErrorCollection(callback: UnhandledErrorCallback) {\n  const { stop: stopInstrumentingOnError } = instrumentOnError(callback)\n  const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(callback)\n\n  return {\n    stop: () => {\n      stopInstrumentingOnError()\n      stopInstrumentingOnUnhandledRejection()\n    },\n  }\n}\n\n/**\n * Install a global onerror handler\n */\nfunction instrumentOnError(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onerror', {\n    before(this: any, message: Event | string, url?: string, lineNo?: number, columnNo?: number, errorObj?: Error) {\n      let stack: StackTrace\n\n      if (errorObj) {\n        stack = computeStackTrace(errorObj)\n        callback(stack, errorObj)\n      } else {\n        const location = {\n          url,\n          column: columnNo,\n          line: lineNo,\n        }\n\n        let name\n        let msg = message\n        if ({}.toString.call(message) === '[object String]') {\n          const groups = ERROR_TYPES_RE.exec(msg as string)\n          if (groups) {\n            name = groups[1]\n            msg = groups[2]\n          }\n        }\n\n        stack = {\n          name,\n          message: typeof msg === 'string' ? msg : undefined,\n          stack: [location],\n        }\n\n        callback(stack, message)\n      }\n    },\n  })\n}\n\n/**\n * Install a global onunhandledrejection handler\n */\nfunction instrumentUnhandledRejection(callback: UnhandledErrorCallback) {\n  return instrumentMethodAndCallOriginal(window, 'onunhandledrejection', {\n    before(e: PromiseRejectionEvent) {\n      const reason = e.reason || 'Empty reason'\n      const stack = computeStackTrace(reason)\n      callback(stack, reason)\n    },\n  })\n}\n","import type { RawError } from '../../tools/error'\nimport { ErrorSource, computeRawError, ErrorHandling } from '../../tools/error'\nimport type { Observable } from '../../tools/observable'\nimport { clocksNow } from '../../tools/timeUtils'\nimport { startUnhandledErrorCollection } from '../tracekit'\n\nexport function trackRuntimeError(errorObservable: Observable<RawError>) {\n  return startUnhandledErrorCollection((stackTrace, originalError) => {\n    errorObservable.notify(\n      computeRawError({\n        stackTrace,\n        originalError,\n        startClocks: clocksNow(),\n        nonErrorPrefix: 'Uncaught',\n        source: ErrorSource.SOURCE,\n        handling: ErrorHandling.UNHANDLED,\n      })\n    )\n  })\n}\n","import type { Context, Subscription } from '@datadog/browser-core'\nimport type { LogsEvent } from '../logsEvent.types'\nimport type { CommonContext, RawLogsEvent } from '../rawLogsEvent.types'\nimport type { Logger } from './logger'\n\nexport const enum LifeCycleEventType {\n  RAW_LOG_COLLECTED,\n  LOG_COLLECTED,\n}\n\nexport class LifeCycle {\n  private callbacks: { [key in LifeCycleEventType]?: Array<(data: any) => void> } = {}\n\n  notify<E extends RawLogsEvent = RawLogsEvent>(\n    eventType: LifeCycleEventType.RAW_LOG_COLLECTED,\n    data: RawLogsEventCollectedData<E>\n  ): void\n  notify(eventType: LifeCycleEventType.LOG_COLLECTED, data: LogsEvent & Context): void\n  notify(eventType: LifeCycleEventType, data?: any) {\n    const eventCallbacks = this.callbacks[eventType]\n    if (eventCallbacks) {\n      eventCallbacks.forEach((callback) => callback(data))\n    }\n  }\n  subscribe(\n    eventType: LifeCycleEventType.RAW_LOG_COLLECTED,\n    callback: (data: RawLogsEventCollectedData) => void\n  ): Subscription\n  subscribe(eventType: LifeCycleEventType.LOG_COLLECTED, callback: (data: LogsEvent & Context) => void): Subscription\n  subscribe(eventType: LifeCycleEventType, callback: (data?: any) => void) {\n    if (!this.callbacks[eventType]) {\n      this.callbacks[eventType] = []\n    }\n    this.callbacks[eventType]!.push(callback)\n    return {\n      unsubscribe: () => {\n        this.callbacks[eventType] = this.callbacks[eventType]!.filter((other) => callback !== other)\n      },\n    }\n  }\n}\n\nexport interface RawLogsEventCollectedData<E extends RawLogsEvent = RawLogsEvent> {\n  rawLogsEvent: E\n  messageContext?: object\n  savedCommonContext?: CommonContext\n  logger?: Logger\n}\n","import { defineGlobal, getGlobalObject } from '@datadog/browser-core'\nimport type { LogsPublicApi } from '../boot/logsPublicApi'\nimport { makeLogsPublicApi } from '../boot/logsPublicApi'\nimport { startLogs } from '../boot/startLogs'\n\nexport { Logger, LogsMessage, StatusType, HandlerType } from '../domain/logger'\nexport { LoggerConfiguration, LogsPublicApi as LogsGlobal } from '../boot/logsPublicApi'\nexport { LogsInitConfiguration } from '../domain/configuration'\nexport { LogsEvent } from '../logsEvent.types'\n\nexport const datadogLogs = makeLogsPublicApi(startLogs)\n\ninterface BrowserWindow extends Window {\n  DD_LOGS?: LogsPublicApi\n}\ndefineGlobal(getGlobalObject<BrowserWindow>(), 'DD_LOGS', datadogLogs)\n","import { catchUserErrors } from '../tools/catchUserErrors'\nimport { setDebugMode } from '../tools/monitor'\nimport { assign } from '../tools/utils'\n\n// replaced at build time\ndeclare const __BUILD_ENV__SDK_VERSION__: string\n\nexport function makePublicApi<T>(stub: T): T & { onReady(callback: () => void): void; version: string } {\n  const publicApi = assign(\n    {\n      version: __BUILD_ENV__SDK_VERSION__,\n\n      // This API method is intentionally not monitored, since the only thing executed is the\n      // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n      // we don't want to interfere with the user uncaught exceptions.\n      onReady(callback: () => void) {\n        callback()\n      },\n    },\n    stub\n  )\n\n  // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n  // as much as possible but of course it's not a real protection.\n  Object.defineProperty(publicApi, '_setDebug', {\n    get() {\n      return setDebugMode\n    },\n    enumerable: false,\n  })\n\n  return publicApi\n}\n\nexport function defineGlobal<Global, Name extends keyof Global>(global: Global, name: Name, api: Global[Name]) {\n  const existingGlobalVariable: { q?: Array<() => void> } | undefined = global[name]\n  global[name] = api\n  if (existingGlobalVariable && existingGlobalVariable.q) {\n    existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')())\n  }\n}\n","import type { InitConfiguration } from '@datadog/browser-core'\nimport {\n  assign,\n  BoundedBuffer,\n  createContextManager,\n  makePublicApi,\n  monitor,\n  display,\n  deepClone,\n  canUseEventBridge,\n  timeStampNow,\n} from '@datadog/browser-core'\nimport type { LogsInitConfiguration } from '../domain/configuration'\nimport { validateAndBuildLogsConfiguration } from '../domain/configuration'\nimport type { HandlerType, StatusType, LogsMessage } from '../domain/logger'\nimport { Logger } from '../domain/logger'\nimport type { CommonContext } from '../rawLogsEvent.types'\nimport type { startLogs } from './startLogs'\n\nexport interface LoggerConfiguration {\n  level?: StatusType\n  handler?: HandlerType | HandlerType[]\n  context?: object\n}\n\nexport type LogsPublicApi = ReturnType<typeof makeLogsPublicApi>\n\nexport type StartLogs = typeof startLogs\n\ntype StartLogsResult = ReturnType<typeof startLogs>\n\nexport function makeLogsPublicApi(startLogsImpl: StartLogs) {\n  let isAlreadyInitialized = false\n\n  const globalContextManager = createContextManager()\n  const customLoggers: { [name: string]: Logger | undefined } = {}\n  let getInternalContextStrategy: StartLogsResult['getInternalContext'] = () => undefined\n\n  const beforeInitLoggerLog = new BoundedBuffer()\n\n  let handleLogStrategy: StartLogsResult['handleLog'] = (\n    logsMessage: LogsMessage,\n    logger: Logger,\n    savedCommonContext = deepClone(getCommonContext()),\n    date = timeStampNow()\n  ) => {\n    beforeInitLoggerLog.add(() => handleLogStrategy(logsMessage, logger, savedCommonContext, date))\n  }\n\n  let getInitConfigurationStrategy = (): InitConfiguration | undefined => undefined\n  const mainLogger = new Logger((...params) => handleLogStrategy(...params))\n\n  function getCommonContext(): CommonContext {\n    return {\n      view: {\n        referrer: document.referrer,\n        url: window.location.href,\n      },\n      context: globalContextManager.get(),\n    }\n  }\n\n  return makePublicApi({\n    logger: mainLogger,\n\n    init: monitor((initConfiguration: LogsInitConfiguration) => {\n      if (canUseEventBridge()) {\n        initConfiguration = overrideInitConfigurationForBridge(initConfiguration)\n      }\n\n      if (!canInitLogs(initConfiguration)) {\n        return\n      }\n\n      const configuration = validateAndBuildLogsConfiguration(initConfiguration)\n      if (!configuration) {\n        return\n      }\n\n      ;({ handleLog: handleLogStrategy, getInternalContext: getInternalContextStrategy } = startLogsImpl(\n        initConfiguration,\n        configuration,\n        getCommonContext,\n        mainLogger\n      ))\n\n      getInitConfigurationStrategy = () => deepClone(initConfiguration)\n      beforeInitLoggerLog.drain()\n\n      isAlreadyInitialized = true\n    }),\n\n    /** @deprecated: use getGlobalContext instead */\n    getLoggerGlobalContext: monitor(globalContextManager.get),\n    getGlobalContext: monitor(globalContextManager.getContext),\n\n    /** @deprecated: use setGlobalContext instead */\n    setLoggerGlobalContext: monitor(globalContextManager.set),\n    setGlobalContext: monitor(globalContextManager.setContext),\n\n    /** @deprecated: use setGlobalContextProperty instead */\n    addLoggerGlobalContext: monitor(globalContextManager.add),\n    setGlobalContextProperty: monitor(globalContextManager.setContextProperty),\n\n    /** @deprecated: use removeGlobalContextProperty instead */\n    removeLoggerGlobalContext: monitor(globalContextManager.remove),\n    removeGlobalContextProperty: monitor(globalContextManager.removeContextProperty),\n\n    clearGlobalContext: monitor(globalContextManager.clearContext),\n\n    createLogger: monitor((name: string, conf: LoggerConfiguration = {}) => {\n      customLoggers[name] = new Logger(\n        (...params) => handleLogStrategy(...params),\n        name,\n        conf.handler,\n        conf.level,\n        conf.context\n      )\n\n      return customLoggers[name]!\n    }),\n\n    getLogger: monitor((name: string) => customLoggers[name]),\n\n    getInitConfiguration: monitor(() => getInitConfigurationStrategy()),\n\n    getInternalContext: monitor((startTime?: number | undefined) => getInternalContextStrategy(startTime)),\n  })\n\n  function overrideInitConfigurationForBridge<C extends InitConfiguration>(initConfiguration: C): C {\n    return assign({}, initConfiguration, { clientToken: 'empty' })\n  }\n\n  function canInitLogs(initConfiguration: LogsInitConfiguration) {\n    if (isAlreadyInitialized) {\n      if (!initConfiguration.silentMultipleInit) {\n        display.error('DD_LOGS is already initialized.')\n      }\n      return false\n    }\n    return true\n  }\n}\n","import type { Context, TelemetryEvent, RawError } from '@datadog/browser-core'\nimport {\n  TelemetryService,\n  willSyntheticsInjectRum,\n  areCookiesAuthorized,\n  canUseEventBridge,\n  getEventBridge,\n  startTelemetry,\n  startBatchWithReplica,\n  isTelemetryReplicationAllowed,\n  ErrorSource,\n  addTelemetryConfiguration,\n} from '@datadog/browser-core'\nimport { startLogsSessionManager, startLogsSessionManagerStub } from '../domain/logsSessionManager'\nimport type { LogsConfiguration, LogsInitConfiguration } from '../domain/configuration'\nimport { serializeLogsConfiguration } from '../domain/configuration'\nimport { startLogsAssembly, getRUMInternalContext } from '../domain/assembly'\nimport { startConsoleCollection } from '../domain/logsCollection/console/consoleCollection'\nimport { startReportCollection } from '../domain/logsCollection/report/reportCollection'\nimport { startNetworkErrorCollection } from '../domain/logsCollection/networkError/networkErrorCollection'\nimport { startRuntimeErrorCollection } from '../domain/logsCollection/runtimeError/runtimeErrorCollection'\nimport { LifeCycle, LifeCycleEventType } from '../domain/lifeCycle'\nimport { startLoggerCollection } from '../domain/logsCollection/logger/loggerCollection'\nimport type { CommonContext, RawAgentLogsEvent } from '../rawLogsEvent.types'\nimport { startLogsBatch } from '../transport/startLogsBatch'\nimport { startLogsBridge } from '../transport/startLogsBridge'\nimport type { Logger } from '../domain/logger'\nimport { StatusType } from '../domain/logger'\nimport { startInternalContext } from '../domain/internalContext'\n\nexport function startLogs(\n  initConfiguration: LogsInitConfiguration,\n  configuration: LogsConfiguration,\n  getCommonContext: () => CommonContext,\n  mainLogger: Logger\n) {\n  const lifeCycle = new LifeCycle()\n\n  const reportError = (error: RawError) =>\n    lifeCycle.notify<RawAgentLogsEvent>(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        message: error.message,\n        date: error.startClocks.timeStamp,\n        error: {\n          origin: ErrorSource.AGENT, // Todo: Remove in the next major release\n        },\n        origin: ErrorSource.AGENT,\n        status: StatusType.error,\n      },\n    })\n  const telemetry = startLogsTelemetry(configuration, reportError)\n  telemetry.setContextProvider(() => ({\n    application: {\n      id: getRUMInternalContext()?.application_id,\n    },\n    session: {\n      id: session.findTrackedSession()?.id,\n    },\n    view: {\n      id: (getRUMInternalContext()?.view as Context)?.id,\n    },\n    action: {\n      id: (getRUMInternalContext()?.user_action as Context)?.id,\n    },\n  }))\n\n  startNetworkErrorCollection(configuration, lifeCycle)\n  startRuntimeErrorCollection(configuration, lifeCycle)\n  startConsoleCollection(configuration, lifeCycle)\n  startReportCollection(configuration, lifeCycle)\n  const { handleLog } = startLoggerCollection(lifeCycle)\n\n  const session =\n    areCookiesAuthorized(configuration.cookieOptions) && !canUseEventBridge() && !willSyntheticsInjectRum()\n      ? startLogsSessionManager(configuration)\n      : startLogsSessionManagerStub(configuration)\n\n  startLogsAssembly(session, configuration, lifeCycle, getCommonContext, mainLogger, reportError)\n\n  if (!canUseEventBridge()) {\n    startLogsBatch(configuration, lifeCycle, reportError)\n  } else {\n    startLogsBridge(lifeCycle)\n  }\n\n  addTelemetryConfiguration(serializeLogsConfiguration(initConfiguration))\n  const internalContext = startInternalContext(session)\n\n  return {\n    handleLog,\n    getInternalContext: internalContext.get,\n  }\n}\n\nfunction startLogsTelemetry(configuration: LogsConfiguration, reportError: (error: RawError) => void) {\n  const telemetry = startTelemetry(TelemetryService.LOGS, configuration)\n  if (canUseEventBridge()) {\n    const bridge = getEventBridge<'internal_telemetry', TelemetryEvent>()!\n    telemetry.observable.subscribe((event) => bridge.send('internal_telemetry', event))\n  } else {\n    const telemetryBatch = startBatchWithReplica(\n      configuration,\n      configuration.rumEndpointBuilder,\n      reportError,\n      configuration.replica?.rumEndpointBuilder\n    )\n    telemetry.observable.subscribe((event) => telemetryBatch.add(event, isTelemetryReplicationAllowed(configuration)))\n  }\n  return telemetry\n}\n","import type { Context, RawError, ClocksState } from '@datadog/browser-core'\nimport { noop, ErrorSource, trackRuntimeError, Observable } from '@datadog/browser-core'\nimport type { RawRuntimeLogsEvent } from '../../../rawLogsEvent.types'\nimport type { LogsConfiguration } from '../../configuration'\nimport type { LifeCycle } from '../../lifeCycle'\nimport { LifeCycleEventType } from '../../lifeCycle'\nimport { StatusType } from '../../logger'\n\nexport interface ProvidedError {\n  startClocks: ClocksState\n  error: unknown\n  context?: Context\n  handlingStack: string\n}\n\nexport function startRuntimeErrorCollection(configuration: LogsConfiguration, lifeCycle: LifeCycle) {\n  if (!configuration.forwardErrorsToLogs) {\n    return { stop: noop }\n  }\n\n  const rawErrorObservable = new Observable<RawError>()\n\n  const { stop: stopRuntimeErrorTracking } = trackRuntimeError(rawErrorObservable)\n\n  const rawErrorSubscription = rawErrorObservable.subscribe((rawError) => {\n    lifeCycle.notify<RawRuntimeLogsEvent>(LifeCycleEventType.RAW_LOG_COLLECTED, {\n      rawLogsEvent: {\n        message: rawError.message,\n        date: rawError.startClocks.timeStamp,\n        error: {\n          kind: rawError.type,\n          origin: ErrorSource.SOURCE, // Todo: Remove in the next major release\n          stack: rawError.stack,\n        },\n        origin: ErrorSource.SOURCE,\n        status: StatusType.error,\n      },\n    })\n  })\n\n  return {\n    stop: () => {\n      stopRuntimeErrorTracking()\n      rawErrorSubscription.unsubscribe()\n    },\n  }\n}\n","import type { RelativeTime } from '@datadog/browser-core'\nimport type { LogsSessionManager } from './logsSessionManager'\n\nexport interface InternalContext {\n  session_id: string | undefined\n}\n\nexport function startInternalContext(sessionManager: LogsSessionManager) {\n  return {\n    get: (startTime?: number): InternalContext | undefined => {\n      const trackedSession = sessionManager.findTrackedSession(startTime as RelativeTime)\n      if (trackedSession) {\n        return {\n          session_id: trackedSession.id,\n        }\n      }\n    },\n  }\n}\n","import type { Context } from '@datadog/browser-core'\nimport { getEventBridge } from '@datadog/browser-core'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport function startLogsBridge(lifeCycle: LifeCycle) {\n  const bridge = getEventBridge<'log', LogsEvent>()!\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (serverLogsEvent: LogsEvent & Context) => {\n    bridge.send('log', serverLogsEvent)\n  })\n}\n","import type { Context, RawError } from '@datadog/browser-core'\nimport { startBatchWithReplica } from '@datadog/browser-core'\nimport type { LogsConfiguration } from '../domain/configuration'\nimport type { LifeCycle } from '../domain/lifeCycle'\nimport { LifeCycleEventType } from '../domain/lifeCycle'\nimport type { LogsEvent } from '../logsEvent.types'\n\nexport function startLogsBatch(\n  configuration: LogsConfiguration,\n  lifeCycle: LifeCycle,\n  reportError: (error: RawError) => void\n) {\n  const batch = startBatchWithReplica(\n    configuration,\n    configuration.logsEndpointBuilder,\n    reportError,\n    configuration.replica?.logsEndpointBuilder\n  )\n\n  lifeCycle.subscribe(LifeCycleEventType.LOG_COLLECTED, (serverLogsEvent: LogsEvent & Context) => {\n    batch.add(serverLogsEvent)\n  })\n}\n"],"sourceRoot":""}